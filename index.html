<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelike åœ°ç‰¢æ¢ç´¢</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #111;
            color: #eee;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 1000px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        
        #game-title {
            color: #ff5555;
            text-shadow: 0 0 5px #ff0000, 0 0 15px #ff0000;
            margin-bottom: 10px;
            font-size: 2.5em;
            letter-spacing: 2px;
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(30, 16px);
            grid-template-rows: repeat(25, 16px);
            gap: 1px;
            background-color: #333;
            border: 2px solid #555;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: fit-content;
            margin: 0 auto;
        }
        
        .cell {
            width: 16px;
            height: 16px;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            user-select: none;
            transition: background-color 0.1s ease;
        }
        
        .wall {
            background-color: #555;
            border-radius: 3px;
        }
        
        .player {
            color: #55ff55;
            font-weight: bold;
            text-shadow: 0 0 3px #00ff00;
        }
        
        .enemy {
            color: #ff5555;
            text-shadow: 0 0 3px #ff0000;
        }
        
        .item {
            color: #5599ff;
            text-shadow: 0 0 3px #0066ff;
        }
        
        .exit {
            color: #ffff55;
            text-shadow: 0 0 3px #ffff00;
            animation: pulse 1.5s infinite;
        }
        
        .explored {
            background-color: #333;
        }
        
        #stats {
            display: flex;
            justify-content: space-around;
            width: 580px;
            margin-bottom: 10px;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        #stats div {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        #stats span {
            color: #ffcc44;
            font-weight: bold;
            margin-left: 5px;
        }

        /* ç”Ÿå‘½å€¼è¿›åº¦æ¡æ ·å¼ */
        #health-bar {
            width: 100px;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-left: 5px;
        }
        
        #health-fill {
            height: 100%;
            background-color: #5f5;
            transition: width 0.3s ease;
        }
        
        #message-log {
            width: 580px;
            height: 100px;
            border: 1px solid #555;
            padding: 10px;
            overflow-y: auto;
            background-color: #111;
            font-size: 14px;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #controls {
            margin-top: 20px;
        }
        
        button {
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            padding: 8px 15px;
            margin: 0 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background-color: #444;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #ff0000;
            text-align: center;
            display: none;
        }
        
        #game-over h2 {
            color: #ff0000;
            margin-top: 0;
        }

        /* æ·»åŠ å•†åº—æ ·å¼ */
        #shop-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            z-index: 1000;
            min-width: 300px;
        }

        #shop-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background-color: #333;
            border: 1px solid #444;
        }

        .shop-item button {
            background-color: #4a4;
            border: none;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
        }

        .shop-item button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .shop-item-price {
            color: #ff5;
        }

        /* æ·»åŠ èŒä¸šé€‰æ‹©æ¨¡æ€æ¡†æ ·å¼ */
        #class-select-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }

        #class-select-container {
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
            max-width: 1200px;
            text-align: center;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .class-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .class-card {
            width: 200px;
            height: 250px;
            background-color: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .class-card:hover {
            border-color: #ffcc44;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(255, 204, 68, 0.3);
        }

        .class-card.selected {
            border-color: #5f5;
            box-shadow: 0 0 15px rgba(85, 255, 85, 0.5);
        }

        /* éš¾åº¦é€‰æ‹©æ ·å¼ */
        .difficulty-options {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .difficulty-card {
            width: 160px;
            min-height: 110px;
            background-color: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .difficulty-card:hover {
            border-color: #ffcc44;
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(255, 204, 68, 0.25);
        }
        .difficulty-card.selected {
            border-color: #5f5;
            box-shadow: 0 0 12px rgba(85, 255, 85, 0.45);
        }
        .difficulty-name {
            font-size: 16px;
            font-weight: bold;
            color: #ffcc44;
            margin-bottom: 6px;
        }
        .difficulty-desc {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffcc44;
        }

        .class-symbol {
            font-size: 32px;
            margin: 10px 0;
        }

        .class-desc {
            font-size: 12px;
            text-align: center;
            color: #ccc;
        }

        .class-stats {
            margin-top: 10px;
            font-size: 12px;
            text-align: left;
            width: 100%;
        }

        .start-game-btn {
            background-color: #4a4;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        .start-game-btn:hover {
            background-color: #5c5;
            box-shadow: 0 0 10px rgba(85, 255, 85, 0.5);
        }

        /* ä¸ªäººè®°å½•æ ·å¼ */
        #record-panel {
            margin-top: 16px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            text-align: left;
        }
        #record-panel h3 {
            color: #ffcc44;
            margin: 0 0 8px 0;
            font-size: 16px;
            border-bottom: 1px dotted #444;
            padding-bottom: 6px;
        }
        #record-content {
            color: #ddd;
            font-size: 13px;
            line-height: 1.6;
        }
        #record-content .muted { color: #aaa; }

        /* å±‚çº§ä¸»é¢˜æ ·å¼ */
        .theme-cave .cell {
            background-color: #223;
        }
        .theme-cave .wall {
            background-color: #446;
        }
        .theme-cave .explored {
            background-color: #334;
        }

        .theme-forest .cell {
            background-color: #232;
        }
        .theme-forest .wall {
            background-color: #464;
        }
        .theme-forest .explored {
            background-color: #343;
        }

        .theme-ruins .cell {
            background-color: #322;
        }
        .theme-ruins .wall {
            background-color: #644;
        }
        .theme-ruins .explored {
            background-color: #433;
        }

        .theme-crystal .cell {
            background-color: #225;
        }
        .theme-crystal .wall {
            background-color: #44a;
        }
        .theme-crystal .explored {
            background-color: #336;
        }

        .theme-volcanic .cell {
            background-color: #422;
        }
        .theme-volcanic .wall {
            background-color: #622;
        }
        .theme-volcanic .explored {
            background-color: #533;
        }

        /* æ–°å¢åœ°åŸŸæ ·å¼ */
        .theme-desert .cell {
            background-color: #542;
        }
        .theme-desert .wall {
            background-color: #875;
        }
        .theme-desert .explored {
            background-color: #653;
        }

        .theme-ice .cell {
            background-color: #e0f7ff; /* æ›´äº®æ›´æ¥è¿‘ç™½è‰² */
        }
        .theme-ice .wall {
            background-color: #7ecbff; /* æ›´æ·±çš„è“è‰²ï¼Œçªå‡ºå¢™ä½“ */
        }
        .theme-ice .explored {
            background-color: #cbeaff; /* é€‚ä¸­äº®åº¦ï¼Œå’ŒcellåŒºåˆ† */
        }

        .theme-void .cell {
            background-color: #204;
        }
        .theme-void .wall {
            background-color: #506;
        }
        .theme-void .explored {
            background-color: #315;
        }

        /* BOSSæ ·å¼ */
        .boss {
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 8px #ff0000;
            animation: boss-pulse 1.2s infinite;
        }
        
        @keyframes boss-pulse {
            0% { text-shadow: 0 0 4px #ff0000; }
            50% { text-shadow: 0 0 12px #ff0000; }
            100% { text-shadow: 0 0 4px #ff0000; }
        }

        /* å›¾é‰´æ ·å¼ */
        #codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        #codex-container {
            max-width: 800px;
            margin: 50px auto;
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
        }

        .codex-section {
            margin-bottom: 20px;
        }

        .codex-title {
            color: #ffcc44;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }

        .codex-item {
            background-color: #333;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
        }

        .codex-item-name {
            color: #5599ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .codex-item-desc {
            font-size: 12px;
            color: #ccc;
        }

        .codex-close {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .codex-tabs {
            display: flex;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .codex-tab {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #333;
            border: 1px solid #444;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }

        .codex-tab.active {
            background-color: #444;
            color: #ffcc44;
        }

        .codex-content {
            display: none;
        }

        .codex-content.active {
            display: block;
        }

        /* ä¸»é¢˜æ˜¾ç¤ºæ ·å¼ */
        #theme-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #444;
            color: #ffcc44;
            font-size: 14px;
        }
        
        /* å•†åº—ç‰©å“æè¿° */
        .shop-item {
            position: relative;
        }
        
        .shop-item-tooltip {
            display: none;
            position: absolute;
            top: -5px;
            left: 105%;
            width: 200px;
            background-color: #111;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px;
            font-size: 12px;
            z-index: 100;
            color: #ccc;
        }
        
        .shop-item:hover .shop-item-tooltip {
            display: block;
        }
        
        .shop-item-tooltip-title {
            color: #5599ff;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
        }

        /* ç‰¹æ®Šæˆ¿é—´æ ·å¼ */
        .special-room {
            color: #ffaa00;
            text-shadow: 0 0 5px #ff8800;
            animation: special-room-pulse 2s infinite;
            cursor: pointer;
        }

        @keyframes special-room-pulse {
            0% { text-shadow: 0 0 3px #ff8800; }
            50% { text-shadow: 0 0 8px #ff8800; }
            100% { text-shadow: 0 0 3px #ff8800; }
        }

        /* ç‰¹æ®Šæˆ¿é—´æç¤ºæ¡†æ ·å¼ */
        .cell[title] {
            position: relative;
        }

        .cell[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* æ·»åŠ å¸®åŠ©å¯¹è¯æ¡†æ ·å¼ */
        #help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        #help-container {
            max-width: 800px;
            margin: 50px auto;
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            color: #eee;
            line-height: 1.6;
        }

        #help-container h2 {
            color: #ffcc44;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        #help-container h3 {
            color: #5599ff;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px dotted #444;
            padding-bottom: 5px;
        }

        #help-container ul {
            margin: 10px 0;
            padding-left: 25px;
        }

        #help-container li {
            margin-bottom: 5px;
        }

        #help-close {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        #help-close:hover {
            background-color: #555;
        }

        .theme-ice .cell,
        .theme-ice .wall,
        .theme-ice .explored {
            color: #111 !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 id="game-title">Roguelike åœ°ç‰¢æ¢ç´¢</h1>
        
        <div id="stats">
            <div>æ·±åº¦: <span id="depth">1</span></div>
            <div>ç”Ÿå‘½: <span id="health">10</span>/<span id="max-health">10</span>
                <div id="health-bar"><div id="health-fill" style="width: 100%"></div></div>
            </div>
            <div>æ”»å‡»: <span id="attack">3</span></div>
            <div>é˜²å¾¡: <span id="defense">1</span></div>
            <div>é‡‘å¸: <span id="gold">0</span></div>
        </div>
        
        <div id="theme-display">å½“å‰åŒºåŸŸ: <span id="current-theme">æ´ç©´</span></div>
        
        <div id="game-board"></div>
        
        <div id="message-log"></div>
        
        <div id="record-panel" style="width:580px;">
            <h3>ä¸ªäººè®°å½•</h3>
            <div id="record-content" class="muted">æš‚æ— è®°å½•</div>
        </div>
        
        <div id="controls">
            <button id="new-game-btn">æ–°æ¸¸æˆ</button>
            <button id="save-btn">å­˜æ¡£</button>
            <button id="load-btn">è¯»æ¡£</button>
            <button id="help-btn">å¸®åŠ©</button>
            <button id="codex-btn">å›¾é‰´</button>
        </div>
    </div>
    
    <div id="game-over">
        <h2>æ¸¸æˆç»“æŸ!</h2>
        <p>ä½ åˆ°è¾¾äº†ç¬¬ <span id="final-depth">1</span> å±‚</p>
        <p>å‡»è´¥äº† <span id="enemies-defeated">0</span> ä¸ªæ•Œäºº</p>
        <p>æ”¶é›†äº† <span id="final-gold">0</span> é‡‘å¸</p>
        <button id="restart-btn">é‡æ–°å¼€å§‹</button>
    </div>

    <!-- æ·»åŠ å•†åº—æ¨¡æ€æ¡† -->
    <div id="shop-modal">
        <h2>å•†åº—</h2>
        <div id="shop-items"></div>
        <!-- å•†åº—å…³é—­æŒ‰é’® -->
        <button onclick="closeShop()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">ç¦»å¼€å•†åº—</button>
    </div>

    <!-- æ·»åŠ èŒä¸šé€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="class-select-modal">
        <div id="class-select-container">
            <h2>é€‰æ‹©ä½ çš„èŒä¸š</h2>
            <div style="margin-top:8px; font-size:14px; color:#bbb">è¯·é€‰æ‹©èŒä¸šä¸éš¾åº¦åå¼€å§‹</div>
            <div class="difficulty-options">
                <div class="difficulty-card" onclick="selectDifficulty('easy')">
                    <div class="difficulty-name">ç®€å•</div>
                    <div class="difficulty-desc">ç©å®¶æ›´å¼ºï¼Œæ•Œäººæ›´å¼±ï¼Œæ›´å¤šæ‰è½ä¸æ›´ä¾¿å®œçš„å•†åº—ã€‚</div>
                </div>
                <div class="difficulty-card selected" onclick="selectDifficulty('normal')">
                    <div class="difficulty-name">æ™®é€š</div>
                    <div class="difficulty-desc">æ ‡å‡†ä½“éªŒï¼Œå¹³è¡¡çš„æ•Œäººä¸å¥–åŠ±ã€‚</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('hard')">
                    <div class="difficulty-name">å›°éš¾</div>
                    <div class="difficulty-desc">æ•Œäººæ›´å¼ºæ›´å¯†é›†ï¼Œé“å…·æ›´å°‘ï¼Œå•†åº—æ›´è´µã€‚</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('diyu')">
                    <div class="difficulty-name">åœ°ç‹±</div>
                    <div class="difficulty-desc">å¼ºæ•Œéåœ°ï¼Œå¥–åŠ±å‡å°‘ï¼Œæå…·æŒ‘æˆ˜æ€§ã€‚</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('ultra')">
                    <div class="difficulty-name">ULTRA</div>
                    <div class="difficulty-desc">æé™éš¾åº¦ï¼šæ•Œäººæå¼ºä¸”ä¼—å¤šï¼Œé“å…·ç¨€ç¼ºã€‚</div>
                </div>
            </div>
            <div class="class-options">
                <div class="class-card" onclick="selectClass('warrior')">
                    <div class="class-name">æˆ˜å£«</div>
                    <div class="class-symbol">âš”ï¸</div>
                    <div class="class-desc">å¼ºå¤§çš„è¿‘æˆ˜èŒä¸šï¼Œæ“…é•¿ä¸æ•Œäººæ­£é¢äº¤é”‹</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 12<br>
                        åˆå§‹æ”»å‡»: 2<br>
                        åˆå§‹é˜²å¾¡: 2<br>
                        ç‰¹æ®Šèƒ½åŠ›: å¢åŠ ä¼¤å®³5%, å¢åŠ é˜²å¾¡10%
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('rogue')">
                    <div class="class-name">ç›—è´¼</div>
                    <div class="class-symbol">ğŸ—¡ï¸</div>
                    <div class="class-desc">çµæ´»çš„åˆºå®¢ï¼Œå–„äºå¯»æ‰¾å®ç‰©</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 8<br>
                        åˆå§‹æ”»å‡»: 3<br>
                        åˆå§‹é˜²å¾¡: 1<br>
                        ç‰¹æ®Šèƒ½åŠ›: é‡‘å¸è·å–+20%, 20%å‡ ç‡é—ªé¿æ”»å‡»
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('mage')">
                    <div class="class-name">æ³•å¸ˆ</div>
                    <div class="class-symbol">âœ¨</div>
                    <div class="class-desc">ç¥ç§˜çš„é­”æ³•ä½¿ç”¨è€…ï¼Œæ‹¥æœ‰å¼ºå¤§çš„ç ´ååŠ›</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 7<br>
                        åˆå§‹æ”»å‡»: 4<br>
                        åˆå§‹é˜²å¾¡: 2<br>
                        ç‰¹æ®Šèƒ½åŠ›: 20%å‡ ç‡é€ æˆåŒå€ä¼¤å®³ï¼Œå•†åº—å•†å“é™ä»·15%
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('cleric')">
                    <div class="class-name">ç‰§å¸ˆ</div>
                    <div class="class-symbol">âœï¸</div>
                    <div class="class-desc">ç¥åœ£çš„æ²»ç–—è€…ï¼Œæ‹¥æœ‰è¶…å¼ºçš„ç”Ÿå­˜èƒ½åŠ›</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 10<br>
                        åˆå§‹æ”»å‡»: 1<br>
                        åˆå§‹é˜²å¾¡: 2<br>
                        ç‰¹æ®Šèƒ½åŠ›: æ²»ç–—æ•ˆæœå¢åŠ 50%, 30%å‡ ç‡åœ¨ä¸€å¼ åœ°å›¾å†…å‡ºç°ç¬¬äºŒä¸ªå•†åº—
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('hunter')">
                    <div class="class-name">çŒäºº</div>
                    <div class="class-symbol">ğŸ¹</div>
                    <div class="class-desc">æ“…é•¿é™·é˜±ä¸è¿œç¨‹æ”»å‡»çš„è’é‡ä¸“å®¶</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 9<br>
                        åˆå§‹æ”»å‡»: 2<br>
                        åˆå§‹é˜²å¾¡: 1<br>
                        ç‰¹æ®Šèƒ½åŠ›: 15%å‡ ç‡æš´å‡», 20%å‡ ç‡åå‡»æ•Œäºº, 5ç èŒƒå›´BOSSè§†é‡
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('warlock')">
                    <div class="class-name">æœ¯å£«</div>
                    <div class="class-symbol">ğŸ”®</div>
                    <div class="class-desc">ä½¿ç”¨é»‘æš—åŠ›é‡çš„æ–½æ³•è€…ï¼Œå¯å¸è¡€</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 11<br>
                        åˆå§‹æ”»å‡»: 2<br>
                        åˆå§‹é˜²å¾¡: 0<br>
                        ç‰¹æ®Šèƒ½åŠ›: 50%å‡ ç‡å¸è¡€, BOSSå±‚å¢åŠ 10%ç”Ÿå‘½ä¸Šé™
                    </div>
                </div>
                <div class="class-card devpro-card" onclick="selectClass('devpro')" style="display:none">
                    <div class="class-name">å¼€å‘è€…Pro</div>
                    <div class="class-symbol">ğŸ’»</div>
                    <div class="class-desc">éšè—èŒä¸šï¼Œæ‹¥æœ‰æé™å±æ€§å’Œæ— é™é‡‘å¸</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 100<br>
                        åˆå§‹æ”»å‡»: 100<br>
                        åˆå§‹é˜²å¾¡: 100<br>
                        ç‰¹æ®Šèƒ½åŠ›: æ— é™é‡‘å¸
                    </div>
                </div>
                <div class="class-card devair-card" onclick="selectClass('devair')" style="display:none">
                    <div class="class-name">å¼€å‘è€…Air</div>
                    <div class="class-symbol">ğŸ›¸</div>
                    <div class="class-desc">éšè—èŒä¸šï¼Œå¯ä»¥ç¬ç§»åˆ°ä»»ä½•åŒºåŸŸ</div>
                    <div class="class-stats">
                        åˆå§‹ç”Ÿå‘½: 50<br>
                        åˆå§‹æ”»å‡»: 50<br>
                        åˆå§‹é˜²å¾¡: 50<br>
                        ç‰¹æ®Šèƒ½åŠ›: ç¬ç§»åˆ°ä»»æ„åŒºåŸŸ
                    </div>
                </div>
            </div>
            <div style="margin-top:10px; color:#bbb; font-size:13px;">æç¤ºï¼šåœ¨æ­¤ç•Œé¢æŒ‰ç©ºæ ¼é”®å¯ç›´æ¥å¼€å§‹æ¸¸æˆ</div>
            <button class="start-game-btn" onclick="startGameWithClass()">å¼€å§‹å†’é™©</button>
        </div>
    </div>

    <!-- æ·»åŠ å›¾é‰´æ¨¡æ€æ¡† -->
    <div id="codex-modal">
        <div id="codex-container">
            <h2>æ¢ç´¢å›¾é‰´</h2>
            
            <div class="codex-tabs">
                <div class="codex-tab active" onclick="showCodexTab('monsters')">æ€ªç‰©</div>
                <div class="codex-tab" onclick="showCodexTab('items')">ç‰©å“</div>
                <div class="codex-tab" onclick="showCodexTab('bosses')">BOSS</div>
                <div class="codex-tab" onclick="showCodexTab('themes')">åœ°åŸŸ</div>
                <div class="codex-tab" onclick="showCodexTab('special')">ç‰¹æ®Šæˆ¿é—´</div>
            </div>
            
            <div id="monsters-content" class="codex-content active">
                <div class="codex-grid" id="monsters-grid"></div>
            </div>
            
            <div id="items-content" class="codex-content">
                <div class="codex-grid" id="items-grid"></div>
            </div>
            
            <div id="bosses-content" class="codex-content">
                <div class="codex-grid" id="bosses-grid"></div>
            </div>
            
            <div id="themes-content" class="codex-content">
                <div class="codex-grid" id="themes-grid"></div>
            </div>
            
            <div id="special-content" class="codex-content">
                <div class="codex-grid" id="special-grid"></div>
            </div>
            
            <!-- å›¾é‰´å…³é—­æŒ‰é’® -->
            <button class="codex-close" onclick="closeCodex()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-top: 20px; display: block; margin-left: auto; margin-right: auto;">å…³é—­</button>
        </div>
    </div>

    <!-- æ·»åŠ å¸®åŠ©å¯¹è¯æ¡† -->
    <div id="help-modal">
        <div id="help-container">
            <h2>åœ°ç‰¢æ¢ç´¢ - å¥‡å¹»å†’é™©æ¸¸æˆ</h2>
            <p id="birthday-message" style="display: none; text-align: center; color: #ffcc44; font-size: 18px; margin-top: -10px; margin-bottom: 20px;">å‘¨æ¢“è½©ç”Ÿæ—¥å¿«ä¹</p>
            
            <h3>æ§åˆ¶æ–¹å¼</h3>
            <ul>
                <li>W - å‘ä¸Šç§»åŠ¨</li>
                <li>S - å‘ä¸‹ç§»åŠ¨</li>
                <li>A - å‘å·¦ç§»åŠ¨</li>
                <li>D - å‘å³ç§»åŠ¨</li>
                <li>E - åœ¨å•†åº—ä½ç½®æ—¶æ‰“å¼€å•†åº—</li>
                <li>é¼ æ ‡ç‚¹å‡» - ç§»åŠ¨åˆ°ç›®æ ‡ä½ç½®</li>
            </ul>
            
            <h3>éš¾åº¦</h3>
            <ul>
                <li>ç®€å•ï¼šæ•Œäººå±æ€§â†“ï¼Œæ•°é‡â†“ï¼Œé“å…·â†‘ï¼Œå•†åº—æ›´ä¾¿å®œï¼Œé‡‘å¸æ›´å¤šï¼Œç©å®¶åˆå§‹ç”Ÿå‘½+2ã€é˜²å¾¡+1ã€‚</li>
                <li>æ™®é€šï¼šæ ‡å‡†è§„åˆ™ã€‚</li>
                <li>å›°éš¾ï¼šæ•Œäººå±æ€§â†‘ï¼Œæ•°é‡â†‘ï¼Œé“å…·â†“ï¼Œå•†åº—æ›´è´µï¼Œé‡‘å¸ç•¥å°‘ã€‚</li>
                <li>åœ°ç‹±ï¼šå¼ºæ•Œéåœ°ï¼Œå•†åº—å¾ˆè´µï¼Œé“å…·åå°‘ï¼Œé‡‘å¸æ›´å°‘ï¼Œç©å®¶åˆå§‹ç”Ÿå‘½-2ã€é˜²å¾¡-1ã€‚</li>
                <li>ULTRAï¼šæé™æŒ‘æˆ˜ï¼Œæ•Œäººæå¼ºä¸”æ›´å¤šï¼Œé“å…·æå°‘ï¼Œå•†åº—æœ€è´µï¼Œé‡‘å¸æœ€å°‘ã€‚</li>
            </ul>
            
            <div style="margin: 6px 0 12px 0; color:#bbb; font-size:13px;">åœ¨èŒä¸š/éš¾åº¦é€‰æ‹©ç•Œé¢ï¼ŒæŒ‰ç©ºæ ¼é”®å¯ç›´æ¥å¼€å§‹æ¸¸æˆã€‚</div>
            <h3>æ¸¸æˆç›®æ ‡</h3>
            <ul>
                <li>æ¢ç´¢éšæœºç”Ÿæˆçš„åœ°ç‰¢</li>
                <li>æ”¶é›†é‡‘å¸å’Œå„ç§ç‰©å“</li>
                <li>æ‰¾åˆ°æ¥¼æ¢¯(>)å‰å¾€ä¸‹ä¸€å±‚</li>
                <li>å‡»è´¥æ•Œäººè·å–å¥–åŠ±</li>
                <li>åœ¨å•†åº—(S)å¤„ä½¿ç”¨é‡‘å¸è´­ä¹°å¼ºåŠ›ç‰©å“</li>
                <li>æ¢ç´¢ç‰¹æ®Šæˆ¿é—´è·å¾—ç‹¬ç‰¹æ•ˆæœ</li>
            </ul>
            
            <h3>æ•Œäººç±»å‹</h3>
            <ul>
                <li>åŸºæœ¬æ•Œäºº - å°è™è (b)ã€éª·é«…(s)ã€èœ˜è››(p)ã€åƒµå°¸(z)ã€åœ°ç²¾(g)</li>
                <li>é«˜çº§æ•Œäºº - é­”æ³•å¸ˆ(m)ã€çŸ³åƒé¬¼(t)ã€æš—å½±åˆºå®¢(a)ï¼ˆå‰ä¸‰å±‚ä¸å‡ºç°ï¼›ç¬¬4å±‚å¼€å§‹â€œå‡çº§æ€ªç‰©â€å‡ºç°ï¼‰</li>
                <li>BOSS - æ¯8å±‚å‡ºç°ä¸€ä¸ªå¼ºå¤§çš„BOSSï¼Œæ‹¥æœ‰ç‰¹æ®Šèƒ½åŠ›</li>
            </ul>
            
            <h3>åœ°åŸŸç±»å‹</h3>
            <ul>
                <li>åŸºç¡€åŒºåŸŸ - æ´ç©´ã€è¿·é›¾æ£®æ—ã€è¿œå¤é—è¿¹ã€æ°´æ™¶æ´çªŸã€ç«å±±æ·±å¤„</li>
                <li>é«˜çº§åŒºåŸŸ - æ²™æ¼ ç¥æ®¿ã€å†°å†»å³¡è°·ã€è™šç©ºè£‚éš™</li>
            </ul>
            
            <h3>ç‰¹æ®Šæˆ¿é—´</h3>
            <ul>
                <li>ç¥­å›(A) - çŒ®ç¥­é‡‘å¸è·å¾—éšæœºå¢ç›Š</li>
                <li>è®­ç»ƒåœº(T) - æ¶ˆè€—é‡‘å¸æå‡æˆ˜æ–—èƒ½åŠ›</li>
                <li>ç”Ÿå‘½ä¹‹æ³‰(F) - æ¢å¤éƒ¨åˆ†ç”Ÿå‘½å€¼</li>
                <li>å®è—å®¤(V) - è·å¾—é‡‘å¸ä½†å¯èƒ½æœ‰é™·é˜±</li>
                <li>å†¥æƒ³æ± (M) - éšæœºæå‡ä¸¤ç§å±æ€§</li>
                <li>é”»é€ ç‚‰(K) - ç”¨é‡‘å¸å¼ºåŒ–æ­¦å™¨æˆ–é˜²å…·</li>
            </ul>
            
            <h3>æ¸¸æˆç‰¹ç‚¹</h3>
            <ul>
                <li>æ¯æ¬¡ç”Ÿæˆå…¨æ–°éšæœºåœ°ç‰¢</li>
                <li>æ­»äº¡å³ç»“æŸï¼Œæ²¡æœ‰é‡ç”Ÿ</li>
                <li>éšç€æ·±å…¥åœ°ç‰¢ï¼Œæ•Œäººè¶Šæ¥è¶Šå¼º</li>
                <li>å¤šç§æ•Œäººå’Œç‰©å“ç­‰å¾…å‘ç°</li>
                <li>å…­ç§ä¸åŒèŒä¸šï¼Œå„å…·ç‰¹è‰²</li>
                <li>æ¯8å±‚å‡ºç°å¼ºå¤§BOSS</li>
                <li>ç¬¬4å±‚å¼€å§‹ä¼šå‡ºç°â€œå‡çº§æ€ªç‰©â€ã€‚</li>
                <li>æŒ‘æˆ˜è‡ªæˆ‘ï¼Œçœ‹çœ‹èƒ½è¾¾åˆ°å¤šæ·±çš„åœ°ç‰¢å±‚æ•°ï¼</li>
            </ul>
            
            <!-- å¸®åŠ©å¯¹è¯æ¡†å…³é—­æŒ‰é’® -->
            <button id="help-close" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-top: 20px; display: block; margin-left: auto; margin-right: auto;">å…³é—­</button>
        </div>
    </div>

    <!-- æ·»åŠ å­˜æ¡£é€‰æ‹©æ¨¡æ€æ¡† -->
    <div id="save-load-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="background-color: #222; padding: 20px; border: 2px solid #555; border-radius: 10px; max-width: 400px; margin: 50px auto; text-align: center;">
            <h2 id="modal-title">é€‰æ‹©å­˜æ¡£æ§½</h2>
            <div id="save-slots" style="margin: 20px 0;">
                <!-- å­˜æ¡£æ§½å°†é€šè¿‡JSåŠ¨æ€ç”Ÿæˆ -->
            </div>
            <button onclick="closeSaveLoadModal()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">å–æ¶ˆ</button>
        </div>
    </div>

    <script>
        // æ¸¸æˆçŠ¶æ€
        const gameState = {
            player: { 
                x: 0, y: 0, 
                health: 10,
                maxHealth: 10, 
                attack: 3, 
                defense: 1, 
                gold: 0,
                class: '',
                classAbilities: {}
            },
            depth: 1,
            enemiesDefeated: 0,
            map: [],
            explored: [],
            enemies: [],
            items: [],
            exit: { x: 0, y: 0 },
            gameOver: false,
            messages: [],
            shop: { x: 0, y: 0, items: [] },
            theme: 'cave',  // åˆå§‹ä¸»é¢˜
            fullRenderNeeded: true, // æ·»åŠ å…¨æ¸²æŸ“æ ‡è®°
            // æ·»åŠ ç”¨äºä¼˜åŒ–çš„ä½ç½®æ˜ å°„
            entityMap: {
                enemies: {}, // æ ¼å¼: "x,y": enemyIndex
                items: {},   // æ ¼å¼: "x,y": itemIndex
            },
            specialRooms: [], // æ·»åŠ ç‰¹æ®Šæˆ¿é—´æ•°ç»„
            // æ€§èƒ½ç›¸å…³å±æ€§
            renderPending: false,     // æ¸²æŸ“è¯·æ±‚æ ‡å¿—
            updateNeeded: false,      // æ›´æ–°è¯·æ±‚æ ‡å¿—
            lastFrameTime: 0,         // ä¸Šä¸€å¸§æ—¶é—´
            fps: 0,                   // å½“å‰FPS
            visibleCells: new Set(),  // å¯è§å•å…ƒæ ¼ç¼“å­˜
            // ç©ºé—´åˆ†åŒºç³»ç»Ÿ - å°†åœ°å›¾åˆ†ä¸ºå¤šä¸ªåŒºå—ä»¥åŠ é€Ÿç¢°æ’æ£€æµ‹
            spatialGrid: {
                cellSize: 5,  // æ¯ä¸ªåŒºå—å¤§å°
                grid: {},     // ç©ºé—´åˆ†åŒºç½‘æ ¼
                rebuild: true // æ˜¯å¦éœ€è¦é‡å»ºç½‘æ ¼
            },
            // åœ¨å…¨å±€çŠ¶æ€æ·»åŠ bossDefeatCount
            bossDefeatCount: 0,
            birthdayEnabled: false, // ç”Ÿæ—¥ç¥ç¦æ˜¯å¦æ¿€æ´»
            saveSlots: [null, null, null], // 3ä¸ªå­˜æ¡£æ§½
            currentSaveSlot: -1, // å½“å‰ä½¿ç”¨çš„å­˜æ¡£æ§½
            difficulty: 'normal',
        };

        // å¯¹è±¡æ± ç³»ç»Ÿ - ç”¨äºé‡ç”¨å¯¹è±¡ä»¥å‡å°‘åƒåœ¾å›æ”¶
        const objectPool = {
            // å®ä½“æ± 
            entities: [],
            // è·å–ä¸€ä¸ªå®ä½“å¯¹è±¡
            getEntity() {
                if (this.entities.length > 0) {
                    return this.entities.pop();
                }
                return {}; // åˆ›å»ºæ–°å¯¹è±¡
            },
            // å›æ”¶ä¸€ä¸ªå®ä½“å¯¹è±¡
            recycleEntity(entity) {
                // æ¸…ç©ºå¯¹è±¡å±æ€§
                for (const key in entity) {
                    if (typeof entity[key] !== 'object') {
                        entity[key] = null;
                    } else if (entity[key] !== null) {
                        Object.keys(entity[key]).forEach(k => {
                            entity[key][k] = null;
                        });
                    }
                }
                this.entities.push(entity);
            },
            // æ¸…ç©ºæ‰€æœ‰å¯¹è±¡æ± 
            clear() {
                this.entities = [];
            }
        };

        // æ€§èƒ½ç›‘æ§ç³»ç»Ÿ
        const performanceMonitor = {
            frameCount: 0,
            lastTimestamp: 0,
            fps: 0,
            renderTime: 0,
            updateTime: 0,
            enabled: false,  // é»˜è®¤å…³é—­æ€§èƒ½ç›‘æ§
            
            // å¼€å§‹ä¸€ä¸ªæ€§èƒ½è®¡æ—¶
            startTimer() {
                return performance.now();
            },
            
            // ç»“æŸä¸€ä¸ªæ€§èƒ½è®¡æ—¶
            endTimer(startTime) {
                return performance.now() - startTime;
            },
            
            // æ›´æ–°FPSè®¡æ•°
            updateFPS(timestamp) {
                this.frameCount++;
                // æ¯ç§’æ›´æ–°ä¸€æ¬¡FPS
                if (timestamp - this.lastTimestamp >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTimestamp = timestamp;
                    
                    // å¯é€‰ï¼šæ˜¾ç¤ºæ€§èƒ½æŒ‡æ ‡
                    if (this.enabled) {
                        console.log(`FPS: ${this.fps}, Render: ${this.renderTime.toFixed(2)}ms, Update: ${this.updateTime.toFixed(2)}ms`);
                    }
                }
            }
        };
        
        // è¾“å…¥å¤„ç†ç³»ç»Ÿï¼ˆé˜²æŠ–å’ŒèŠ‚æµï¼‰
        const inputHandler = {
            keysPressed: {},      // å½“å‰æŒ‰ä¸‹çš„æŒ‰é”®
            lastKeyTime: 0,       // ä¸Šæ¬¡æŒ‰é”®æ—¶é—´
            keyThrottle: 100,     // æŒ‰é”®èŠ‚æµé˜ˆå€¼ (ms)
            clickThrottle: 200,   // ç‚¹å‡»èŠ‚æµé˜ˆå€¼ (ms)
            lastClickTime: 0,     // ä¸Šæ¬¡ç‚¹å‡»æ—¶é—´
            birthdaySequence: "", // å­˜å‚¨è¾“å…¥çš„åºåˆ—
            requiredSequence: "wwssaadd61", // éœ€è¦è¾“å…¥çš„åºåˆ—
            
            // åˆå§‹åŒ–è¾“å…¥å¤„ç†
            init() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    
                    // æ£€æŸ¥ç”Ÿæ—¥ç¥ç¦æ¿€æ´»åºåˆ—
                    if (document.getElementById('help-modal').style.display === 'block') {
                        this.birthdaySequence += key;
                        
                        // æ£€æŸ¥æ˜¯å¦è¾“å…¥äº†å®Œæ•´åºåˆ—
                        if (this.birthdaySequence.includes(this.requiredSequence)) {
                            gameState.birthdayEnabled = true;
                            document.getElementById('birthday-message').style.display = 'block';
                            this.birthdaySequence = ""; // é‡ç½®åºåˆ—
                            addMessage("ç”Ÿæ—¥ç¥ç¦å·²æ¿€æ´»ï¼");
                        }
                        
                        // é˜²æ­¢åºåˆ—è¿‡é•¿
                        if (this.birthdaySequence.length > 20) {
                            this.birthdaySequence = "";
                        }
                    }
                    
                    this.keysPressed[key] = true;
                    const now = performance.now();
                    
                    // å¯¹æŒ‰é”®è¾“å…¥è¿›è¡ŒèŠ‚æµ
                    if (now - this.lastKeyTime > this.keyThrottle) {
                        this.lastKeyTime = now;
                        this.processInput();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    delete this.keysPressed[e.key.toLowerCase()];
                });
            },
            
            // å¤„ç†è¾“å…¥
            processInput() {
                if (gameState.gameOver) return;
                
                // å¤„ç†æ–¹å‘é”®
                if (this.keysPressed['w'] || this.keysPressed['arrowup']) {
                    movePlayer(0, -1);
                } else if (this.keysPressed['s'] || this.keysPressed['arrowdown']) {
                    movePlayer(0, 1);
                } else if (this.keysPressed['a'] || this.keysPressed['arrowleft']) {
                    movePlayer(-1, 0);
                } else if (this.keysPressed['d'] || this.keysPressed['arrowright']) {
                    movePlayer(1, 0);
                } else if (this.keysPressed['e']) {
                    openShopIfAtLocation();
                }
            },
            
            // å¤„ç†å•å…ƒæ ¼ç‚¹å‡»ï¼ŒåŒ…å«èŠ‚æµé€»è¾‘
            handleCellClick(x, y) {
                const now = performance.now();
                if (now - this.lastClickTime < this.clickThrottle) return;
                this.lastClickTime = now;
                
                handleCellClick(x, y);
            }
        };

        // å±‚çº§ä¸»é¢˜
        const dungeonThemes = [
            { 
                name: 'cave', 
                displayName: 'æ´ç©´', 
                description: 'é»‘æš—æ½®æ¹¿çš„æ´ç©´ç³»ç»Ÿï¼Œæ –æ¯ç€å„ç§é€‚åº”äº†é»‘æš—ç¯å¢ƒçš„ç”Ÿç‰©ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "æ´ç©´è™è ",
                    "éª·é«…": "æ´ç©´éª·é«…",
                    "èœ˜è››": "æ´ç©´èœ˜è››",
                    "åƒµå°¸": "çŸ¿å·¥åƒµå°¸",
                    "åœ°ç²¾": "æ´ç©´åœ°ç²¾",
                    "é­”æ³•å¸ˆ": "æ´ç©´æ³•å¸ˆ",
                    "çŸ³åƒé¬¼": "å²©çŸ³çŸ³åƒé¬¼",
                    "æš—å½±åˆºå®¢": "æ´ç©´æ½œè¡Œè€…"
                }
            },
            { 
                name: 'forest', 
                displayName: 'è¿·é›¾æ£®æ—', 
                description: 'è¢«é­”æ³•è¿·é›¾è¦†ç›–çš„å¤è€æ£®æ—ï¼Œä¼ è¯´ä¸­éšè—ç€ç²¾çµå’Œè‡ªç„¶å…ƒç´ çš„åŠ›é‡ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "æ£®æ—è™è ",
                    "éª·é«…": "æ ‘ç²¾éª·é«…",
                    "èœ˜è››": "å·¨å‹æ—è››",
                    "åƒµå°¸": "æ£®æ—è…å°¸",
                    "åœ°ç²¾": "æœ¨ç²¾çµ",
                    "é­”æ³•å¸ˆ": "æ£®æ—å·«å¸ˆ",
                    "çŸ³åƒé¬¼": "æ ‘å¦–çŸ³åƒé¬¼",
                    "æš—å½±åˆºå®¢": "è¿·é›¾åˆºå®¢"
                }
            },
            { 
                name: 'ruins', 
                displayName: 'è¿œå¤é—è¿¹', 
                description: 'ä¸€ä¸ªè¢«é—å¿˜çš„å¤ä»£æ–‡æ˜é—å€ï¼Œå……æ»¡äº†æœªçŸ¥çš„å±é™©å’Œå®è—ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "é—è¿¹è™è ",
                    "éª·é«…": "å¤ä»£å£«å…µ",
                    "èœ˜è››": "å®ˆå«èœ˜è››",
                    "åƒµå°¸": "å¤ä»£ç¥­å¸",
                    "åœ°ç²¾": "é—è¿¹å®ˆå«",
                    "é­”æ³•å¸ˆ": "è¿œå¤æ³•å¸ˆ",
                    "çŸ³åƒé¬¼": "é—è¿¹å®ˆæŠ¤è€…",
                    "æš—å½±åˆºå®¢": "å¤ä»£åˆºå®¢"
                }
            },
            { 
                name: 'crystal', 
                displayName: 'æ°´æ™¶æ´çªŸ', 
                description: 'é—ªè€€ç€é­”æ³•å…‰èŠ’çš„æ°´æ™¶æ´çªŸï¼Œè¿™é‡Œçš„ç”Ÿç‰©å·²ç»è¢«æ°´æ™¶çš„èƒ½é‡æ”¹å˜ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "æ°´æ™¶è™è ",
                    "éª·é«…": "æ°´æ™¶éª·é«…",
                    "èœ˜è››": "æ°´æ™¶èœ˜è››",
                    "åƒµå°¸": "æ°´æ™¶å‚€å„¡",
                    "åœ°ç²¾": "æ°´æ™¶å®ˆå«",
                    "é­”æ³•å¸ˆ": "æ°´æ™¶æ³•å¸ˆ",
                    "çŸ³åƒé¬¼": "æ°´æ™¶çŸ³åƒé¬¼",
                    "æš—å½±åˆºå®¢": "é—ªå…‰åˆºå®¢"
                }
            },
            { 
                name: 'volcanic', 
                displayName: 'ç«å±±æ·±å¤„', 
                description: 'ç‚½çƒ­çš„åœ°ä¸‹ç«å±±åŒºåŸŸï¼Œåªæœ‰æœ€åšéŸ§çš„ç”Ÿç‰©æ‰èƒ½åœ¨è¿™é‡Œç”Ÿå­˜ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "ç«ç„°è™è ",
                    "éª·é«…": "ç°çƒ¬éª·é«…",
                    "èœ˜è››": "ç†”å²©èœ˜è››",
                    "åƒµå°¸": "ç«ç„°åƒµå°¸",
                    "åœ°ç²¾": "ç«å±±åœ°ç²¾",
                    "é­”æ³•å¸ˆ": "ç†”å²©å·«å¸ˆ",
                    "çŸ³åƒé¬¼": "å²©æµ†çŸ³åƒé¬¼",
                    "æš—å½±åˆºå®¢": "ç°çƒ¬åˆºå®¢"
                }
            },
            { 
                name: 'desert', 
                displayName: 'æ²™æ¼ ç¥æ®¿', 
                description: 'å¤è€çš„æ²™æ¼ å»ºç­‘ç¾¤ï¼Œå……æ»¡äº†é™·é˜±å’Œè°œé¢˜ï¼Œä¼ è¯´ä¸­è—æœ‰è¿œå¤æ³•è€çš„å®è—ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "æ²™æ¼ è™è ",
                    "éª·é«…": "æ³•è€å«å…µ",
                    "èœ˜è››": "æ²™æ¼ èœ˜è››",
                    "åƒµå°¸": "æœ¨ä¹ƒä¼Š",
                    "åœ°ç²¾": "æ²™æ¼ æ å¤ºè€…",
                    "é­”æ³•å¸ˆ": "æ²™æ¼ ç¥­å¸",
                    "çŸ³åƒé¬¼": "ç¥æ®¿å®ˆå«",
                    "æš—å½±åˆºå®¢": "æ²™å½±åˆºå®¢"
                }
            },
            { 
                name: 'ice', 
                displayName: 'å†°å†»å³¡è°·', 
                description: 'å¯’å†·åˆºéª¨çš„å†°é›ªåœ°å¸¦ï¼Œè¿™é‡Œçš„ç”Ÿç‰©å·²ç»é€‚åº”äº†æå¯’ç¯å¢ƒï¼Œå…·æœ‰ç‹¬ç‰¹çš„å†°ç³»èƒ½åŠ›ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "éœœç¿¼è™è ",
                    "éª·é«…": "å†°éœœéª·é«…",
                    "èœ˜è››": "å†°æ™¶èœ˜è››",
                    "åƒµå°¸": "å†°å†»åƒµå°¸",
                    "åœ°ç²¾": "é›ªåœ°åœ°ç²¾",
                    "é­”æ³•å¸ˆ": "å†°éœœæ³•å¸ˆ",
                    "çŸ³åƒé¬¼": "å†°é›•çŸ³åƒé¬¼",
                    "æš—å½±åˆºå®¢": "é›ªå½±åˆºå®¢"
                }
            },
            { 
                name: 'void', 
                displayName: 'è™šç©ºè£‚éš™', 
                description: 'ç°å®ä¸è™šæ— ä¹‹é—´çš„å¯æ€•é¢†åŸŸï¼Œæ‹¥æœ‰æ‰­æ›²çš„ç©ºé—´å’Œä¸ç¨³å®šçš„ç‰©è´¨ç»“æ„ï¼Œä»¤äººå‘ç–¯çš„æ™¯è±¡ã€‚',
                enemyNameModifiers: {
                    "å°è™è ": "è™šç©ºé£è¡Œè€…",
                    "éª·é«…": "ç©ºé—´æ®‹éª¸",
                    "èœ˜è››": "æ¬¡å…ƒèœ˜è››",
                    "åƒµå°¸": "è™šç©ºè¡Œå°¸",
                    "åœ°ç²¾": "æ‰­æ›²åœ°ç²¾",
                    "é­”æ³•å¸ˆ": "è™šç©ºæœ¯å£«",
                    "çŸ³åƒé¬¼": "è£‚éš™å®ˆå«",
                    "æš—å½±åˆºå®¢": "è™šç©ºçŒæ‰‹"
                }
            }
        ];

        // æ•Œäººç±»å‹
        const enemyTypes = [
            { 
                name: "å°è™è ", 
                health: 3, 
                attack: 2, 
                defense: 0, 
                symbol: "b", 
                exp: 1,
                description: "é»‘æš—ä¸­æ•æ·çš„é£è¡Œç”Ÿç‰©ï¼Œæ”»å‡»åŠ›ä¸é«˜ä½†è¡ŒåŠ¨è¿…é€Ÿã€‚"
            },
            { 
                name: "éª·é«…", 
                health: 5, 
                attack: 3, 
                defense: 1, 
                symbol: "s", 
                exp: 2,
                description: "è¢«é­”æ³•å¤æ´»çš„éª¸éª¨ï¼Œå…·æœ‰ä¸€å®šçš„é˜²å¾¡èƒ½åŠ›ã€‚"
            },
            { 
                name: "èœ˜è››", 
                health: 4, 
                attack: 4, 
                defense: 0, 
                symbol: "p", 
                exp: 2,
                description: "å…«è¶³çš„æ é£Ÿè€…ï¼Œæ”»å‡»åŠ›è¾ƒå¼ºä½†é˜²å¾¡è–„å¼±ã€‚"
            },
            { 
                name: "åƒµå°¸", 
                health: 7, 
                attack: 3, 
                defense: 2, 
                symbol: "z", 
                exp: 3,
                description: "è¡ŒåŠ¨ç¼“æ…¢ä½†ç”Ÿå‘½é¡½å¼ºçš„ä¸æ­»ç”Ÿç‰©ï¼Œå…·æœ‰è¾ƒé«˜çš„é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "åœ°ç²¾", 
                health: 6, 
                attack: 5, 
                defense: 1, 
                symbol: "g", 
                exp: 4,
                description: "ç‹¡çŒ¾çš„ç”Ÿç‰©ï¼Œæ”»å‡»åŠ›å¾ˆé«˜ï¼Œæ˜¯åœ°ç‰¢ä¸­çš„å±é™©æ•Œäººã€‚"
            },
            { 
                name: "é­”æ³•å¸ˆ", 
                health: 5, 
                attack: 6, 
                defense: 0, 
                symbol: "m", 
                exp: 4,
                description: "æŒæ¡ç€å…ƒç´ é­”æ³•çš„æ–½æ³•è€…ï¼Œæ‹¥æœ‰å¼ºå¤§çš„æ”»å‡»åŠ›ä½†é˜²å¾¡è–„å¼±ã€‚"
            },
            { 
                name: "çŸ³åƒé¬¼", 
                health: 8, 
                attack: 4, 
                defense: 3, 
                symbol: "t", 
                exp: 5,
                description: "çŸ³å¤´æ„æˆçš„é£è¡Œæ€ªç‰©ï¼Œæ‹¥æœ‰å¾ˆé«˜çš„é˜²å¾¡åŠ›å’Œä¸­ç­‰çš„æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "æš—å½±åˆºå®¢", 
                health: 6, 
                attack: 7, 
                defense: 1, 
                symbol: "a", 
                exp: 5,
                description: "èƒ½åœ¨é»‘æš—ä¸­éšå½¢çš„åˆºå®¢ï¼Œæ”»å‡»åŠ›æé«˜ä½†ç”Ÿå‘½å€¼å’Œé˜²å¾¡è¾ƒä½ã€‚"
            }
        ];

        // BOSSå®šä¹‰
        const bossTypes = [
            { 
                name: "åœ°ç‰¢å®ˆå«", 
                health: 30, 
                attack: 7, 
                defense: 5,
                symbol: "G", // å®ˆå« Guardian
                exp: 10,
                description: "ä¸€ä¸ªå·¨å¤§çš„çŸ³å¤´å‚€å„¡ï¼Œå®ˆå«ç€åœ°ç‰¢çš„ç§˜å¯†ã€‚æ‹¥æœ‰æé«˜çš„é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "æš—å½±å·«å¸ˆ", 
                health: 24, 
                attack: 10, 
                defense: 3,
                symbol: "M", // Mage
                exp: 12,
                description: "æ§åˆ¶é»‘æš—é­”æ³•çš„å¼ºå¤§å·«å¸ˆï¼Œå¯ä»¥å¬å”¤æš—å½±ä»†ä»ã€‚é˜²å¾¡åŠ›è™½ä½ä½†æ”»å‡»æé«˜ã€‚"
            },
            { 
                name: "åœ°ä¸‹é¾™å…½", 
                health: 40, 
                attack: 8, 
                defense: 6,
                symbol: "D", // Dragon
                exp: 15,
                description: "åœ°ä¸‹æ´ç©´ä¸­çš„ææ€–ç”Ÿç‰©ï¼Œåšç¡¬çš„é³ç‰‡å’Œé”‹åˆ©çš„çˆªç‰™ã€‚æ‹¥æœ‰æé«˜çš„ç”Ÿå‘½å€¼å’Œé˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "è¿œå¤æœºæ¢°å®ˆå«", 
                health: 35, 
                attack: 9, 
                defense: 7,
                symbol: "R", // Robot/Remnant
                exp: 18,
                description: "è¿œå¤æ–‡æ˜ç•™ä¸‹çš„æœºæ¢°å®ˆå«ï¼Œè£…å¤‡ç€å¼ºå¤§çš„æ­¦å™¨å’Œè£…ç”²ã€‚æ‹¥æœ‰æ¸¸æˆä¸­æœ€é«˜çš„é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "å™©æ¢¦ä¹‹ç‹", 
                health: 45, 
                attack: 12, 
                defense: 5,
                symbol: "N", // Nightmare
                exp: 20,
                description: "ä»å™©æ¢¦ä¸­è¯ç”Ÿçš„ææ€–å­˜åœ¨ï¼Œå¯ä»¥æ“æ§ææƒ§æœ¬èº«ã€‚å…¨é¢å¼ºå¤§çš„ç»ˆæBOSSã€‚"
            },
            { 
                name: "è¿œå¤å·¨é¾™", 
                health: 50, 
                attack: 14, 
                defense: 6,
                symbol: "F", // Flame Dragon
                exp: 25,
                description: "ä¼ è¯´ä¸­çš„ç«é¾™ï¼Œå¯ä»¥å–·åæ¯ç­æ€§çš„é¾™æ¯ï¼Œæ‹¥æœ‰å¼ºå¤§çš„æ”»å‡»åŠ›å’Œæé«˜çš„ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "è™šç©ºé¢†ä¸»", 
                health: 42, 
                attack: 16, 
                defense: 4,
                symbol: "V", // Void
                exp: 28,
                description: "æ¥è‡ªè™šç©ºçš„ç¥ç§˜å­˜åœ¨ï¼Œå¯ä»¥æ“æ§æ—¶ç©ºå’Œæš—å½±é­”æ³•ï¼Œæ”»å‡»åŠ›æé«˜ä½†é˜²å¾¡ç•¥ä½ã€‚"
            },
            { 
                name: "ä¸ç­å®ˆæŠ¤è€…", 
                health: 60, 
                attack: 13, 
                defense: 8,
                symbol: "U", // Undying
                exp: 30,
                description: "ç¥è¯ä¸­çš„ä¸æœ½ç”Ÿç‰©ï¼Œæ‹¥æœ‰è‡ªæ„ˆèƒ½åŠ›å’Œæé«˜çš„é˜²å¾¡åŠ›ï¼Œæ˜¯æœ€ä¸ºé¡½å¼ºçš„BOSSä¹‹ä¸€ã€‚"
            }
        ];

        // ç‰©å“ç±»å‹
        const itemTypes = [
            { 
                name: "ç”Ÿå‘½è¯æ°´", 
                type: "health", 
                value: 3, 
                symbol: "!", 
                rarity: 2,
                description: "çº¢è‰²æ¶²ä½“å……æ»¡çš„å°ç“¶ï¼Œé¥®ç”¨åå¯æ¢å¤å°‘é‡ç”Ÿå‘½å€¼ã€‚æ¢å¤3ç‚¹ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "å¤§ç”Ÿå‘½è¯æ°´", 
                type: "health", 
                value: 5, 
                symbol: "!", 
                rarity: 1,
                description: "æ›´å¤§çš„è¯æ°´ç“¶ï¼Œå†…å«æ›´çº¯å‡€çš„æ²»ç–—è¯å‰‚ã€‚æ¢å¤5ç‚¹ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "è¶…çº§ç”Ÿå‘½è¯æ°´", 
                type: "health", 
                value: 8, 
                symbol: "!", 
                rarity: 1,
                description: "æœ€é«˜çº§åˆ«çš„æ²»ç–—è¯å‰‚ï¼Œæœ‰ç€æ˜¾è‘—çš„æ²»ç–—æ•ˆæœã€‚æ¢å¤8ç‚¹ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "æ”»å‡»å·è½´", 
                type: "attack", 
                value: 1, 
                symbol: "?", 
                rarity: 2,
                description: "åˆ»æœ‰å¤è€ç¬¦æ–‡çš„å·è½´ï¼Œé˜…è¯»åå¯çŸ­æš‚æå‡æ”»å‡»åŠ›ã€‚å¢åŠ 1ç‚¹æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "å¼ºåŠ›æ”»å‡»å·è½´", 
                type: "attack", 
                value: 2, 
                symbol: "?", 
                rarity: 1,
                description: "åˆ»æœ‰å¼ºåŠ›æˆ˜æ–—ç¬¦æ–‡çš„å·è½´ï¼Œæ•ˆæœæ›´ä¸ºæ˜¾è‘—ã€‚å¢åŠ 2ç‚¹æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "é˜²å¾¡å·è½´", 
                type: "defense", 
                value: 1, 
                symbol: "?", 
                rarity: 2,
                description: "è®°è½½ç€é˜²å¾¡å’’è¯­çš„å·è½´ï¼Œé˜…è¯»åå¯çŸ­æš‚æå‡é˜²å¾¡åŠ›ã€‚å¢åŠ 1ç‚¹é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "åšå›ºé˜²å¾¡å·è½´", 
                type: "defense", 
                value: 2, 
                symbol: "?", 
                rarity: 1,
                description: "é«˜çº§é˜²æŠ¤å·è½´ï¼Œèƒ½æä¾›æ›´å¼ºåŠ›çš„é˜²å¾¡å¢ç›Šã€‚å¢åŠ 2ç‚¹é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "é‡‘å¸", 
                type: "gold", 
                value: 1, 
                symbol: "$", 
                rarity: 3,
                description: "é—ªé—ªå‘å…‰çš„é‡‘å¸ï¼Œæ˜¯åœ°ç‰¢ä¸­é€šç”¨çš„è´§å¸ï¼Œå¯åœ¨å•†åº—ä¸­è´­ä¹°ç‰©å“ã€‚"
            },
            { 
                name: "é‡‘å¸å †", 
                type: "gold", 
                value: 5, 
                symbol: "$", 
                rarity: 2,
                description: "ä¸€å°å †é‡‘å¸ï¼Œæ˜¯ä¸€ç¬”ä¸é”™çš„è´¢å¯Œã€‚ä»·å€¼5é‡‘å¸ã€‚"
            },
            { 
                name: "å®ç®±", 
                type: "gold", 
                value: 10, 
                symbol: "$", 
                rarity: 1,
                description: "è£…æ»¡é‡‘å¸çš„å°ç®±å­ï¼Œæ˜¯ç›¸å½“å¯è§‚çš„è´¢å¯Œã€‚ä»·å€¼10é‡‘å¸ã€‚"
            },
            { 
                name: "ç”Ÿå‘½ä¸Šé™è¯å‰‚", 
                type: "maxHealth", 
                value: 2, 
                symbol: "+", 
                rarity: 1,
                description: "ä¸€ç§ç¨€æœ‰çš„è¯å‰‚ï¼Œé¥®ç”¨åå¯æ°¸ä¹…å¢åŠ ç”Ÿå‘½ä¸Šé™ã€‚å¢åŠ 2ç‚¹ç”Ÿå‘½ä¸Šé™ã€‚"
            },
            { 
                name: "åŠ›é‡è¯å‰‚", 
                type: "permAttack", 
                value: 1, 
                symbol: "^", 
                rarity: 1,
                description: "ä¸€ç§çè´µçš„çº¢è‰²è¯å‰‚ï¼Œé¥®ç”¨åå¯æ°¸ä¹…å¢åŠ æ”»å‡»åŠ›ã€‚å¢åŠ 1ç‚¹æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "æŠ¤ç”²è¯å‰‚", 
                type: "permDefense", 
                value: 1, 
                symbol: "&", 
                rarity: 1,
                description: "ä¸€ç§çè´µçš„è“è‰²è¯å‰‚ï¼Œé¥®ç”¨åå¯æ°¸ä¹…å¢åŠ é˜²å¾¡åŠ›ã€‚å¢åŠ 1ç‚¹é˜²å¾¡åŠ›ã€‚"
            },
            // æ–°å¢ç‰©å“
            { 
                name: "ç‹‚æš´è¯å‰‚", 
                type: "berserk", 
                value: 3, 
                symbol: "*", 
                rarity: 1,
                description: "é¥®ç”¨åè¿›å…¥ç‹‚æš´çŠ¶æ€ï¼Œæ”»å‡»åŠ›+3ï¼Œä½†é˜²å¾¡åŠ›-1ã€‚"
            },
            { 
                name: "éšèº«è¯æ°´", 
                type: "stealth", 
                value: 6, 
                symbol: "~", 
                rarity: 1,
                description: "ä½¿ç”¨åå¯ä»¥é¿å…è¢«æ•Œäººå‘ç°ï¼ŒæŒç»­6å›åˆã€‚"
            },

            { 
                name: "ç»éªŒå®ç ", 
                type: "experience", 
                value: 1, 
                symbol: "O", 
                rarity: 1,
                description: "è•´å«ç€èƒ½é‡çš„å®ç ï¼Œä½¿ç”¨åå¯ä»¥éšæœºæå‡ä¸€é¡¹å±æ€§ã€‚"
            }
        ];

        // å•†åº—ç‰©å“æ± 
        const shopItemTypes = [
            { 
                name: "ä¼˜è´¨ç”Ÿå‘½è¯æ°´", 
                type: "health", 
                value: 6, 
                symbol: "!", 
                price: 20, // åŸä»·15
                description: "ç‰¹è´¨é…æ–¹é…¿é€ çš„è¯æ°´ï¼Œæ¯”æ™®é€šè¯æ°´æœ‰æ›´å¥½çš„æ²»ç–—æ•ˆæœã€‚æ¢å¤6ç‚¹ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "ç‰¹åˆ¶ç”Ÿå‘½è¯æ°´", 
                type: "health", 
                value: 10, 
                symbol: "!", 
                price: 35, // åŸä»·25
                description: "ç‚¼é‡‘å¤§å¸ˆåˆ¶ä½œçš„é¡¶çº§è¯æ°´ï¼Œå…·æœ‰å¼ºå¤§çš„æ²»ç–—åŠŸæ•ˆã€‚æ¢å¤10ç‚¹ç”Ÿå‘½å€¼ã€‚"
            },
            { 
                name: "æ”»å‡»æˆ’æŒ‡", 
                type: "permAttack", 
                value: 1, 
                symbol: "^", 
                price: 40, // åŸä»·30
                description: "é•¶åµŒç€çº¢å®çŸ³çš„æˆ’æŒ‡ï¼Œä½©æˆ´åå¯ä»¥æ°¸ä¹…å¢å¼ºæ”»å‡»åŠ›ã€‚æ°¸ä¹…å¢åŠ 1ç‚¹æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "é˜²å¾¡æŠ¤ç¬¦", 
                type: "permDefense", 
                value: 1, 
                symbol: "&", 
                price: 40, // åŸä»·30
                description: "å¤è€çš„å®ˆæŠ¤æŠ¤ç¬¦ï¼Œå¯ä»¥å¢å¼ºä½©æˆ´è€…çš„é˜²å¾¡èƒ½åŠ›ã€‚æ°¸ä¹…å¢åŠ 1ç‚¹é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "ç”Ÿå‘½å®çŸ³", 
                type: "maxHealth", 
                value: 3, 
                symbol: "+", 
                price: 45, // åŸä»·35
                description: "è•´å«ç”Ÿå‘½èƒ½é‡çš„å®çŸ³ï¼Œå¯ä»¥å¢å¼ºä½¿ç”¨è€…çš„ç”Ÿå‘½åŠ›ã€‚æ°¸ä¹…å¢åŠ 3ç‚¹ç”Ÿå‘½ä¸Šé™ã€‚"
            },
            { 
                name: "åŠ›é‡æ‰‹ç¯", 
                type: "permAttack", 
                value: 2, 
                symbol: "^", 
                price: 65, // åŸä»·50
                description: "ä¼ è¯´ä¸­çš„æˆ˜å£«ä½©æˆ´çš„æ‰‹ç¯ï¼Œå¯ä»¥å¤§å¹…å¢å¼ºæ”»å‡»åŠ›ã€‚æ°¸ä¹…å¢åŠ 2ç‚¹æ”»å‡»åŠ›ã€‚"
            },
            { 
                name: "å®ˆæŠ¤é“ ç”²", 
                type: "permDefense", 
                value: 2, 
                symbol: "&", 
                price: 65, // åŸä»·50
                description: "ç”±åšå›ºææ–™åˆ¶ä½œçš„æŠ¤ç”²ç¢ç‰‡ï¼Œå¯ä»¥æ˜¾è‘—æé«˜é˜²å¾¡èƒ½åŠ›ã€‚æ°¸ä¹…å¢åŠ 2ç‚¹é˜²å¾¡åŠ›ã€‚"
            },
            { 
                name: "ç”Ÿå‘½ä¹‹å¿ƒ", 
                type: "maxHealth", 
                value: 5, 
                symbol: "+", 
                price: 80, // åŸä»·60
                description: "ä¼ è¯´ä¸­çš„ç¥å™¨ï¼Œæ®è¯´æ˜¯ä»æŸä¸ªå¼ºå¤§ç”Ÿç‰©ä½“å†…å–å‡ºã€‚æ°¸ä¹…å¢åŠ 5ç‚¹ç”Ÿå‘½ä¸Šé™ã€‚"
            }
        ];

        // èŒä¸šå®šä¹‰
        const classes = {
            warrior: {
                name: 'æˆ˜å£«',
                health: 12,
                attack: 2,
                defense: 2,
                abilities: {
                    increaseDamage: 0.05,         // å¢åŠ ä¼¤å®³5%
                    increaseDefense: 0.1          // å¢åŠ é˜²å¾¡10%
                }
            },
            rogue: {
                name: 'ç›—è´¼',
                health: 8,
                attack: 3,
                defense: 1,
                abilities: {
                    increaseLoot: 0.2,           // å¢åŠ é‡‘å¸è·å–20%
                    dodgeChance: 0.2            // 20%å‡ ç‡é—ªé¿æ”»å‡»
                }
            },
            mage: {
                name: 'æ³•å¸ˆ',
                health: 7,
                attack: 4,
                defense: 2,
                abilities: {
                    criticalHitChance: 0.2,     // 20%å‡ ç‡é€ æˆåŒå€ä¼¤å®³
                    shopDiscount: 0.15          // å•†åº—å•†å“é™ä»·15%
                }
            },
            cleric: {
                name: 'ç‰§å¸ˆ',
                health: 10,
                attack: 1,
                defense: 2,
                abilities: {
                    healingBoost: 0.5,          // æ²»ç–—æ•ˆæœå¢åŠ 50%
                    extraShop: 0.3              // 30%å‡ ç‡åœ¨ä¸€å¼ åœ°å›¾å†…å‡ºç°ç¬¬äºŒä¸ªå•†åº—
                }
            },
            // æ–°å¢èŒä¸šï¼šçŒäºº
            hunter: {
                name: 'çŒäºº',
                health: 9,
                attack: 2,
                defense: 1,
                abilities: {
                    rangedAttack: 0.15,         // 15%å‡ ç‡åœ¨è¿œå¤„æ‰“å‡»æ•Œäºº
                    criticalHitChance: 0.15,    // 15%å‡ ç‡é€ æˆåŒå€ä¼¤å®³
                    trapChance: 0.2,            // 20%å‡ ç‡åœ¨è¢«æ”»å‡»æ—¶åå‡»
                    bossVision: {
                        range: 5,
                        duration: 2
                    }
                }
            },
            // æ–°å¢èŒä¸šï¼šæœ¯å£«
            warlock: {
                name: 'æœ¯å£«',
                health: 11,
                attack: 2,
                defense: 0,
                abilities: {
                    lifeSteal: 0.5,             // 50%å‡ ç‡å¸è¡€
                    bossHealthBoost: 0.1        // BOSSå±‚å¢åŠ 10%ç”Ÿå‘½ä¸Šé™
                }
            },
            devpro: {
                name: 'å¼€å‘è€…Pro',
                health: 100,
                attack: 100,
                defense: 100,
                abilities: {
                    infiniteGold: true
                }
            },
            devair: {
                name: 'å¼€å‘è€…Air',
                health: 50,
                attack: 50,
                defense: 50,
                abilities: {
                    teleport: true
                }
            }
        };

        let selectedClass = null;
        let selectedDifficulty = 'normal';

        // ä½è¡€é‡èŒä¸šå‰æœŸç”Ÿå­˜åŠ æˆåˆ¤å®šï¼šåˆå§‹ç”Ÿå‘½â‰¤10ä¸”æ·±åº¦â‰¤4
        function hasEarlyLowHpClassBuff() {
            try {
                const cls = gameState && gameState.player && gameState.player.class ? gameState.player.class : null;
                if (!cls || !classes[cls]) return false;
                const baseHp = classes[cls].health;
                const isLowHpClass = baseHp <= 10;
                const isEarlyDepth = (gameState && typeof gameState.depth === 'number') ? (gameState.depth <= 4) : true;
                return isLowHpClass && isEarlyDepth;
            } catch(e) {
                return false;
            }
        }

        // éš¾åº¦å®šä¹‰
        const difficulties = {
            easy: {
                key: 'easy',
                displayName: 'ç®€å•',
                enemyStatMultiplier: 0.85,
                enemyCountDelta: -2,
                itemCountDelta: 2,
                shopPriceMultiplier: 0.8,
                playerDamageDealtMultiplier: 1.1,
                playerDamageTakenMultiplier: 0.85,
                goldFindMultiplier: 1.2,
                playerStartAdjust: { health: 2, attack: 0, defense: 1 }
            },
            normal: {
                key: 'normal',
                displayName: 'æ™®é€š',
                enemyStatMultiplier: 1.0,
                enemyCountDelta: 0,
                itemCountDelta: 0,
                shopPriceMultiplier: 1.0,
                playerDamageDealtMultiplier: 1.0,
                playerDamageTakenMultiplier: 1.0,
                goldFindMultiplier: 1.0,
                playerStartAdjust: { health: 0, attack: 0, defense: 0 }
            },
            hard: {
                key: 'hard',
                displayName: 'å›°éš¾',
                enemyStatMultiplier: 1.2,
                enemyCountDelta: 1,
                itemCountDelta: -1,
                shopPriceMultiplier: 1.2,
                playerDamageDealtMultiplier: 0.95,
                playerDamageTakenMultiplier: 1.15,
                goldFindMultiplier: 0.9,
                playerStartAdjust: { health: -1, attack: 0, defense: 0 }
            },
            diyu: { 
                key: 'diyu',
                displayName: 'åœ°ç‹±',
                enemyStatMultiplier: 1.4,
                enemyCountDelta: 2,
                itemCountDelta: -2,
                shopPriceMultiplier: 1.4,
                playerDamageDealtMultiplier: 0.9,
                playerDamageTakenMultiplier: 1.3,
                goldFindMultiplier: 0.85,
                playerStartAdjust: { health: -2, attack: 0, defense: -1 }
            },
            ultra: {
                key: 'ultra',
                displayName: 'ULTRA',
                enemyStatMultiplier: 1.8,
                enemyCountDelta: 3,
                itemCountDelta: -3,
                shopPriceMultiplier: 1.6,
                playerDamageDealtMultiplier: 0.85,
                playerDamageTakenMultiplier: 1.5,
                goldFindMultiplier: 0.8,
                playerStartAdjust: { health: -3, attack: -1, defense: -2 }
            }
        };

        // éš¾åº¦é€‰æ‹©
        function selectDifficulty(difficultyKey) {
            selectedDifficulty = difficultyKey;
            // å–æ¶ˆæ‰€æœ‰å·²é€‰ä¸­æ ·å¼
            document.querySelectorAll('.difficulty-card').forEach(card => {
                card.classList.remove('selected');
            });
            // æ·»åŠ é€‰ä¸­æ ·å¼
            const el = document.querySelector(`.difficulty-card[onclick="selectDifficulty('${difficultyKey}')"]`);
            if (el) el.classList.add('selected');
        }

        // é€‰æ‹©èŒä¸š
        function selectClass(className) {
            selectedClass = className;
            
            // ç§»é™¤æ‰€æœ‰å·²é€‰ä¸­æ ·å¼
            document.querySelectorAll('.class-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // æ·»åŠ é€‰ä¸­æ ·å¼
            document.querySelector(`.class-card[onclick="selectClass('${className}')"]`).classList.add('selected');
        }

        // å¼€å‘è€…Proæ¿€æ´»é€»è¾‘
        (function(){
            const devproSequence = 'qwertyasdfghzxcvbn123456';
            let inputBuffer = '';
            // åªåœ¨èŒä¸šé€‰æ‹©ç•Œé¢æ˜¾ç¤ºæ—¶ç›‘å¬
            document.addEventListener('keydown', function(e) {
                const modal = document.getElementById('class-select-modal');
                if (modal && modal.style.display !== 'none') {
                    let key = e.key;
                    // ç»Ÿä¸€å°å†™
                    if (/^[A-Z]$/.test(key)) key = key.toLowerCase();
                    inputBuffer += key;
                    if (inputBuffer.length > devproSequence.length) {
                        inputBuffer = inputBuffer.slice(-devproSequence.length);
                    }
                    if (inputBuffer === devproSequence) {
                        // æ˜¾ç¤ºå¼€å‘è€…Proå¡ç‰‡
                        document.querySelector('.devpro-card').style.display = 'flex';
                    }
                }
            });
        })();
        // å¼€å‘è€…Airæ¿€æ´»é€»è¾‘
        (function(){
            const devairSequence = 'qwerasdfzxcv7894';
            let inputBuffer = '';
            document.addEventListener('keydown', function(e) {
                const modal = document.getElementById('class-select-modal');
                if (modal && modal.style.display !== 'none') {
                    let key = e.key;
                    if (/^[A-Z]$/.test(key)) key = key.toLowerCase();
                    inputBuffer += key;
                    if (inputBuffer.length > devairSequence.length) {
                        inputBuffer = inputBuffer.slice(-devairSequence.length);
                    }
                    if (inputBuffer === devairSequence) {
                        document.querySelector('.devair-card').style.display = 'flex';
                    }
                }
            });
        })();

        // ä½¿ç”¨æ‰€é€‰èŒä¸šå¼€å§‹æ¸¸æˆ
        function startGameWithClass() {
            if (!selectedClass) {
                alert('è¯·é€‰æ‹©ä¸€ä¸ªèŒä¸šï¼ˆä¹Ÿå¯æŒ‰ç©ºæ ¼é”®å¿«é€Ÿå¼€å§‹ï¼‰');
                return;
            }
            
            const chosenClass = classes[selectedClass];
            
            // è®¾ç½®èŒä¸šå±æ€§
            gameState.player.health = chosenClass.health;
            gameState.player.maxHealth = chosenClass.health;
            gameState.player.attack = chosenClass.attack;
            gameState.player.defense = chosenClass.defense;
            gameState.player.class = selectedClass;
            gameState.player.classAbilities = chosenClass.abilities;
            // å¦‚æœæ˜¯å¼€å‘è€…Proï¼Œåˆå§‹é‡‘å¸999999
            if(selectedClass === 'devpro') {
                gameState.player.gold = 999999;
            }
            
            // å…³é—­èŒä¸šé€‰æ‹©ç•Œé¢
            document.getElementById('class-select-modal').style.display = 'none';
            
            // åˆå§‹åŒ–æ¸¸æˆ
            initGame();
        }

        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            if (!gameState.player.class) {
                document.getElementById('class-select-modal').style.display = 'flex';
                return;
            }
            // ç¡®ä¿å•†åº—ç•Œé¢éšè—
            document.getElementById('shop-modal').style.display = 'none';
            
            // é‡ç½®ç©å®¶çŠ¶æ€ï¼ˆä¿ç•™å·²é€‰èŒä¸šå±æ€§ï¼‰
            const previousClass = gameState.player.class;
            const previousAbilities = gameState.player.classAbilities;
            
            gameState.player = { 
                x: 0, y: 0, 
                health: classes[previousClass].health, 
                maxHealth: classes[previousClass].health, 
                attack: classes[previousClass].attack, 
                defense: classes[previousClass].defense, 
                gold: 0,
                class: previousClass,
                classAbilities: previousAbilities
            };
            
            // åº”ç”¨éš¾åº¦å¯¹ç©å®¶åˆå§‹å±æ€§çš„è°ƒæ•´
            const diff = difficulties[selectedDifficulty] || difficulties.normal;
            if (diff && diff.playerStartAdjust) {
                gameState.player.maxHealth += diff.playerStartAdjust.health;
                gameState.player.health += diff.playerStartAdjust.health;
                gameState.player.attack += diff.playerStartAdjust.attack;
                gameState.player.defense += diff.playerStartAdjust.defense;
                if (gameState.player.health > gameState.player.maxHealth) {
                    gameState.player.health = gameState.player.maxHealth;
                }
            }
            
            gameState.difficulty = selectedDifficulty;
            
            gameState.depth = 1;
            gameState.enemiesDefeated = 0;
            gameState.gameOver = false;
            gameState.messages = [];
            gameState.fullRenderNeeded = true; // æ·»åŠ å…¨æ¸²æŸ“æ ‡è®°
            
            // è®¾ç½®åˆå§‹ä¸»é¢˜
            gameState.theme = dungeonThemes[0].name;
            
            generateDungeon();
            updateStats();
            renderMap();
            addMessage(`ä½ ä½œä¸º${classes[gameState.player.class].name}è¿›å…¥äº†${getDungeonThemeDisplay()}çš„ç¬¬ä¸€å±‚...`);
            const diffName = (difficulties[gameState.difficulty] || difficulties.normal).displayName;
            addMessage(`å½“å‰éš¾åº¦: ${diffName}`);
            // å±•ç¤ºå½“å‰éš¾åº¦å¯¹ç©å®¶çš„å…·ä½“å½±å“
            const d = difficulties[gameState.difficulty] || difficulties.normal;
            const diffDetail = [
                `ç©å®¶å¯¹æ•Œäººä¼¤å®³Ã—${d.playerDamageDealtMultiplier || 1}`,
                `ç©å®¶å—åˆ°ä¼¤å®³Ã—${d.playerDamageTakenMultiplier || 1}`,
                `æ•Œäººå±æ€§Ã—${d.enemyStatMultiplier || 1}`,
                `æ•Œäººæ•°é‡è°ƒæ•´: ${d.enemyCountDelta > 0 ? '+'+d.enemyCountDelta : d.enemyCountDelta}`,
                `é“å…·æ•°é‡è°ƒæ•´: ${d.itemCountDelta > 0 ? '+'+d.itemCountDelta : d.itemCountDelta}`,
                `å•†åº—ä»·æ ¼Ã—${d.shopPriceMultiplier || 1}`,
                `é‡‘å¸æ‰è½Ã—${d.goldFindMultiplier || 1}`
            ].join('ï¼Œ');
            addMessage(`éš¾åº¦æ•ˆæœï¼š${diffDetail}`);
            // å¼ºåˆ¶åˆ·æ–°ä¸€æ¬¡çŠ¶æ€æ¡ï¼Œç¡®ä¿åˆå§‹åŠ¨ç”»å¡«æ»¡
            updateStats();
            // å¦‚æœè§¦å‘å‰æœŸä½è¡€é‡èŒä¸šå‡ä¼¤ï¼Œç»™å‡ºæç¤º
            if (hasEarlyLowHpClassBuff()) {
                addMessage('æ—©æœŸç”Ÿå­˜åŠ æˆï¼šä½ çš„èŒä¸šåœ¨å‰å‡ å±‚å—åˆ°çš„ä¼¤å®³é™ä½ã€‚');
            }
            
            document.getElementById('game-over').style.display = 'none';
            const music = document.getElementById('background-music');
            music.play(); // æ’­æ”¾éŸ³ä¹
            gameState.currentSaveSlot = -1;
        }

        // è·å–å½“å‰ä¸»é¢˜æ˜¾ç¤ºå
        function getDungeonThemeDisplay() {
            const theme = dungeonThemes.find(t => t.name === gameState.theme);
            return theme ? theme.displayName : 'æœªçŸ¥åŒºåŸŸ';
        }

        // ç”Ÿæˆåœ°ç‰¢
        function generateDungeon() {
            // æ¸…ç©ºåœ°å›¾
            gameState.map = [];
            gameState.explored = [];
            gameState.enemies = [];
            gameState.items = [];
            gameState.fullRenderNeeded = true; // æ·»åŠ å…¨æ¸²æŸ“æ ‡è®°
            
            // åˆ›å»ºç©ºåœ°å›¾ (25x30)
            for (let y = 0; y < 25; y++) {
                gameState.map[y] = [];
                gameState.explored[y] = [];
                for (let x = 0; x < 30; x++) {
                    gameState.map[y][x] = 1; // 1 = å¢™, 0 = åœ°æ¿
                    gameState.explored[y][x] = false;
                }
            }
            
            // ä½¿ç”¨éšæœºæ¸¸èµ°ç®—æ³•ç”Ÿæˆåœ°ç‰¢
            generateRoomsAndCorridors();
            
            // æ”¾ç½®ç©å®¶
            placePlayer();
            
            // æ”¾ç½®å‡ºå£
            placeExit();
            
            // æ”¾ç½®æ•Œäºº
            placeEnemies();
            
            // æ”¾ç½®ç‰©å“
            placeItems();
            
            // æ”¾ç½®å•†åº—
            placeShop();
            
            // æ ¹æ®æ·±åº¦é€‰æ‹©ä¸»é¢˜
            const themeIndex = (gameState.depth - 1) % dungeonThemes.length;
            gameState.theme = dungeonThemes[themeIndex].name;
            
            // æ˜¾ç¤ºå½“å‰ä¸»é¢˜
            document.getElementById('current-theme').textContent = dungeonThemes[themeIndex].displayName;
            
            // è®¾ç½®æ¸¸æˆæ¿çš„ä¸»é¢˜ç±»
            const gameBoard = document.getElementById('game-board');
            dungeonThemes.forEach(theme => {
                gameBoard.classList.remove(`theme-${theme.name}`);
            });
            gameBoard.classList.add(`theme-${gameState.theme}`);
        }

        // ä½¿ç”¨æˆ¿é—´å’Œèµ°å»Šç”Ÿæˆåœ°ç‰¢
        function generateRoomsAndCorridors() {
            // æ”¾ç½®å‡ ä¸ªéšæœºæˆ¿é—´
            const roomCount = 5 + Math.floor(Math.random() * 3);
            let rooms = [];
            
            for (let i = 0; i < roomCount; i++) {
                // å¢åŠ æˆ¿é—´å°ºå¯¸
                const width = 4 + Math.floor(Math.random() * 5);  // 4-8çš„å®½åº¦ï¼ŒåŸæ¥æ˜¯3-6
                const height = 4 + Math.floor(Math.random() * 5); // 4-8çš„é«˜åº¦ï¼ŒåŸæ¥æ˜¯3-6
                const x = 1 + Math.floor(Math.random() * (28 - width));
                const y = 1 + Math.floor(Math.random() * (23 - height));
                
                // æŒ–å‡ºæˆ¿é—´
                for (let ry = y; ry < y + height; ry++) {
                    for (let rx = x; rx < x + width; rx++) {
                        gameState.map[ry][rx] = 0;
                    }
                }
                
                // å¦‚æœä¸æ˜¯ç¬¬ä¸€ä¸ªæˆ¿é—´ï¼Œè¿æ¥åˆ°ä¸Šä¸€ä¸ªæˆ¿é—´
                if (i > 0) {
                    const prevRoom = rooms[i-1];
                    const prevCenterX = Math.floor(prevRoom.x + prevRoom.width / 2);
                    const prevCenterY = Math.floor(prevRoom.y + prevRoom.height / 2);
                    const newCenterX = Math.floor(x + width / 2);
                    const newCenterY = Math.floor(y + height / 2);
                    
                    // æŒ–å‡ºèµ°å»Š
                    digCorridor(prevCenterX, prevCenterY, newCenterX, newCenterY);
                }
                
                // ä¿å­˜æˆ¿é—´ä¿¡æ¯
                rooms.push({ x, y, width, height });
            }

            // ç”Ÿæˆç‰¹æ®Šæˆ¿é—´
            gameState.specialRooms = [];
            const specialRoomCount = 2 + Math.floor(Math.random() * 3); // 2-4ä¸ªç‰¹æ®Šæˆ¿é—´ï¼ŒåŸæ¥æ˜¯1-2ä¸ª
            const availableRooms = [...rooms];
            const availableSpecialRooms = [...specialRooms];

            for (let i = 0; i < specialRoomCount && availableRooms.length > 0 && availableSpecialRooms.length > 0; i++) {
                // éšæœºé€‰æ‹©ä¸€ä¸ªæˆ¿é—´å’Œç‰¹æ®Šæˆ¿é—´ç±»å‹
                const roomIndex = Math.floor(Math.random() * availableRooms.length);
                const room = availableRooms.splice(roomIndex, 1)[0];
                
                // å¦‚æœç‰¹æ®Šæˆ¿é—´ç±»å‹ç”¨å®Œäº†ï¼Œé‡æ–°å¡«å……
                if (availableSpecialRooms.length === 0) {
                    availableSpecialRooms.push(...specialRooms);
                }
                
                const specialRoomIndex = Math.floor(Math.random() * availableSpecialRooms.length);
                const specialRoomType = availableSpecialRooms.splice(specialRoomIndex, 1)[0];

                // ç”Ÿæˆç‰¹æ®Šæˆ¿é—´
                const specialRoom = generateSpecialRoom(room.x, room.y, room.width, room.height, specialRoomType);
                gameState.specialRooms.push(specialRoom);
            }
        }

        // æŒ–å‡ºèµ°å»Š
        function digCorridor(x1, y1, x2, y2) {
            let x = x1;
            let y = y1;
            
            // éšæœºå†³å®šå…ˆæ°´å¹³è¿˜æ˜¯å‚ç›´
            if (Math.random() < 0.5) {
                // å…ˆæ°´å¹³ï¼Œå†å‚ç›´
                while (x !== x2) {
                    gameState.map[y][x] = 0;
                    // å¢åŠ èµ°å»Šå®½åº¦ - å‘ä¸Šä¸‹å„æ‰©å±•ä¸€æ ¼
                    if (y > 0) gameState.map[y-1][x] = 0;
                    if (y < 24) gameState.map[y+1][x] = 0;
                    x += x2 > x ? 1 : -1;
                }
                while (y !== y2) {
                    gameState.map[y][x] = 0;
                    // å¢åŠ èµ°å»Šå®½åº¦ - å‘å·¦å³å„æ‰©å±•ä¸€æ ¼
                    if (x > 0) gameState.map[y][x-1] = 0;
                    if (x < 29) gameState.map[y][x+1] = 0;
                    y += y2 > y ? 1 : -1;
                }
            } else {
                // å…ˆå‚ç›´ï¼Œå†æ°´å¹³
                while (y !== y2) {
                    gameState.map[y][x] = 0;
                    // å¢åŠ èµ°å»Šå®½åº¦ - å‘å·¦å³å„æ‰©å±•ä¸€æ ¼
                    if (x > 0) gameState.map[y][x-1] = 0;
                    if (x < 29) gameState.map[y][x+1] = 0;
                    y += y2 > y ? 1 : -1;
                }
                while (x !== x2) {
                    gameState.map[y][x] = 0;
                    // å¢åŠ èµ°å»Šå®½åº¦ - å‘ä¸Šä¸‹å„æ‰©å±•ä¸€æ ¼
                    if (y > 0) gameState.map[y-1][x] = 0;
                    if (y < 24) gameState.map[y+1][x] = 0;
                    x += x2 > x ? 1 : -1;
                }
            }
        }

        // æ”¾ç½®ç©å®¶
        function placePlayer() {
            // æ‰¾åˆ°æ‰€æœ‰åœ°æ¿ä½ç½®
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0) {
                        floorPositions.push({ x, y });
                    }
                }
            }
            
            // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.player.x = pos.x;
                gameState.player.y = pos.y;
                
                // æ ‡è®°å‘¨å›´ä¸ºå·²æ¢ç´¢
                updateExplored(pos.x, pos.y);
            }
        }

        // æ”¾ç½®å‡ºå£
        function placeExit() {
            // æ‰¾åˆ°æ‰€æœ‰å¯ç”¨çš„åœ°æ¿ä½ç½®ï¼ˆå¿…é¡»æ˜¯åœ°æ¿ä¸”è¿œç¦»ç©å®¶ï¼‰
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0) {
                        // è®¡ç®—ä¸ç©å®¶çš„è·ç¦»
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        // ç¡®ä¿å‡ºå£ä½ç½®è‡³å°‘ç¦»ç©å®¶10æ ¼è¿œ
                        if (dist >= 10) {
                            // æ£€æŸ¥å‘¨å›´æ˜¯å¦æœ‰å¢™ï¼ˆç¡®ä¿ä¸ä¼šè¢«å®Œå…¨åŒ…å›´ï¼‰
                            let hasPath = false;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25 && gameState.map[ny][nx] === 0) {
                                        hasPath = true;
                                        break;
                                    }
                                }
                                if (hasPath) break;
                            }
                            if (hasPath) {
                                floorPositions.push({ x, y });
                            }
                        }
                    }
                }
            }
            
            // å¦‚æœæ‰¾åˆ°åˆé€‚çš„ä½ç½®ï¼Œéšæœºé€‰æ‹©ä¸€ä¸ª
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.exit = { x: pos.x, y: pos.y };
            } else {
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ°ç†æƒ³ä½ç½®ï¼Œé€‰æ‹©ä»»ä½•è¿œç¦»ç©å®¶çš„åœ°æ¿ä½ç½®
                const fallbackPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0) {
                            const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                            if (dist >= 5) {
                                fallbackPositions.push({ x, y });
                            }
                        }
                    }
                }
                if (fallbackPositions.length > 0) {
                    const pos = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
                    gameState.exit = { x: pos.x, y: pos.y };
                } else {
                                    // æœ€åçš„åå¤‡æ–¹æ¡ˆï¼šé€‰æ‹©ä»»ä½•åœ°æ¿ä½ç½®
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y)) {
                            fallbackPositions.push({ x, y });
                        }
                    }
                }
                    if (fallbackPositions.length > 0) {
                        const pos = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
                        gameState.exit = { x: pos.x, y: pos.y };
                    }
                }
            }
        }

        // æ”¾ç½®æ•Œäºº
        function placeEnemies() {
            // æ¸…ç©ºæ•Œäººä½ç½®æ˜ å°„
            gameState.entityMap.enemies = {};
            
            // åˆ¤æ–­æ˜¯å¦æ˜¯BOSSå±‚
            const isBossLevel = gameState.depth % 8 === 0;
            
            if (isBossLevel) {
                // æ”¾ç½®BOSS
                placeBoss();
                return;
            }
            
            // æ ¹æ®æ·±åº¦å¢åŠ æ•Œäººæ•°é‡å’Œå®åŠ› - é™ä½å‰4å±‚éš¾åº¦
            let baseEnemyCount = 7;
            if (gameState.depth <= 4) baseEnemyCount = 4; // å‰4å±‚æ›´å°‘æ•Œäºº
            const depthFactor = Math.floor(gameState.depth / 2);
            let enemyCount = baseEnemyCount + depthFactor + Math.floor(Math.random() * (gameState.depth <= 4 ? 2 : 4)); // å‰4å±‚æ³¢åŠ¨æ›´å°
            // éš¾åº¦å½±å“æ•Œäººæ•°é‡
            const diffForCount = difficulties[gameState.difficulty] || difficulties.normal;
            enemyCount = Math.max(1, enemyCount + (diffForCount.enemyCountDelta || 0));
            
            // è·å–å½“å‰ä¸»é¢˜
            const currentThemeObj = dungeonThemes.find(t => t.name === gameState.theme);
            
            for (let i = 0; i < enemyCount; i++) {
                // æ‰¾åˆ°æ‰€æœ‰è¿œç¦»ç©å®¶çš„åœ°æ¿ä½ç½®
                const floorPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y) &&
                            !(x === gameState.exit.x && y === gameState.exit.y)) {
                                // è®¡ç®—ä¸ç©å®¶çš„è·ç¦»
                                const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                                // å‰4å±‚æ•Œäººç¦»ç©å®¶æ›´è¿œ
                                if (dist > (gameState.depth <= 4 ? 3 : 5)) {
                                    floorPositions.push({ x, y });
                                }
                            }
                        }
                    }
                    
                    // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®
                    if (floorPositions.length > 0) {
                        const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                        
                        // é€‰æ‹©æ•Œäººç±»å‹ (éšç€æ·±åº¦å¢åŠ æ›´å¼ºçš„æ•Œäºº)
                        let enemyPool = [...enemyTypes];
                        if (gameState.depth <= 3) {
                            enemyPool = enemyPool.filter(e => !['m','t','a'].includes(e.symbol));
                        }
                        if (gameState.depth > 3) {
                            enemyPool = enemyPool.filter(e => e.exp > 1);
                        }
                        if (gameState.depth > 6) {
                            enemyPool = enemyPool.filter(e => e.exp > 2);
                        }
                        
                        const enemyType = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                        
                        // éš¾åº¦å½±å“æ•ŒäººåŸºç¡€å±æ€§
                        const diffStat = difficulties[gameState.difficulty] || difficulties.normal;
                        const statMul = diffStat.enemyStatMultiplier || 1;
                        
                        // æ ¹æ®ä¸»é¢˜è°ƒæ•´æ•Œäººåç§°
                        let enemyName = enemyType.name;
                        if (currentThemeObj && currentThemeObj.enemyNameModifiers && currentThemeObj.enemyNameModifiers[enemyName]) {
                            enemyName = currentThemeObj.enemyNameModifiers[enemyName];
                        }
                        
                        // æ ¹æ®æ·±åº¦å¢åŠ æ•Œäººå®åŠ›ï¼Œå‰4å±‚æ— åŠ æˆ
                        let healthBonus = Math.floor(gameState.depth / 2);
                        let attackBonus = Math.floor(gameState.depth / 4);
                        let defenseBonus = Math.floor(gameState.depth / 6);
                        if (gameState.depth <= 4) {
                            healthBonus = 0;
                            attackBonus = 0;
                            defenseBonus = 0;
                        }
                        
                        const enemy = {
                            ...enemyType,
                            name: enemyName,  // ä½¿ç”¨ä¸»é¢˜è°ƒæ•´åçš„åç§°
                            x: pos.x,
                            y: pos.y,
                            maxHealth: Math.round((enemyType.health + healthBonus) * statMul),
                            health: Math.round((enemyType.health + healthBonus) * statMul),
                            attack: Math.max(1, Math.round((enemyType.attack + attackBonus) * statMul)),
                            defense: Math.max(0, Math.round((enemyType.defense + defenseBonus) * statMul))
                        };
                        
                        // æ·»åŠ åˆ°æ•°ç»„å¹¶æ›´æ–°ä½ç½®æ˜ å°„
                        const index = gameState.enemies.length;
                        gameState.enemies.push(enemy);
                        gameState.entityMap.enemies[`${pos.x},${pos.y}`] = index;
                    }
                }
            }

        // æ”¾ç½®BOSS
        function placeBoss() {
            // æ‰¾æ‰€æœ‰è¿œç¦»ç©å®¶çš„åœ°æ¿ä½ç½®
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0 && 
                        !(x === gameState.player.x && y === gameState.player.y) &&
                        !(x === gameState.exit.x && y === gameState.exit.y)) {
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        if (dist > 8) {
                            floorPositions.push({ x, y });
                        }
                    }
                }
            }
            // åˆ¤æ–­æ˜¯å¦16çš„å€æ•°
            const bossCount = (gameState.depth % 16 === 0) ? 2 : 1;
            const usedPositions = new Set();
            for (let b = 0; b < bossCount; b++) {
                if (floorPositions.length === 0) break;
                // éšæœºé€‰ä¸€ä¸ªä¸é‡å¤çš„ä½ç½®
                let posIdx = Math.floor(Math.random() * floorPositions.length);
                let pos = floorPositions[posIdx];
                // ç§»é™¤è¯¥ä½ç½®ï¼Œé˜²æ­¢é‡å 
                floorPositions.splice(posIdx, 1);
                usedPositions.add(`${pos.x},${pos.y}`);
                // é€‰æ‹©BOSSï¼ˆä¸åŸé€»è¾‘ä¸€è‡´ï¼‰
                let bossIndex = Math.min(Math.floor(gameState.depth / 8) - 1, bossTypes.length - 1);
                if (gameState.depth > 8) {
                    if (Math.random() < 0.5) {
                        const minIndex = bossIndex;
                        const maxIndex = Math.min(bossIndex + 2, bossTypes.length - 1);
                        bossIndex = minIndex + Math.floor(Math.random() * (maxIndex - minIndex + 1));
                    }
                }
                const bossType = bossTypes[bossIndex];
                const depthBonus = Math.floor(gameState.depth / 3);
                // åœ¨placeBosså‡½æ•°ç”ŸæˆBOSSæ—¶åº”ç”¨å±æ€§åŠ æˆ
                const bossMultiplier = Math.pow(1.3, gameState.bossDefeatCount || 0);
                // éš¾åº¦å½±å“BOSSå±æ€§
                const diffStat = difficulties[gameState.difficulty] || difficulties.normal;
                const bossStatMul = diffStat.enemyStatMultiplier || 1;
                const boss = {
                    ...bossType,
                    x: pos.x,
                    y: pos.y,
                    maxHealth: Math.round((bossType.health + depthBonus * 8) * bossStatMul),
                    health: Math.round((bossType.health + depthBonus * 8) * bossStatMul),
                    attack: Math.max(1, Math.round((bossType.attack + depthBonus * 2) * bossStatMul)),
                    defense: Math.max(0, Math.round((bossType.defense + depthBonus * 1.5) * bossStatMul)),
                    isBoss: true
                };
                // æ·»åŠ åˆ°æ•°ç»„å¹¶æ›´æ–°ä½ç½®æ˜ å°„
                const index = gameState.enemies.length;
                gameState.enemies.push(boss);
                gameState.entityMap.enemies[`${pos.x},${pos.y}`] = index;
                // é¢„è­¦æ¶ˆæ¯
                addMessage(`æ³¨æ„! ${boss.name}å‡ºç°äº†!`);
                addMessage(boss.description);
                addMessage(`è¿™ä¸ªå¼ºå¤§çš„æ•Œäººæ‹¥æœ‰ ${boss.defense} ç‚¹é˜²å¾¡åŠ›ï¼Œè¯·åšå¥½å……åˆ†å‡†å¤‡ï¼`);
            }
        }

        // æ”¾ç½®ç‰©å“
        function placeItems() {
            // æ¸…ç©ºç‰©å“ä½ç½®æ˜ å°„
            gameState.entityMap.items = {};
            
            let itemCount = 5 + Math.floor(Math.random() * 4);
            if (gameState.depth <= 4) itemCount += 2; // å‰4å±‚å¤š2ä¸ªç‰©å“
            // éš¾åº¦å½±å“ç‰©å“æ•°é‡
            const diffItems = difficulties[gameState.difficulty] || difficulties.normal;
            itemCount = Math.max(1, itemCount + (diffItems.itemCountDelta || 0));
            
            for (let i = 0; i < itemCount; i++) {
                // æ‰¾åˆ°æ‰€æœ‰åœ°æ¿ä½ç½®
                const floorPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y) &&
                            !(x === gameState.exit.x && y === gameState.exit.y) &&
                            !gameState.entityMap.enemies[`${x},${y}`]) {
                                floorPositions.push({ x, y });
                            }
                        }
                    }
                    
                    // å¢åŠ å‰4å±‚å›è¡€é“å…·æ¦‚ç‡
                    let itemPool = [];
                    itemTypes.forEach(item => {
                        let rarity = item.rarity || 1;
                        if (gameState.depth <= 4 && item.type === "health") rarity += 2;
                        for (let j = 0; j < rarity; j++) {
                            itemPool.push(item);
                        }
                    });
                    
                    // éšæœºé€‰æ‹©ä¸€ä¸ªä½ç½®
                    if (floorPositions.length > 0) {
                        const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                        
                        const itemType = itemPool[Math.floor(Math.random() * itemPool.length)];
                        const item = {
                            ...itemType,
                            x: pos.x,
                            y: pos.y
                        };
                        
                        // æ·»åŠ åˆ°æ•°ç»„å¹¶æ›´æ–°ä½ç½®æ˜ å°„
                        const index = gameState.items.length;
                        gameState.items.push(item);
                        gameState.entityMap.items[`${pos.x},${pos.y}`] = index;
                    }
                }
            }

        // ç”Ÿæˆå•†åº—ç‰©å“
        function generateShopItems() {
            let itemCount = 3 + Math.floor(Math.random() * 2); // 3-4ä¸ªå•†å“
            // éš¾åº¦å½±å“å•†åº—é™ˆåˆ—æ•°é‡ï¼ˆç®€å•å¤šï¼Œå›°éš¾å°‘ï¼‰
            const diff = difficulties[gameState.difficulty] || difficulties.normal;
            itemCount = Math.max(1, itemCount + (diff.itemCountDelta > 0 ? Math.min(1, diff.itemCountDelta) : Math.max(-1, diff.itemCountDelta)));
            const availableItems = [...shopItemTypes];
            const selectedItems = [];

            for (let i = 0; i < itemCount && availableItems.length > 0; i++) {
                const index = Math.floor(Math.random() * availableItems.length);
                const item = availableItems.splice(index, 1)[0];
                
                // æ ¹æ®åœ°ç‰¢æ·±åº¦è°ƒæ•´ä»·æ ¼
                let adjustedPrice = Math.floor(item.price * (1 + (gameState.depth - 1) * 0.2));
                
                // éš¾åº¦å½±å“ä»·æ ¼
                const diff = difficulties[gameState.difficulty] || difficulties.normal;
                adjustedPrice = Math.floor(adjustedPrice * (diff.shopPriceMultiplier || 1));
                
                // æ³•å¸ˆå•†åº—æŠ˜æ‰£
                if (gameState.player.classAbilities.shopDiscount) {
                    adjustedPrice = Math.floor(adjustedPrice * (1 - gameState.player.classAbilities.shopDiscount));
                }
                
                selectedItems.push({
                    ...item,
                    price: adjustedPrice
                });
            }

            return selectedItems;
        }

        // æ”¾ç½®å•†åº—
        function placeShop() {
            // æ‰¾åˆ°æ‰€æœ‰åˆé€‚çš„åœ°æ¿ä½ç½®
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0 && 
                        !(x === gameState.player.x && y === gameState.player.y) &&
                        !(x === gameState.exit.x && y === gameState.exit.y)) {
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        if (dist >= 3) {
                            floorPositions.push({ x, y });
                        }
                    }
                }
            }
            
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.shop = {
                    x: pos.x,
                    y: pos.y,
                    items: generateShopItems()
                };
            }
        }

        // æ˜¾ç¤ºå•†åº—ç•Œé¢
        function openShop() {
            const shopModal = document.getElementById('shop-modal');
            const shopItemsContainer = document.getElementById('shop-items');
            shopItemsContainer.innerHTML = '';

            gameState.shop.items.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.className = 'shop-item';
                itemElement.innerHTML = `
                    <span>${item.name}</span>
                    <span class="shop-item-price">${item.price} é‡‘å¸</span>
                    <button onclick="buyItem(${index})" ${gameState.player.gold < item.price ? 'disabled' : ''}>è´­ä¹°</button>
                    <div class="shop-item-tooltip">
                        <div class="shop-item-tooltip-title">${item.name}</div>
                        <div>${item.description}</div>
                    </div>
                `;
                shopItemsContainer.appendChild(itemElement);
            });

            shopModal.style.display = 'block';
        }

        // å…³é—­å•†åº—ç•Œé¢
        function closeShop() {
            document.getElementById('shop-modal').style.display = 'none';
        }

        // è´­ä¹°ç‰©å“
        function buyItem(index) {
            const item = gameState.shop.items[index];
            if (gameState.player.gold >= item.price) {
                gameState.player.gold -= item.price;
                
                // åº”ç”¨ç‰©å“æ•ˆæœ
                switch (item.type) {
                    case "health":
                        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + item.value);
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, æ¢å¤äº† ${item.value} ç‚¹ç”Ÿå‘½å€¼!`);
                        break;
                    case "maxHealth":
                        gameState.player.maxHealth += item.value;
                        gameState.player.health += item.value;
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, ç”Ÿå‘½ä¸Šé™æ°¸ä¹…å¢åŠ  ${item.value}!`);
                        break;
                    case "attack":
                        gameState.player.attack += item.value;
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, æ”»å‡»åŠ›æš‚æ—¶å¢åŠ  ${item.value}!`);
                        break;
                    case "permAttack":
                        gameState.player.attack += item.value;
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, æ”»å‡»åŠ›æ°¸ä¹…å¢åŠ  ${item.value}!`);
                        break;
                    case "defense":
                        gameState.player.defense += item.value;
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, é˜²å¾¡åŠ›æš‚æ—¶å¢åŠ  ${item.value}!`);
                        break;
                    case "permDefense":
                        gameState.player.defense += item.value;
                        addMessage(`ä½ è´­ä¹°å¹¶ä½¿ç”¨äº†${item.name}, é˜²å¾¡åŠ›æ°¸ä¹…å¢åŠ  ${item.value}!`);
                        break;
                    case "gold":
                        gameState.player.gold += item.value;
                        addMessage(`ä½ æ‹¾å–äº†${item.value}é‡‘å¸!`);
                        break;
                }
                
                // ä»å•†åº—ç§»é™¤ç‰©å“
                gameState.shop.items.splice(index, 1);
                
                // æ›´æ–°çŠ¶æ€å’Œå•†åº—æ˜¾ç¤º
                updateStats();
                openShop();
                
                // å¦‚æœå•†åº—æ²¡æœ‰ç‰©å“äº†ï¼Œå…³é—­å•†åº—
                if (gameState.shop.items.length === 0) {
                    closeShop();
                    addMessage("å•†åº—çš„å•†å“å·²ç»å”®ç½„äº†!");
                }
            }
        }

        // ä¿®æ”¹ç§»åŠ¨ç©å®¶å‡½æ•°
        function movePlayer(dx, dy) {
            if (gameState.gameOver) return;
            
            const nx = gameState.player.x + dx;
            const ny = gameState.player.y + dy;
            
            if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25) return;
            if (gameState.map[ny][nx] === 1) {
                addMessage("ä½ æ’åˆ°äº†å¢™ä¸Š!");
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæˆ¿é—´
            const specialRoom = gameState.specialRooms.find(room => room.x === nx && room.y === ny);
            if (specialRoom && !specialRoom.used) {
                specialRoom.effect(gameState.player);
                specialRoom.used = true; // æ ‡è®°ä¸ºå·²ä½¿ç”¨
                updateStats();
                // ä¸returnï¼Œç»§ç»­åç»­ç§»åŠ¨é€»è¾‘
            }
            
            // ä½¿ç”¨ä½ç½®æ˜ å°„æ£€æŸ¥æ•Œäºº
            const posKey = `${nx},${ny}`;
            const enemyIndex = gameState.entityMap.enemies[posKey] !== undefined ? 
                                gameState.entityMap.enemies[posKey] : -1;
                                
            if (enemyIndex !== -1) {
                attackEnemy(enemyIndex);
                return;
            }
            
            // ä½¿ç”¨ä½ç½®æ˜ å°„æ£€æŸ¥ç‰©å“
            const itemIndex = gameState.entityMap.items[posKey] !== undefined ? 
                               gameState.entityMap.items[posKey] : -1;
                                
            if (itemIndex !== -1) {
                pickUpItem(itemIndex);
                gameState.player.x = nx;
                gameState.player.y = ny;
                updateExplored(nx, ny);
                renderMap();
                return;
            }
            
            // æ£€æŸ¥å‡ºå£
            if (nx === gameState.exit.x && ny === gameState.exit.y) {
                descendDungeon();
                return;
            }
            
            // ç§»åŠ¨ç©å®¶
            gameState.player.x = nx;
            gameState.player.y = ny;
            
            // æ›´æ–°æ¢ç´¢åŒºåŸŸ
            updateExplored(nx, ny);
            
            // æ¸²æŸ“åœ°å›¾
            renderMap();
            
            // æ•Œäººå›åˆ
            enemyTurn();
        }

        // æ›´æ–°æ¢ç´¢åŒºåŸŸ
        function updateExplored(x, y) {
            // æ ‡è®°å½“å‰ä½ç½®å’Œå‘¨å›´8æ ¼ä¸ºå·²æ¢ç´¢
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25) {
                        gameState.explored[ny][nx] = true;
                    }
                }
            }
        }

        // æ¸²æŸ“åœ°å›¾ - æ€§èƒ½ä¼˜åŒ–ç‰ˆ
        function renderMap() {
            // å¦‚æœå·²ç»æœ‰æ¸²æŸ“è¯·æ±‚ï¼Œåˆ™è·³è¿‡
            if (gameState.renderPending) return;
            
            // è¯·æ±‚ä¸‹ä¸€å¸§æ¸²æŸ“
            gameState.renderPending = true;
            requestAnimationFrame(() => {
                const startTime = performanceMonitor.startTimer();
                
                const board = document.getElementById('game-board');

                // ä»…åœ¨é¦–æ¬¡æ¸²æŸ“æˆ–é‡æ–°ç”Ÿæˆåœ°å›¾æ—¶å®Œå…¨é‡å»ºDOM
                if (!board.hasChildNodes() || gameState.fullRenderNeeded) {
                    board.innerHTML = '';
                    
                    for (let y = 0; y < 25; y++) {
                        for (let x = 0; x < 30; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.id = `cell-${x}-${y}`;
                            
                            // ä½¿ç”¨äº‹ä»¶å§”æ‰˜è€Œä¸æ˜¯æ¯ä¸ªæ ¼å­å•ç‹¬æ·»åŠ äº‹ä»¶
                            cell.dataset.x = x;
                            cell.dataset.y = y;
                            
                            board.appendChild(cell);
                        }
                    }
                    
                    // å§”æ‰˜äº‹ä»¶å¤„ç†åˆ°çˆ¶å…ƒç´ 
                    if (!board.hasAttribute('data-event-bound')) {
                        board.addEventListener('click', (e) => {
                            const cell = e.target;
                            if (cell.classList.contains('cell')) {
                                const x = parseInt(cell.dataset.x);
                                const y = parseInt(cell.dataset.y);
                                inputHandler.handleCellClick(x, y);
                            }
                        });
                        board.setAttribute('data-event-bound', 'true');
                    }
                    
                    gameState.fullRenderNeeded = false;
                }

                // åˆ›å»ºæœ¬åœ°å¼•ç”¨ä»¥æé«˜æ€§èƒ½
                const { map, explored, player, exit, shop, entityMap, specialRooms } = gameState;

                // è®¡ç®—è§†é‡å¯è§åŒºåŸŸ
                gameState.visibleCells.clear();
                const visionRange = 15; // è§†é‡èŒƒå›´
                
                for (let dy = -visionRange; dy <= visionRange; dy++) {
                    for (let dx = -visionRange; dx <= visionRange; dx++) {
                        const x = player.x + dx;
                        const y = player.y + dy;
                        // æ£€æŸ¥æ˜¯å¦åœ¨åœ°å›¾èŒƒå›´å†…
                        if (x >= 0 && x < 30 && y >= 0 && y < 25) {
                            // è®¡ç®—åˆ°ç©å®¶çš„è·ç¦»
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= visionRange) {
                                gameState.visibleCells.add(`${x},${y}`);
                            }
                        }
                    }
                }

                // åªæ›´æ–°å¯è§åŒºåŸŸçš„å•å…ƒæ ¼ä»¥å‡å°‘DOMæ“ä½œ
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        // æ£€æŸ¥æ˜¯å¦åœ¨å¯è§åŒºåŸŸæˆ–å·²æ¢ç´¢
                        if (!gameState.visibleCells.has(`${x},${y}`) && !explored[y][x]) continue;
                        
                        const cell = document.getElementById(`cell-${x}-${y}`);
                        
                        // é‡ç½®å•å…ƒæ ¼ç±»
                        cell.className = 'cell';
                        
                        if (!explored[y][x]) {
                            cell.style.backgroundColor = '#000';
                            cell.textContent = '';
                            continue;
                        }
                        
                        cell.classList.add('explored');
                        cell.style.backgroundColor = ''; // é‡ç½®èƒŒæ™¯è‰²
                        
                        // æ£€æŸ¥æ˜¯å¦æ˜¯ç‰¹æ®Šæˆ¿é—´
                        const specialRoom = specialRooms.find(room => room.x === x && room.y === y);
                        
                        if (map[y][x] === 1) {
                            cell.classList.add('wall');
                            cell.textContent = '#';
                        } 
                        else if (x === player.x && y === player.y) {
                            cell.classList.add('player');
                            cell.textContent = '@';
                        }
                        else if (x === exit.x && y === exit.y) {
                            cell.classList.add('exit');
                            cell.textContent = '>';
                        }
                        else if (x === shop.x && y === shop.y) {
                            cell.classList.add('item');
                            cell.textContent = 'S';
                        }
                        else if (specialRoom) {
                            cell.classList.add('special-room');
                            cell.textContent = specialRoom.symbol;
                            // æ·»åŠ æç¤ºä¿¡æ¯
                            cell.title = `${specialRoom.name}: ${specialRoom.description}`;
                        }
                        else {
                            const posKey = `${x},${y}`;
                            const enemyIndex = entityMap.enemies[posKey];
                            const itemIndex = entityMap.items[posKey];
                            
                            if (enemyIndex !== undefined) {
                                const enemy = gameState.enemies[enemyIndex];
                                if (enemy.isBoss) {
                                    cell.classList.add('boss');
                                } else {
                                    cell.classList.add('enemy');
                                }
                                cell.textContent = enemy.symbol;
                            } else if (itemIndex !== undefined) {
                                const item = gameState.items[itemIndex];
                                cell.classList.add('item');
                                cell.textContent = item.symbol;
                            } else {
                                cell.textContent = '.';
                            }
                        }
                    }
                }
                
                gameState.renderPending = false;
                
                // æ€§èƒ½ç›‘æ§
                performanceMonitor.renderTime = performanceMonitor.endTimer(startTime);
                performanceMonitor.updateFPS(performance.now());
            });
        }

        // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
        function updateStats() {
            // å¦‚æœæ˜¯å¼€å‘è€…Proï¼Œé‡‘å¸é”å®š999999
            if(gameState.player.class === 'devpro') {
                gameState.player.gold = 999999;
            }
            document.getElementById('depth').textContent = gameState.depth;
            document.getElementById('health').textContent = gameState.player.health;
            document.getElementById('max-health').textContent = gameState.player.maxHealth;
            document.getElementById('attack').textContent = gameState.player.attack;
            document.getElementById('defense').textContent = gameState.player.defense;
            document.getElementById('gold').textContent = gameState.player.gold;
            
            // æ›´æ–°ç”Ÿå‘½æ¡ï¼ˆå–æ•´å¹¶å¤¹ç´§ï¼Œé¿å…å‡ºç° 99.999% å¯¼è‡´çœ‹èµ·æ¥æœªæ»¡çš„é—®é¢˜ï¼‰
            const rawHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const healthPercent = Math.max(0, Math.min(100, Math.round(rawHealthPercent)));
            document.getElementById('health-fill').style.width = `${healthPercent}%`;
            
            // æ ¹æ®ç”Ÿå‘½å€¼ç™¾åˆ†æ¯”æ›´æ”¹é¢œè‰²
            let healthColor = '#5f5'; // ç»¿è‰²
            if (healthPercent < 30) {
                healthColor = '#f55'; // çº¢è‰²
            } else if (healthPercent < 60) {
                healthColor = '#fa5'; // æ©™è‰²
            }
            document.getElementById('health-fill').style.backgroundColor = healthColor;
        }

        // æ·»åŠ æ¶ˆæ¯
        function addMessage(msg) {
            gameState.messages.push(msg);
            if (gameState.messages.length > 5) {
                gameState.messages.shift();
            }
            
            const log = document.getElementById('message-log');
            log.innerHTML = gameState.messages.join('<br>');
            log.scrollTop = log.scrollHeight;
        }

        // ä¿®æ”¹æ”»å‡»æ•Œäººå‡½æ•°ï¼Œæ›´æ–°ä½ç½®æ˜ å°„
        function attackEnemy(enemyIndex) {
            const enemy = gameState.enemies[enemyIndex];
            const isBoss = enemy.isBoss;
            
            // ç©å®¶æ”»å‡»æ•Œäºº
            let playerDamage = Math.max(1, gameState.player.attack - enemy.defense);

            // éš¾åº¦å½±å“ç©å®¶å¯¹æ•Œäººé€ æˆçš„ä¼¤å®³
            const diffDmgDealt = difficulties[gameState.difficulty] || difficulties.normal;
            playerDamage = Math.max(1, Math.round(playerDamage * (diffDmgDealt.playerDamageDealtMultiplier || 1)));
            
            // åº”ç”¨èŒä¸šæŠ€èƒ½
            let criticalHit = false;
            
            // æˆ˜å£«å¢ä¼¤
            if (gameState.player.classAbilities.increaseDamage) {
                playerDamage = Math.floor(playerDamage * (1 + gameState.player.classAbilities.increaseDamage));
            }
            
            // æ³•å¸ˆæš´å‡»
            if (gameState.player.classAbilities.criticalHitChance && Math.random() < gameState.player.classAbilities.criticalHitChance) {
                playerDamage *= 2;
                criticalHit = true;
            }
            
            // æœ¯å£«è¯…å’’æ•ˆæœ
            if (gameState.player.classAbilities.curseEffect) {
                playerDamage = Math.floor(playerDamage * (1 + gameState.player.classAbilities.curseEffect));
            }
            
            enemy.health -= playerDamage;
            
            // æœ¯å£«ç”Ÿå‘½å·å–
            if (gameState.player.classAbilities.lifeSteal && Math.random() < gameState.player.classAbilities.lifeSteal) {
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 1);
                addMessage(`ä½ çš„æ”»å‡»å¸å–äº†æ•Œäººçš„ç”Ÿå‘½åŠ›ï¼Œæ¢å¤äº†1ç‚¹ç”Ÿå‘½å€¼!`);
            }
            
            if (criticalHit) {
                addMessage(`æš´å‡»ï¼ä½ æ”»å‡»äº†${enemy.name}, é€ æˆ ${playerDamage} ç‚¹ä¼¤å®³!`);
            } else {
                addMessage(`ä½ æ”»å‡»äº†${enemy.name}, é€ æˆ ${playerDamage} ç‚¹ä¼¤å®³!`);
            }
            
            // æ˜¾ç¤ºBOSSçš„è¡€é‡ç™¾åˆ†æ¯”
            if (isBoss) {
                const healthPercent = Math.floor((enemy.health / enemy.maxHealth) * 100);
                addMessage(`${enemy.name} å‰©ä½™ç”Ÿå‘½: ${healthPercent}%`);
            }
            
            // æ£€æŸ¥æ•Œäººæ˜¯å¦æ­»äº¡
            if (enemy.health <= 0) {
                // ä»ä½ç½®æ˜ å°„ä¸­ç§»é™¤
                delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
                
                gameState.enemies.splice(enemyIndex, 1);
                gameState.enemiesDefeated++;
                
                // æ›´æ–°æ‰€æœ‰å¤§äºè¢«åˆ é™¤æ•Œäººç´¢å¼•çš„æ˜ å°„
                for (let key in gameState.entityMap.enemies) {
                    if (gameState.entityMap.enemies[key] > enemyIndex) {
                        gameState.entityMap.enemies[key]--;
                    }
                }
                
                if (isBoss) {
                    // BOSSå¥–åŠ±
                    const bossGold = gameState.depth * 20;
                    gameState.player.gold += bossGold;
                    addMessage(`ä½ å‡»è´¥äº†BOSS ${enemy.name}!`);
                    addMessage(`ä½ è·å¾—äº† ${bossGold} é‡‘å¸çš„å¥–åŠ±!`);
                    
                    // é¢å¤–å¥–åŠ±
                    gameState.player.maxHealth += 2;
                    gameState.player.health += 2;
                    gameState.player.attack += 1;
                    addMessage("ä½ æ„Ÿåˆ°è‡ªå·±å˜å¾—æ›´å¼ºå¤§äº†!");
                } else {
                    addMessage(`ä½ å‡»è´¥äº†${enemy.name}!`);
                    
                                    // æ™®é€šæ•Œäººæ‰è½é‡‘å¸
                if (Math.random() < 0.7) {
                    let goldAmount = 1 + Math.floor(Math.random() * 3);

                    // éš¾åº¦å½±å“é‡‘å¸æ‰è½
                    const diffGold = difficulties[gameState.difficulty] || difficulties.normal;
                    goldAmount = Math.max(1, Math.floor(goldAmount * (diffGold.goldFindMultiplier || 1)));
                    
                    // ç›—è´¼è·å¾—æ›´å¤šé‡‘å¸
                    if (gameState.player.classAbilities.increaseLoot) {
                        goldAmount = Math.floor(goldAmount * (1 + gameState.player.classAbilities.increaseLoot));
                    }
                        
                        const newItem = {
                            name: "é‡‘å¸",
                            type: "gold",
                            value: goldAmount,
                            symbol: "$",
                            x: enemy.x,
                            y: enemy.y
                        };
                        
                        // æ·»åŠ åˆ°ç‰©å“æ•°ç»„å¹¶æ›´æ–°ä½ç½®æ˜ å°„
                        const index = gameState.items.length;
                        gameState.items.push(newItem);
                        gameState.entityMap.items[`${enemy.x},${enemy.y}`] = index;
                        
                        addMessage(`${enemy.name}æ‰è½äº†${goldAmount}é‡‘å¸!`);
                    }
                }
            } else {
                // æ•Œäººåå‡» (é™ä½10%æ”»å‡»åŠ›)
                const reducedAttack = Math.floor(enemy.attack * 0.9);
                
                // ç›—è´¼å¯èƒ½é—ªé¿æ”»å‡»
                if (gameState.player.classAbilities.dodgeChance && Math.random() < gameState.player.classAbilities.dodgeChance) {
                    addMessage(`ä½ çµå·§åœ°èº²è¿‡äº†${enemy.name}çš„æ”»å‡»!`);
                } 
                // çŒäººé™·é˜±åå‡»
                else if (gameState.player.classAbilities.trapChance && Math.random() < gameState.player.classAbilities.trapChance) {
                    const trapDamage = Math.floor(gameState.player.attack / 2);
                    enemy.health -= trapDamage;
                    addMessage(`ä½ çš„é™·é˜±è§¦å‘äº†ï¼Œå¯¹${enemy.name}é€ æˆäº†${trapDamage}ç‚¹ä¼¤å®³!`);
                    
                    // å†æ¬¡æ£€æŸ¥æ•Œäººæ˜¯å¦æ­»äº¡
                    if (enemy.health <= 0) {
                        delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
                        gameState.enemies.splice(enemyIndex, 1);
                        gameState.enemiesDefeated++;
                        addMessage(`ä½ å‡»è´¥äº†${enemy.name}!`);
                    }
                } else {
                    let enemyDamage;
                    if (isBoss) {
                        // BOSSæ— è§†æŠ¤ç”²
                        enemyDamage = Math.max(1, reducedAttack);
                    } else {
                        enemyDamage = Math.max(1, reducedAttack - gameState.player.defense);
                    }
                    // éš¾åº¦å½±å“ç©å®¶å—åˆ°çš„ä¼¤å®³
                    const diffDmgTaken = difficulties[gameState.difficulty] || difficulties.normal;
                    enemyDamage = Math.max(1, Math.round(enemyDamage * (diffDmgTaken.playerDamageTakenMultiplier || 1)));
                    // ä½è¡€é‡èŒä¸šå‰å‡ å±‚å‡ä¼¤
                    if (hasEarlyLowHpClassBuff()) {
                        enemyDamage = Math.max(1, Math.floor(enemyDamage * 0.75));
                    }
                    gameState.player.health -= enemyDamage;
                    updateStats();
                    
                    // BOSSæœ‰ç‰¹æ®Šæ”»å‡»æ¶ˆæ¯
                    if (isBoss) {
                        const attackMessages = [
                            `${enemy.name}ä½¿ç”¨å¼ºåŠ›ä¸€å‡»ï¼Œé€ æˆ ${enemyDamage} ç‚¹ä¼¤å®³!`,
                            `${enemy.name}å‘åŠ¨çŒ›çƒˆæ”»å‡»ï¼Œé€ æˆ ${enemyDamage} ç‚¹ä¼¤å®³!`,
                            `${enemy.name}çš„æ”»å‡»å‡»ä¸­äº†ä½ ï¼Œé€ æˆ ${enemyDamage} ç‚¹ä¼¤å®³!`
                        ];
                        const msgIndex = Math.floor(Math.random() * attackMessages.length);
                        addMessage(attackMessages[msgIndex]);
                    } else {
                        addMessage(`${enemy.name}åå‡», é€ æˆ ${enemyDamage} ç‚¹ä¼¤å®³!`);
                    }
                    
                    // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                    if (gameState.player.health <= 0) {
                        gameOver();
                    }
                }
            }
            
            // æ›´æ–°çŠ¶æ€å’Œåœ°å›¾
            updateStats();
            renderMap();
        }

        // ä¿®æ”¹æ‹¾å–ç‰©å“å‡½æ•°ï¼Œæ›´æ–°ä½ç½®æ˜ å°„
        function pickUpItem(itemIndex) {
            const item = gameState.items[itemIndex];
            
            // æ ¹æ®ç‰©å“ç±»å‹åº”ç”¨æ•ˆæœ
            switch (item.type) {
                case "health":
                    let healAmount = item.value;
                    
                    // ç‰§å¸ˆæ²»ç–—å¢ç›Š
                    if (gameState.player.classAbilities.healingBoost) {
                        healAmount = Math.floor(healAmount * (1 + gameState.player.classAbilities.healingBoost));
                    }
                    
                    gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, æ¢å¤äº† ${healAmount} ç‚¹ç”Ÿå‘½å€¼!`);
                    break;
                case "maxHealth":
                    gameState.player.maxHealth += item.value;
                    gameState.player.health += item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, ç”Ÿå‘½ä¸Šé™æ°¸ä¹…å¢åŠ  ${item.value}!`);
                    break;
                case "attack":
                    gameState.player.attack += item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, æ”»å‡»åŠ›æš‚æ—¶å¢åŠ  ${item.value}!`);
                    break;
                case "permAttack":
                    gameState.player.attack += item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, æ”»å‡»åŠ›æ°¸ä¹…å¢åŠ  ${item.value}!`);
                    break;
                case "defense":
                    gameState.player.defense += item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, é˜²å¾¡åŠ›æš‚æ—¶å¢åŠ  ${item.value}!`);
                    break;
                case "permDefense":
                    gameState.player.defense += item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, é˜²å¾¡åŠ›æ°¸ä¹…å¢åŠ  ${item.value}!`);
                    break;
                case "gold":
                    gameState.player.gold += item.value;
                    addMessage(`ä½ æ‹¾å–äº†${item.value}é‡‘å¸!`);
                    break;
                // æ–°å¢ç‰©å“æ•ˆæœ
                case "berserk":
                    gameState.player.attack += item.value;
                    gameState.player.defense = Math.max(0, gameState.player.defense - 1);
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, è¿›å…¥ç‹‚æš´çŠ¶æ€! æ”»å‡»+${item.value}, é˜²å¾¡-1`);
                    break;
                case "stealth":
                    gameState.player.stealth = item.value;
                    addMessage(`ä½ ä½¿ç”¨äº†${item.name}, è·å¾—${item.value}å›åˆçš„éšèº«æ•ˆæœ!`);
                    break;
                
                case "experience":
                    // éšæœºæå‡ä¸€é¡¹å±æ€§
                    const attr = Math.floor(Math.random() * 3);
                    switch(attr) {
                        case 0:
                            gameState.player.maxHealth += 2;
                            gameState.player.health += 2;
                            addMessage(`ä½ ä½¿ç”¨äº†${item.name}, ç”Ÿå‘½ä¸Šé™å¢åŠ äº†2ç‚¹!`);
                            break;
                        case 1:
                            gameState.player.attack += 1;
                            addMessage(`ä½ ä½¿ç”¨äº†${item.name}, æ”»å‡»åŠ›å¢åŠ äº†1ç‚¹!`);
                            break;
                        case 2:
                            gameState.player.defense += 1;
                            addMessage(`ä½ ä½¿ç”¨äº†${item.name}, é˜²å¾¡åŠ›å¢åŠ äº†1ç‚¹!`);
                            break;
                    }
                    break;
            }
            
            // ä»ä½ç½®æ˜ å°„ä¸­ç§»é™¤
            delete gameState.entityMap.items[`${item.x},${item.y}`];
            
            // ç§»é™¤ç‰©å“
            gameState.items.splice(itemIndex, 1);
            
            // æ›´æ–°æ‰€æœ‰å¤§äºè¢«åˆ é™¤ç‰©å“ç´¢å¼•çš„æ˜ å°„
            for (let key in gameState.entityMap.items) {
                if (gameState.entityMap.items[key] > itemIndex) {
                    gameState.entityMap.items[key]--;
                }
            }
            
            // æ›´æ–°çŠ¶æ€
            updateStats();
        }

        // ä¿®æ”¹æ•Œäººç§»åŠ¨å‡½æ•°ï¼Œæ›´æ–°ä½ç½®æ˜ å°„
        function tryMoveEnemy(enemyIndex, dx, dy) {
            const enemy = gameState.enemies[enemyIndex];
            const nx = enemy.x + dx;
            const ny = enemy.y + dy;
            
            // æ£€æŸ¥è¾¹ç•Œå’Œå¢™å£
            if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25 || gameState.map[ny][nx] === 1) {
                return false;
            }
            
            // ä½¿ç”¨ä½ç½®æ˜ å°„æ£€æŸ¥å…¶ä»–æ•Œäºº
            const posKey = `${nx},${ny}`;
            if (gameState.entityMap.enemies[posKey] !== undefined && gameState.entityMap.enemies[posKey] !== enemyIndex) {
                return false;
            }
            
            // ä½¿ç”¨ä½ç½®æ˜ å°„æ£€æŸ¥ç‰©å“
            if (gameState.entityMap.items[posKey] !== undefined) {
                return false;
            }
            
            // æ£€æŸ¥ç©å®¶
            if (nx === gameState.player.x && ny === gameState.player.y) {
                // æ”»å‡»ç©å®¶
                const enemy = gameState.enemies[enemyIndex];
                const damage = Math.max(1, enemy.attack - gameState.player.defense);
                let finalDamage = damage;
                // ä½è¡€é‡èŒä¸šå‰å‡ å±‚å‡ä¼¤
                if (hasEarlyLowHpClassBuff()) {
                    finalDamage = Math.max(1, Math.floor(finalDamage * 0.75));
                }
                gameState.player.health -= finalDamage;
                updateStats();
                addMessage(`${enemy.name}æ”»å‡»äº†ä½ , é€ æˆ ${finalDamage} ç‚¹ä¼¤å®³!`);
                
                // æ£€æŸ¥ç©å®¶æ˜¯å¦æ­»äº¡
                if (gameState.player.health <= 0) {
                    gameOver();
                }
                
                return true;
            }
            
            // æ£€æŸ¥å‡ºå£
            if (nx === gameState.exit.x && ny === gameState.exit.y) {
                return false;
            }
            
            // ä»æ—§ä½ç½®çš„æ˜ å°„ä¸­ç§»é™¤
            delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
            
            // ç§»åŠ¨æ•Œäºº
            enemy.x = nx;
            enemy.y = ny;
            
            // æ›´æ–°ä½ç½®æ˜ å°„
            gameState.entityMap.enemies[`${nx},${ny}`] = enemyIndex;
            
            return true;
        }

        // è¿›å…¥ä¸‹ä¸€å±‚
        function descendDungeon() {
            gameState.depth++;
            
            // åªåœ¨ç”Ÿæ—¥ç¥ç¦æ¿€æ´»æ—¶æ˜¾ç¤º
            if (gameState.birthdayEnabled) {
                addMessage("å‘¨æ¢“è½©ç”Ÿæ—¥å¿«ä¹ï¼");
            }
            
            // æ¯å±‚å¥–åŠ±é‡‘å¸ (å±‚æ•° Ã— 10)
            let coinReward = gameState.depth * 10;

            // éš¾åº¦å½±å“é‡‘å¸
            const diffGold = difficulties[gameState.difficulty] || difficulties.normal;
            coinReward = Math.floor(coinReward * (diffGold.goldFindMultiplier || 1));
            
            // ç›—è´¼è·å¾—æ›´å¤šé‡‘å¸
            if (gameState.player.classAbilities.increaseLoot) {
                coinReward = Math.floor(coinReward * (1 + gameState.player.classAbilities.increaseLoot));
            }
            
            gameState.player.gold += coinReward;
            
            // ä¿®å¤ï¼šå…ˆæ›´æ–°ä¸»é¢˜
            // æ ¹æ®æ·±åº¦é€‰æ‹©ä¸»é¢˜
            const themeIndex = (gameState.depth - 1) % dungeonThemes.length;
            gameState.theme = dungeonThemes[themeIndex].name;
            
            // å¦‚æœä¸‹ä¸€å±‚æ˜¯BOSSå±‚ï¼Œæå‰è­¦å‘Š
            if (gameState.depth % 8 === 0) {
                addMessage(`ä½ è¿›å…¥äº†${getDungeonThemeDisplay()}çš„ç¬¬ ${gameState.depth} å±‚...`);
                addMessage(`è­¦å‘Šï¼šè¿™ä¸€å±‚æœ‰å¼ºå¤§çš„BOSSå®ˆæŠ¤ï¼`);
            } else {
                addMessage(`ä½ è¿›å…¥äº†${getDungeonThemeDisplay()}çš„ç¬¬ ${gameState.depth} å±‚...`);
            }
            
            if (gameState.depth === 4) {
                addMessage('æé†’ï¼šä»ç¬¬4å±‚å¼€å§‹ä¼šå‡ºç°"å‡çº§æ€ªç‰©"ã€‚');
            }
            
            addMessage(`å‘ç°äº† ${coinReward} é‡‘å¸!`);
            
            // ç‰§å¸ˆæ¯å±‚å›å¤ç”Ÿå‘½
            if (gameState.player.classAbilities.regenPerLevel) {
                const regenAmount = gameState.player.classAbilities.regenPerLevel;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + regenAmount);
                addMessage(`ä½ çš„æ²»æ„ˆèƒ½åŠ›è®©ä½ æ¢å¤äº† ${regenAmount} ç‚¹ç”Ÿå‘½å€¼!`);
            }
            
            // æ¯3å±‚æ¢å¤ä¸€äº›ç”Ÿå‘½å€¼
            if (gameState.depth % 3 === 0) {
                const healAmount = 3;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                addMessage(`æ·±å…¥åœ°ä¸‹è®©ä½ æ„Ÿåˆ°æŒ¯å¥‹, æ¢å¤äº† ${healAmount} ç‚¹ç”Ÿå‘½å€¼!`);
            }
            
            // ç”Ÿæˆæ–°åœ°ç‰¢
            generateDungeon();
            
            // æ›´æ–°çŠ¶æ€å’Œåœ°å›¾
            updateStats();
            renderMap();
        }

        // æ•Œäººå›åˆ
        function enemyTurn() {
            // æ£€æŸ¥æ˜¯å¦æœ‰éšèº«æ•ˆæœ
            if (gameState.player.stealth > 0) {
                gameState.player.stealth--;
                addMessage(`éšèº«æ•ˆæœå‰©ä½™ ${gameState.player.stealth} å›åˆ`);
                return; // éšèº«æ—¶æ•Œäººä¸è¡ŒåŠ¨
            }
            
            // æ›´æ–°ç©ºé—´åˆ†åŒºç³»ç»Ÿ
            updateSpatialGrid();
            
            // åªå¤„ç†ç©å®¶é™„è¿‘çš„æ•Œäººï¼Œä»¥æé«˜æ€§èƒ½
            const nearbyEnemies = [];
            const visionRange = 15; // ç›¸åŒçš„è§†é‡èŒƒå›´
            
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // ä½¿ç”¨ç©ºé—´åˆ†åŒºå¿«é€Ÿæ‰¾åˆ°é™„è¿‘çš„æ•Œäºº
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const gridX = Math.floor((playerX + dx * gameState.spatialGrid.cellSize) / gameState.spatialGrid.cellSize);
                    const gridY = Math.floor((playerY + dy * gameState.spatialGrid.cellSize) / gameState.spatialGrid.cellSize);
                    const key = `${gridX},${gridY}`;
                    
                    const cellContent = gameState.spatialGrid.grid[key];
                    if (cellContent && cellContent.enemies.length > 0) {
                        cellContent.enemies.forEach(enemyIndex => {
                            const enemy = gameState.enemies[enemyIndex];
                            const dist = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                            if (dist <= visionRange) {
                                nearbyEnemies.push(enemyIndex);
                            }
                        });
                    }
                }
            }
            
            // å¦‚æœæ²¡æœ‰ä½¿ç”¨ç©ºé—´åˆ†åŒºï¼Œå›é€€åˆ°æ£€æŸ¥æ‰€æœ‰æ•Œäºº
            if (nearbyEnemies.length === 0) {
                for (let i = 0; i < gameState.enemies.length; i++) {
                    const enemy = gameState.enemies[i];
                    const dist = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                    if (dist <= visionRange) {
                        nearbyEnemies.push(i);
                    }
                }
            }
            
            // åªå¤„ç†é™„è¿‘çš„æ•Œäºº
            for (const enemyIndex of nearbyEnemies) {
                const enemy = gameState.enemies[enemyIndex];
                
                // ç®€å•AI: å‰4å±‚æ•Œäººåªåœ¨è·ç¦»1æ ¼æ—¶æ‰ä¼šåŠ¨
                const distToPlayer = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                if (gameState.depth <= 4 && distToPlayer > 1) continue;
                
                if (distToPlayer <= 3) {
                    // å°è¯•ç§»åŠ¨åˆ°ç©å®¶
                    let dx = 0;
                    let dy = 0;
                    
                    if (Math.random() < 0.7) { // 70%å‡ ç‡å‘ç©å®¶ç§»åŠ¨
                        if (enemy.x < playerX) dx = 1;
                        else if (enemy.x > playerX) dx = -1;
                        
                        if (enemy.y < playerY) dy = 1;
                        else if (enemy.y > playerY) dy = -1;
                        
                        // éšæœºå†³å®šå…ˆç§»åŠ¨xè¿˜æ˜¯y
                        if (Math.random() < 0.5) {
                            if (dx !== 0) {
                                tryMoveEnemy(enemyIndex, dx, 0);
                                continue;
                            } else if (dy !== 0) {
                                tryMoveEnemy(enemyIndex, 0, dy);
                                continue;
                            }
                        } else {
                            if (dy !== 0) {
                                tryMoveEnemy(enemyIndex, 0, dy);
                                continue;
                            } else if (dx !== 0) {
                                tryMoveEnemy(enemyIndex, dx, 0);
                                continue;
                            }
                        }
                    }
                } else {
                    // è¿œç¦»ç©å®¶çš„æ•Œäººä¸è¡ŒåŠ¨ï¼Œä»¥èŠ‚çœæ€§èƒ½
                    continue;
                }
            }
            
            // æ ‡è®°ç©ºé—´åˆ†åŒºéœ€è¦é‡å»º
            gameState.spatialGrid.rebuild = true;
            
            // æ¸²æŸ“åœ°å›¾
            renderMap();
        }

        // æ¸¸æˆç»“æŸ
        function gameOver() {
            gameState.gameOver = true;
            addMessage("ä½ æ­»äº†! æ¸¸æˆç»“æŸ!");
            
            document.getElementById('final-depth').textContent = gameState.depth;
            document.getElementById('enemies-defeated').textContent = gameState.enemiesDefeated;
            document.getElementById('final-gold').textContent = gameState.player.gold;
            
            // ä¿®å¤ï¼šä½¿ç”¨textContentè€Œä¸æ˜¯innerHTML+=
            const className = classes[gameState.player.class].name;
            const gameOverEl = document.getElementById('game-over');
            
            // æ£€æŸ¥æ˜¯å¦å·²ç»å­˜åœ¨èŒä¸šä¿¡æ¯
            if (!gameOverEl.querySelector('.player-class-info')) {
                const classInfoElement = document.createElement('p');
                classInfoElement.className = 'player-class-info';
                classInfoElement.textContent = `èŒä¸š: ${className}`;
                gameOverEl.appendChild(classInfoElement);
            } else {
                document.querySelector('.player-class-info').textContent = `èŒä¸š: ${className}`;
            }
            
            gameOverEl.style.display = 'block';

            // è®°å½•æœ€ä½³æˆç»©ï¼ˆæŒ‰æœ€é«˜å±‚æ•°æ¯”è¾ƒï¼‰
            const currentRecord = {
                difficulty: gameState.difficulty,
                depth: gameState.depth,
                enemiesDefeated: gameState.enemiesDefeated,
                gold: gameState.player.gold,
                health: Math.max(gameState.player.health),
                maxHealth: gameState.player.maxHealth,
                attack: gameState.player.attack,
                defense: gameState.player.defense,
                class: gameState.player.class
            };
            const best = loadBestRecord();
            if (!best || currentRecord.depth > best.depth) {
                saveBestRecord(currentRecord);
                renderBestRecord();
                addMessage('æ–°çºªå½•ï¼ä½ çš„æœ€é«˜å±‚æ•°å·²æ›´æ–°ã€‚');
            }
        }

        // å›¾é‰´ç›¸å…³å‡½æ•°
        function showCodexTab(tabName) {
            // éšè—æ‰€æœ‰å†…å®¹
            document.querySelectorAll('.codex-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // å–æ¶ˆæ‰€æœ‰æ ‡ç­¾çš„æ¿€æ´»çŠ¶æ€
            document.querySelectorAll('.codex-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ¿€æ´»é€‰å®šçš„æ ‡ç­¾å’Œå†…å®¹
            document.getElementById(`${tabName}-content`).classList.add('active');
            document.querySelector(`.codex-tab[onclick="showCodexTab('${tabName}')"]`).classList.add('active');
            
            // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ˜¾ç¤ºï¼Œç”Ÿæˆå†…å®¹
            if (document.getElementById(`${tabName}-grid`).innerHTML === '') {
                generateCodexContent(tabName);
            }
        }
        
        function generateCodexContent(tabName) {
            const grid = document.getElementById(`${tabName}-grid`);
            grid.innerHTML = '';
            
            switch(tabName) {
                case 'monsters':
                    enemyTypes.forEach(enemy => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${enemy.name} (${enemy.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${enemy.description}</p>
                                    <p>ç”Ÿå‘½: ${enemy.health} | æ”»å‡»: ${enemy.attack} | é˜²å¾¡: ${enemy.defense}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'items':
                    itemTypes.forEach(item => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${item.name} (${item.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${item.description}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'bosses':
                    bossTypes.forEach(boss => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${boss.name} (${boss.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${boss.description}</p>
                                    <p>ç”Ÿå‘½: ${boss.health} | æ”»å‡»: ${boss.attack} | é˜²å¾¡: ${boss.defense}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'themes':
                    dungeonThemes.forEach(theme => {
                        // ä¸ºä¸»é¢˜æ·»åŠ æ›´å¤šè¯¦ç»†ä¿¡æ¯
                        let enemyExamples = '';
                        if (theme.enemyNameModifiers) {
                            const examples = Object.values(theme.enemyNameModifiers).slice(0, 3);
                            if (examples.length > 0) {
                                enemyExamples = `<p>å…¸å‹æ•Œäºº: ${examples.join('ã€')}</p>`;
                            }
                        }
                        
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${theme.displayName}</div>
                                <div class="codex-item-desc">
                                    <p>${theme.description}</p>
                                    ${enemyExamples}
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'special':
                    specialRooms.forEach(room => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${room.name} (${room.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${room.description}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
            }
        }
        
        function openCodex() {
            document.getElementById('codex-modal').style.display = 'block';
            showCodexTab('monsters'); // é»˜è®¤æ˜¾ç¤ºæ€ªç‰©æ ‡ç­¾
        }
        
        function closeCodex() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        // æ·»åŠ æ‰“å¼€å•†åº—çš„å•ç‹¬å‡½æ•°
        function openShopIfAtLocation() {
            // æ£€æŸ¥ç©å®¶æ˜¯å¦åœ¨å•†åº—ä½ç½®
            if (gameState.player.x === gameState.shop.x && gameState.player.y === gameState.shop.y) {
                openShop();
            } else {
                addMessage("ä½ ä¸åœ¨å•†åº—ä½ç½®ï¼Œæ— æ³•ä¸å•†äººäº¤æ˜“ã€‚");
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            // åˆå§‹åŒ–è¾“å…¥å¤„ç†ç³»ç»Ÿ
            inputHandler.init();
            
            // æ–°æ¸¸æˆæŒ‰é’®
            document.getElementById('new-game-btn').addEventListener('click', initGame);

            // åœ¨èŒä¸š/éš¾åº¦é€‰æ‹©ç•Œé¢æŒ‰ç©ºæ ¼é”®å¼€å§‹
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('class-select-modal');
                if (!modal || modal.style.display === 'none') return;
                if (e.code === 'Space') {
                    e.preventDefault();
                    startGameWithClass();
                }
            });
            
            // é‡æ–°å¼€å§‹æŒ‰é’®
            document.getElementById('restart-btn').addEventListener('click', initGame);
            
            // å¸®åŠ©æŒ‰é’® - ä½¿ç”¨è‡ªå®šä¹‰å¯¹è¯æ¡†æ›¿ä»£alert
            document.getElementById('help-btn').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'block';
            });
            
            // å…³é—­å¸®åŠ©å¯¹è¯æ¡†æŒ‰é’®
            document.getElementById('help-close').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'none';
                localStorage.setItem('helpShown', 'true'); // æ ‡è®°ä¸ºå·²æ˜¾ç¤º
            });

            // å›¾é‰´æŒ‰é’®
            document.getElementById('codex-btn').addEventListener('click', openCodex);
            
            // å­˜æ¡£æŒ‰é’®
            document.getElementById('save-btn').addEventListener('click', function() {
                if (gameState.gameOver) {
                    addMessage("æ¸¸æˆå·²ç»“æŸï¼Œæ— æ³•å­˜æ¡£");
                    return;
                }
                showSaveLoadModal(true);
            });
            
            // è¯»æ¡£æŒ‰é’®
            document.getElementById('load-btn').addEventListener('click', function() {
                showSaveLoadModal(false);
            });
        }

        // ä¸ªäººè®°å½•é€»è¾‘
        const BEST_RECORD_KEY = 'roguelike_best_record_v1';
        function loadBestRecord() {
            try {
                const raw = localStorage.getItem(BEST_RECORD_KEY);
                if (!raw) return null;
                return JSON.parse(raw);
            } catch { return null; }
        }
        function saveBestRecord(record) {
            try {
                localStorage.setItem(BEST_RECORD_KEY, JSON.stringify(record));
            } catch {}
        }
        function renderBestRecord() {
            const el = document.getElementById('record-content');
            if (!el) return;
            const rec = loadBestRecord();
            if (!rec) { el.textContent = 'æš‚æ— è®°å½•'; el.classList.add('muted'); return; }
            const diffName = (difficulties[rec.difficulty] || difficulties.normal).displayName;
            el.classList.remove('muted');
            el.innerHTML = `
                éš¾åº¦: ${diffName}<br>
                æœ€é«˜å±‚æ•°: ${rec.depth}<br>
                å‡»è´¥æ•Œäºº: ${rec.enemiesDefeated}<br>
                æœ€ç»ˆé‡‘å¸: ${rec.gold}<br>
                å±æ€§: ç”Ÿå‘½ ${rec.health}/${rec.maxHealth}ï¼Œæ”» ${rec.attack}ï¼Œé˜² ${rec.defense}
            `;
        }

        // å¯åŠ¨æ¸¸æˆ
        window.onload = function() {
            initEventListeners();
            loadBestRecord();
            renderBestRecord();

            // åŠ è½½å­˜æ¡£
            for (let i = 0; i < 3; i++) {
                const savedData = localStorage.getItem(`roguelike_save_${i}`);
                if (savedData) {
                    gameState.saveSlots[i] = JSON.parse(savedData);
                }
            }

            // é»˜è®¤é€‰ä¸­â€œæ™®é€šâ€éš¾åº¦å¡ç‰‡
            selectDifficulty('normal');

            // å¼ºåˆ¶æ˜¾ç¤ºå¸®åŠ©ç•Œé¢ï¼ˆä»…é¦–æ¬¡å¯åŠ¨ï¼‰
            if (!localStorage.getItem('helpShown')) {
                const helpModal = document.getElementById('help-modal');
                const helpCloseBtn = document.getElementById('help-close');
                helpModal.style.display = 'block';
                helpCloseBtn.disabled = true;
                helpCloseBtn.style.opacity = 0.5;
                helpCloseBtn.style.backgroundColor = '#444'; // ç°è‰²
                let countdown = 10;
                helpCloseBtn.textContent = `å…³é—­ï¼ˆ${countdown}ï¼‰`;
                const timer = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        helpCloseBtn.textContent = `å…³é—­ï¼ˆ${countdown}ï¼‰`;
                    } else {
                        clearInterval(timer);
                        helpCloseBtn.disabled = false;
                        helpCloseBtn.style.opacity = 1;
                        helpCloseBtn.textContent = 'å…³é—­';
                        helpCloseBtn.style.backgroundColor = '#2196f3'; // è“è‰²
                        localStorage.setItem('helpShown', 'true'); // æ ‡è®°ä¸ºå·²æ˜¾ç¤º
                    }
                }, 1000);
            }

            initGame();
        };

        // æ·»åŠ å¤„ç†å•å…ƒæ ¼ç‚¹å‡»çš„å‡½æ•°
        function handleCellClick(targetX, targetY) {
            if (gameState.gameOver) return;
            // å¦‚æœæ˜¯å¼€å‘è€…AirèŒä¸šï¼Œç‚¹å‡»åœ°æ¿ç›´æ¥ç¬ç§»
            if (gameState.player.class === 'devair') {
                if (gameState.map[targetY][targetX] === 1) return; // å¢™ä¸å¯ç¬ç§»
                gameState.player.x = targetX;
                gameState.player.y = targetY;
                updateExplored(targetX, targetY);
                renderMap();
                addMessage(`ä½ ç¬ç§»åˆ°äº†(${targetX},${targetY})`);
                enemyTurn();
                return;
            }
            // å¦‚æœç‚¹å‡»çš„æ˜¯å¢™æˆ–æœªæ¢ç´¢åŒºåŸŸ,ä¸å¤„ç†
            if (gameState.map[targetY][targetX] === 1 || !gameState.explored[targetY][targetX]) {
                return;
            }
            
            // è·å–å½“å‰ç©å®¶ä½ç½®
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // å¦‚æœç‚¹å‡»å½“å‰ä½ç½®,ä¸å¤„ç†
            if (playerX === targetX && playerY === targetY) {
                return;
            }
            
            // å¦‚æœæ˜¯ç›¸é‚»æ ¼å­,ç›´æ¥ç§»åŠ¨
            const dx = targetX - playerX;
            const dy = targetY - playerY;
            
            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx === 0 || dy === 0)) { 
                // åªå…è®¸ä¸Šä¸‹å·¦å³ç§»åŠ¨,ä¸å…è®¸æ–œå‘ç§»åŠ¨
                movePlayer(dx, dy);
                return;
            }
            
            // å¯¹äºè¿œè·ç¦»ç‚¹å‡»,ä½¿ç”¨A*è·¯å¾„æŸ¥æ‰¾ç®—æ³• (æ›¿ä»£ç®€å•è´ªå¿ƒç®—æ³•)
            findPathAndMove(playerX, playerY, targetX, targetY);
        }

        // A*è·¯å¾„æŸ¥æ‰¾ç®—æ³•
        function findPathAndMove(startX, startY, endX, endY) {
            // èŠ‚ç‚¹ç»“æ„: {x, y, g, h, f, parent}
            const openList = [];
            const closedSet = new Set();
            
            // å¯å‘å‡½æ•°: æ›¼å“ˆé¡¿è·ç¦»
            function heuristic(x, y) {
                return Math.abs(x - endX) + Math.abs(y - endY);
            }
            
            // æ·»åŠ èµ·ç‚¹åˆ°å¼€æ”¾åˆ—è¡¨
            openList.push({
                x: startX,
                y: startY,
                g: 0,
                h: heuristic(startX, startY),
                f: heuristic(startX, startY),
                parent: null
            });
            
            // å½“å¼€æ”¾åˆ—è¡¨ä¸ä¸ºç©ºæ—¶ç»§ç»­æœç´¢
            while (openList.length > 0) {
                // æ‰¾å‡ºfå€¼æœ€å°çš„èŠ‚ç‚¹
                let minIndex = 0;
                for (let i = 1; i < openList.length; i++) {
                    if (openList[i].f < openList[minIndex].f) {
                        minIndex = i;
                    }
                }
                
                // å½“å‰èŠ‚ç‚¹
                const current = openList[minIndex];
                
                // å¦‚æœè¾¾åˆ°ç›®æ ‡ï¼Œæ„å»ºè·¯å¾„
                if (current.x === endX && current.y === endY) {
                    let path = [];
                    let temp = current;
                    
                    while (temp.parent) {
                        path.push({x: temp.x, y: temp.y});
                        temp = temp.parent;
                    }
                    
                    path.reverse();
                    
                    // ç§»åŠ¨åˆ°è·¯å¾„çš„ç¬¬ä¸€ä¸ªä½ç½®
                    if (path.length > 0) {
                        const nextStep = path[0];
                        const dx = nextStep.x - startX;
                        const dy = nextStep.y - startY;
                        movePlayer(dx, dy);
                    }
                    
                    return;
                }
                
                // ä»å¼€æ”¾åˆ—è¡¨ä¸­ç§»é™¤å½“å‰èŠ‚ç‚¹
                openList.splice(minIndex, 1);
                
                // æ·»åŠ å½“å‰èŠ‚ç‚¹åˆ°å…³é—­é›†
                closedSet.add(`${current.x},${current.y}`);
                
                // æ£€æŸ¥å››ä¸ªæ–¹å‘çš„é‚»å±…
                const directions = [
                    {dx: 0, dy: -1}, // ä¸Š
                    {dx: 1, dy: 0},  // å³
                    {dx: 0, dy: 1},  // ä¸‹
                    {dx: -1, dy: 0}  // å·¦
                ];
                
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // æ£€æŸ¥è¾¹ç•Œ
                    if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25) continue;
                    
                    // æ£€æŸ¥æ˜¯å¦æ˜¯å¢™æˆ–å·²åœ¨å…³é—­é›†ä¸­
                    if (gameState.map[ny][nx] === 1 || closedSet.has(`${nx},${ny}`)) continue;
                    
                    // è®¡ç®—gå€¼ (è·¯å¾„é•¿åº¦)
                    const g = current.g + 1;
                    
                    // æ£€æŸ¥æ˜¯å¦å·²åœ¨å¼€æ”¾åˆ—è¡¨ä¸­
                    let inOpenList = false;
                    for (let i = 0; i < openList.length; i++) {
                        if (openList[i].x === nx && openList[i].y === ny) {
                            inOpenList = true;
                            
                            // å¦‚æœæ–°è·¯å¾„æ›´å¥½ï¼Œæ›´æ–°
                            if (g < openList[i].g) {
                                openList[i].g = g;
                                openList[i].f = g + openList[i].h;
                                openList[i].parent = current;
                            }
                            break;
                        }
                    }
                    
                    // å¦‚æœä¸åœ¨å¼€æ”¾åˆ—è¡¨ä¸­ï¼Œæ·»åŠ 
                    if (!inOpenList) {
                        const h = heuristic(nx, ny);
                        openList.push({
                            x: nx,
                            y: ny,
                            g: g,
                            h: h,
                            f: g + h,
                            parent: current
                        });
                    }
                }
                
                // é™åˆ¶æœç´¢æ­¥éª¤ï¼Œé˜²æ­¢é•¿è·¯å¾„è®¡ç®—è¿‡ä¹…
                if (openList.length > 100) break;
            }
            
            // å¦‚æœæ²¡æ‰¾åˆ°è·¯å¾„ï¼Œä½¿ç”¨åŸæ¥çš„è´ªå¿ƒç®—æ³•
            movePlayerTowards(endX, endY);
        }

        // ä¼˜åŒ–çˆ¶ç±»
        movePlayerTowards = function(targetX, targetY) {
            // è·å–å½“å‰ä½ç½®
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // å†³å®šæ˜¯å…ˆæ°´å¹³ç§»åŠ¨è¿˜æ˜¯å…ˆå‚ç›´ç§»åŠ¨(éšæœº)
            let dx = 0;
            let dy = 0;
            
            if (Math.random() < 0.5) {
                // å…ˆå°è¯•æ°´å¹³ç§»åŠ¨
                if (playerX < targetX) dx = 1;
                else if (playerX > targetX) dx = -1;
                
                // å¦‚æœå·²ç»æ°´å¹³å¯¹é½,åˆ™å‚ç›´ç§»åŠ¨
                if (dx === 0) {
                    if (playerY < targetY) dy = 1;
                    else if (playerY > targetY) dy = -1;
                }
            } else {
                // å…ˆå°è¯•å‚ç›´ç§»åŠ¨
                if (playerY < targetY) dy = 1;
                else if (playerY > targetY) dy = -1;
                
                // å¦‚æœå·²ç»å‚ç›´å¯¹é½,åˆ™æ°´å¹³ç§»åŠ¨
                if (dy === 0) {
                    if (playerX < targetX) dx = 1;
                    else if (playerX > targetX) dx = -1;
                }
            }
            
            // å¦‚æœè®¡ç®—å‡ºäº†ç§»åŠ¨æ–¹å‘,åˆ™ç§»åŠ¨ä¸€æ­¥
            if (dx !== 0 || dy !== 0) {
                movePlayer(dx, dy);
            }
        };

        // ç‰¹æ®Šæˆ¿é—´å®šä¹‰
        const specialRooms = [
            {
                name: "ç¥­å›",
                symbol: "A",
                description: "ä¸€ä¸ªç¥ç§˜çš„ç¥­å›ï¼Œå¯ä»¥çŒ®ç¥­ç‰©å“æ¥è·å¾—éšæœºå¢ç›Šã€‚",
                effect: function(player) {
                    if (player.gold >= 20) {
                        player.gold -= 20;
                        const effects = [
                            {type: "maxHealth", value: 3, desc: "ç”Ÿå‘½ä¸Šé™+3"},
                            {type: "attack", value: 2, desc: "æ”»å‡»åŠ›+2"},
                            {type: "defense", value: 2, desc: "é˜²å¾¡åŠ›+2"}
                        ];
                        const effect = effects[Math.floor(Math.random() * effects.length)];
                        player[effect.type] += effect.value;
                        if (effect.type === "maxHealth") player.health += effect.value;
                        addMessage(`ä½ åœ¨ç¥­å›çŒ®ç¥­äº†20é‡‘å¸ï¼Œè·å¾—äº†${effect.desc}ï¼`);
                    } else {
                        addMessage("ä½ éœ€è¦è‡³å°‘20é‡‘å¸æ‰èƒ½åœ¨ç¥­å›çŒ®ç¥­ã€‚");
                    }
                }
            },
            {
                name: "è®­ç»ƒåœº",
                symbol: "T",
                description: "ä¸€ä¸ªå¤è€çš„è®­ç»ƒåœºï¼Œå¯ä»¥æ¶ˆè€—é‡‘å¸æå‡æˆ˜æ–—èƒ½åŠ›ã€‚",
                effect: function(player) {
                    if (player.gold >= 30) {
                        player.gold -= 30;
                        player.attack += 1;
                        player.defense += 1;
                        addMessage("ä½ åœ¨è®­ç»ƒåœºè¿›è¡Œäº†ç‰¹è®­ï¼Œæ”»å‡»åŠ›å’Œé˜²å¾¡åŠ›å„+1ï¼");
                    } else {
                        addMessage("ä½ éœ€è¦è‡³å°‘30é‡‘å¸æ‰èƒ½ä½¿ç”¨è®­ç»ƒåœºã€‚");
                    }
                }
            },
            {
                name: "ç”Ÿå‘½ä¹‹æ³‰",
                symbol: "F",
                description: "ä¸€ä¸ªç¥å¥‡çš„æ³‰æ°´ï¼Œå¯ä»¥æ¢å¤ç”Ÿå‘½å€¼ã€‚",
                effect: function(player) {
                    const healAmount = Math.floor(player.maxHealth * 0.3);
                    player.health = Math.min(player.maxHealth, player.health + healAmount);
                    addMessage(`ä½ åœ¨ç”Ÿå‘½ä¹‹æ³‰ä¸­ä¼‘æ¯ï¼Œæ¢å¤äº†${healAmount}ç‚¹ç”Ÿå‘½å€¼ï¼`);
                }
            },
            {
                name: "å®è—å®¤",
                symbol: "V",
                description: "ä¸€ä¸ªå……æ»¡è´¢å®çš„æˆ¿é—´ï¼Œä½†å¯èƒ½æœ‰é™·é˜±ã€‚",
                effect: function(player) {
                    if (Math.random() < 0.7) {
                        const gold = 20 + Math.floor(Math.random() * 30);
                        player.gold += gold;
                        addMessage(`ä½ æ‰¾åˆ°äº†${gold}é‡‘å¸çš„å®è—ï¼`);
                    } else {
                        const damage = Math.floor(player.maxHealth * 0.2);
                        player.health = Math.max(1, player.health - damage);
                        addMessage(`ä½ è§¦å‘äº†é™·é˜±ï¼Œå—åˆ°äº†${damage}ç‚¹ä¼¤å®³ï¼`);
                    }
                }
            },
            {
                name: "å†¥æƒ³æ± ",
                symbol: "M",
                description: "ä¸€ä¸ªå¯ä»¥å¹³é™å¿ƒçµçš„æ°´æ± ï¼Œæ²‰æµ¸å…¶ä¸­èƒ½æ„Ÿå—åˆ°å¥‡å¦™çš„åŠ›é‡ã€‚",
                effect: function(player) {
                    // éšæœºæå‡ä¸¤é¡¹å±æ€§
                    const attrs = ["attack", "defense", "maxHealth"];
                    const boostValues = [1, 1, 2]; // å¯¹åº”å±æ€§æå‡å€¼
                    const usedIndices = new Set();
                    
                    // éšæœºé€‰æ‹©ä¸¤ç§ä¸åŒçš„å±æ€§
                    for (let i = 0; i < 2; i++) {
                        let index;
                        do {
                            index = Math.floor(Math.random() * attrs.length);
                        } while (usedIndices.has(index));
                        
                        usedIndices.add(index);
                        const attr = attrs[index];
                        const value = boostValues[index];
                        
                        player[attr] += value;
                        if (attr === "maxHealth") player.health += value;
                        
                        let attrName = "";
                        if (attr === "attack") attrName = "æ”»å‡»åŠ›";
                        else if (attr === "defense") attrName = "é˜²å¾¡åŠ›";
                        else if (attr === "maxHealth") attrName = "ç”Ÿå‘½ä¸Šé™";
                        
                        addMessage(`å†¥æƒ³è®©ä½ çš„${attrName}æå‡äº†${value}ç‚¹ï¼`);
                    }
                    
                    addMessage("ä½ æ„Ÿåˆ°å†…å¿ƒå¹³é™è€Œå¼ºå¤§...");
                }
            },
            {
                name: "é”»é€ ç‚‰",
                symbol: "K",
                description: "ä¸€ä¸ªå¤è€çš„é”»é€ ç‚‰ï¼Œèƒ½å¤Ÿç”¨é‡‘å¸å¼ºåŒ–ä½ çš„æ­¦å™¨æˆ–é˜²å…·ã€‚",
                effect: function(player) {
                    if (player.gold >= 40) {
                        player.gold -= 40;
                        
                        // ç©å®¶é€‰æ‹©å¼ºåŒ–æ”»å‡»æˆ–é˜²å¾¡
                        const choice = Math.random() < 0.5 ? "attack" : "defense";
                        
                        if (choice === "attack") {
                            player.attack += 2;
                            addMessage("ä½ å°†é‡‘å¸æŠ•å…¥é”»é€ ç‚‰ï¼Œä½ çš„æ­¦å™¨å˜å¾—æ›´åŠ é”‹åˆ©ï¼æ”»å‡»åŠ›+2");
                        } else {
                            player.defense += 2;
                            addMessage("ä½ å°†é‡‘å¸æŠ•å…¥é”»é€ ç‚‰ï¼Œä½ çš„æŠ¤ç”²å˜å¾—æ›´åŠ åšå›ºï¼é˜²å¾¡åŠ›+2");
                        }
                    } else {
                        addMessage("ä½ éœ€è¦40é‡‘å¸æ‰èƒ½ä½¿ç”¨é”»é€ ç‚‰ã€‚");
                    }
                }
            }
        ];

        // ç”Ÿæˆç‰¹æ®Šæˆ¿é—´
        function generateSpecialRoom(x, y, width, height, type) {
            // åœ¨æˆ¿é—´ä¸­å¤®æ”¾ç½®ç‰¹æ®Šæ ‡è®°
            const centerX = Math.floor(x + width / 2);
            const centerY = Math.floor(y + height / 2);
            
            // æ‰©å¤§ç‰¹æ®Šæˆ¿é—´åŒºåŸŸ - åœ¨ä¸­å¿ƒç‚¹å‘¨å›´å½¢æˆä¸€ä¸ªåå­—å½¢çš„ç‰¹æ®ŠåŒºåŸŸ
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const nx = centerX + dx;
                    const ny = centerY + dy;
                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25 && 
                        gameState.map[ny][nx] === 0) {
                        // åœ¨ç‰¹æ®Šæˆ¿é—´å‘¨å›´æ·»åŠ è£…é¥°æ€§åœ°æ¿
                        gameState.map[ny][nx] = 0; // ç¡®ä¿æ˜¯åœ°æ¿
                    }
                }
            }
            
            return {
                x: centerX,
                y: centerY,
                ...type,
                used: false
            };
        }

        // æ›´æ–°ç©ºé—´åˆ†åŒºç½‘æ ¼
        function updateSpatialGrid() {
            if (!gameState.spatialGrid.rebuild) return;
            
            const { cellSize } = gameState.spatialGrid;
            gameState.spatialGrid.grid = {};
            
            // æ·»åŠ æ•Œäººåˆ°ç©ºé—´ç½‘æ ¼
            gameState.enemies.forEach((enemy, index) => {
                const gridX = Math.floor(enemy.x / cellSize);
                const gridY = Math.floor(enemy.y / cellSize);
                const key = `${gridX},${gridY}`;
                
                if (!gameState.spatialGrid.grid[key]) {
                    gameState.spatialGrid.grid[key] = { enemies: [], items: [] };
                }
                
                gameState.spatialGrid.grid[key].enemies.push(index);
            });
            
            // æ·»åŠ ç‰©å“åˆ°ç©ºé—´ç½‘æ ¼
            gameState.items.forEach((item, index) => {
                const gridX = Math.floor(item.x / cellSize);
                const gridY = Math.floor(item.y / cellSize);
                const key = `${gridX},${gridY}`;
                
                if (!gameState.spatialGrid.grid[key]) {
                    gameState.spatialGrid.grid[key] = { enemies: [], items: [] };
                }
                
                gameState.spatialGrid.grid[key].items.push(index);
            });
            
            gameState.spatialGrid.rebuild = false;
        }

        // è·å–æŒ‡å®šä½ç½®çš„ç©ºé—´åˆ†åŒºå†…å®¹
        function getSpatialGridContent(x, y) {
            const { cellSize } = gameState.spatialGrid;
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);
            const key = `${gridX},${gridY}`;
            
            return gameState.spatialGrid.grid[key] || { enemies: [], items: [] };
        }

        // æ·»åŠ å­˜æ¡£/è¯»æ¡£ç›¸å…³å‡½æ•°
        function showSaveLoadModal(isSave) {
            const modal = document.getElementById('save-load-modal');
            const title = document.getElementById('modal-title');
            const slotsContainer = document.getElementById('save-slots');
            
            title.textContent = isSave ? 'é€‰æ‹©å­˜æ¡£æ§½' : 'é€‰æ‹©è¯»æ¡£æ§½';
            slotsContainer.innerHTML = '';
            
            // ç”Ÿæˆ3ä¸ªå­˜æ¡£æ§½
            for (let i = 0; i < 3; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.style.display = 'flex';
                slotDiv.style.justifyContent = 'space-between';
                slotDiv.style.alignItems = 'center';
                slotDiv.style.margin = '10px 0';
                slotDiv.style.padding = '10px';
                slotDiv.style.backgroundColor = '#333';
                slotDiv.style.borderRadius = '5px';
                
                const slotInfo = document.createElement('div');
                if (gameState.saveSlots[i]) {
                    const d = gameState.saveSlots[i];
                    const diffName = (d.difficulty && difficulties[d.difficulty]) ? difficulties[d.difficulty].displayName : 'æ™®é€š';
                    slotInfo.innerHTML = `å­˜æ¡£ ${i+1}<br>éš¾åº¦: ${diffName} æ·±åº¦: ${d.depth} é‡‘å¸: ${d.player.gold}`;
                } else {
                    slotInfo.textContent = `å­˜æ¡£ ${i+1} (ç©º)`;
                }
                
                const slotButton = document.createElement('button');
                slotButton.textContent = isSave ? 'å­˜æ¡£' : 'è¯»æ¡£';
                slotButton.style.backgroundColor = isSave ? '#4CAF50' : '#2196F3';
                slotButton.style.color = 'white';
                slotButton.style.border = 'none';
                slotButton.style.padding = '5px 10px';
                slotButton.style.borderRadius = '3px';
                slotButton.style.cursor = 'pointer';
                
                slotButton.onclick = (function(slotIndex) {
                    return function() {
                        if (isSave) {
                            saveGame(slotIndex);
                        } else {
                            loadGame(slotIndex);
                        }
                        closeSaveLoadModal();
                    };
                })(i);
                
                // æ–°å¢åˆ é™¤æŒ‰é’®
                const deleteButton = document.createElement('button');
                deleteButton.textContent = 'åˆ é™¤';
                deleteButton.style.backgroundColor = '#f44336';
                deleteButton.style.color = 'white';
                deleteButton.style.border = 'none';
                deleteButton.style.padding = '5px 10px';
                deleteButton.style.borderRadius = '3px';
                deleteButton.style.cursor = 'pointer';
                deleteButton.style.marginLeft = '10px';
                deleteButton.onclick = (function(slotIndex) {
                    return function() {
                        if (gameState.saveSlots[slotIndex]) {
                            if (confirm(`ç¡®å®šè¦åˆ é™¤å­˜æ¡£ ${slotIndex+1} å—ï¼Ÿ`)) {
                                clearSave(slotIndex);
                                showSaveLoadModal(isSave); // åˆ·æ–°åˆ—è¡¨
                            }
                        } else {
                            addMessage(`å­˜æ¡£ ${slotIndex+1} ä¸ºç©ºï¼Œæ— éœ€åˆ é™¤ã€‚`);
                        }
                    };
                })(i);
                
                slotDiv.appendChild(slotInfo);
                slotDiv.appendChild(slotButton);
                slotDiv.appendChild(deleteButton);
                slotsContainer.appendChild(slotDiv);
            }
            
            modal.style.display = 'block';
        }

        function closeSaveLoadModal() {
            document.getElementById('save-load-modal').style.display = 'none';
        }

        function saveGame(slotIndex) {
            try {
                const saveData = {
                    player: JSON.parse(JSON.stringify(gameState.player)),
                    depth: gameState.depth,
                    enemiesDefeated: gameState.enemiesDefeated,
                    map: JSON.parse(JSON.stringify(gameState.map)),
                    explored: JSON.parse(JSON.stringify(gameState.explored)),
                    enemies: JSON.parse(JSON.stringify(gameState.enemies)),
                    items: JSON.parse(JSON.stringify(gameState.items)),
                    exit: JSON.parse(JSON.stringify(gameState.exit)),
                    messages: JSON.parse(JSON.stringify(gameState.messages)),
                    shop: JSON.parse(JSON.stringify(gameState.shop)),
                    theme: gameState.theme,
                    specialRooms: JSON.parse(JSON.stringify(gameState.specialRooms)),
                    entityMap: JSON.parse(JSON.stringify(gameState.entityMap)),
                    birthdayEnabled: gameState.birthdayEnabled,
                    difficulty: gameState.difficulty,
                    timestamp: new Date().toLocaleString()
                };

                // ä¿å­˜åˆ°å†…å­˜å’Œ localStorage
                gameState.saveSlots[slotIndex] = saveData;
                localStorage.setItem(`roguelike_save_${slotIndex}`, JSON.stringify(saveData));
                addMessage(`æ¸¸æˆå·²ä¿å­˜åˆ°å­˜æ¡£ ${slotIndex + 1}`);
            } catch (e) {
                console.error("å­˜æ¡£å¤±è´¥:", e);
                addMessage("å­˜æ¡£å¤±è´¥ï¼Œå¯èƒ½æ˜¯å­˜å‚¨ç©ºé—´ä¸è¶³ï¼");
            }
        }

        function loadGame(slotIndex) {
            try {
                const savedData = localStorage.getItem(`roguelike_save_${slotIndex}`);
                if (!savedData) {
                    addMessage("è¯¥å­˜æ¡£æ§½ä¸ºç©ºï¼");
                    return;
                }

                const saveData = JSON.parse(savedData);
                Object.keys(saveData).forEach(key => {
                    if (key !== 'timestamp' && gameState.hasOwnProperty(key)) {
                        gameState[key] = JSON.parse(JSON.stringify(saveData[key]));
                    }
                });

                // å…¼å®¹æ—§ç‰ˆå­˜æ¡£æ— éš¾åº¦å­—æ®µ
                if (!gameState.difficulty) {
                    gameState.difficulty = 'normal';
                }
                selectedDifficulty = gameState.difficulty;

                gameState.currentSaveSlot = slotIndex;
                gameState.fullRenderNeeded = true;
                gameState.spatialGrid.rebuild = true;

                updateStats();
                renderMap();
                addMessage(`å·²ä»å­˜æ¡£ ${slotIndex + 1} åŠ è½½æ¸¸æˆ`);
                addMessage(`å­˜æ¡£æ—¶é—´: ${saveData.timestamp}`);
            } catch (e) {
                console.error("è¯»æ¡£å¤±è´¥:", e);
                addMessage("è¯»æ¡£å¤±è´¥ï¼Œå­˜æ¡£å¯èƒ½å·²æŸåï¼");
            }
        }

        function clearSave(slotIndex) {
            // ä»å†…å­˜ä¸­æ¸…é™¤
            gameState.saveSlots[slotIndex] = null;
            
            // ä» localStorage ä¸­æ¸…é™¤
            localStorage.removeItem(`roguelike_save_${slotIndex}`);
            addMessage(`å·²æ¸…é™¤å­˜æ¡£ ${slotIndex + 1}`);
        }

        // ç›‘å¬Té”®å®ç°å¼€å‘è€…Airç¬ç§»
        document.addEventListener('keydown', function(e) {
            if (gameState.player && gameState.player.class === 'devair' && !gameState.gameOver) {
                if (e.key === 't' || e.key === 'T') {
                    let input = prompt('è¾“å…¥ç›®æ ‡åæ ‡ï¼ˆæ ¼å¼ï¼šx,yï¼ŒèŒƒå›´0-29,0-24ï¼‰ï¼š');
                    if (!input) return;
                    let parts = input.split(',');
                    if (parts.length !== 2) { alert('æ ¼å¼é”™è¯¯'); return; }
                    let x = parseInt(parts[0].trim());
                    let y = parseInt(parts[1].trim());
                    if (isNaN(x) || isNaN(y) || x < 0 || x > 29 || y < 0 || y > 24) {
                        alert('åæ ‡è¶…å‡ºèŒƒå›´'); return;
                    }
                    if (gameState.map && gameState.map[y] && gameState.map[y][x] === 0) {
                        gameState.player.x = x;
                        gameState.player.y = y;
                        updateExplored(x, y);
                        renderMap();
                        addMessage(`ä½ ç¬ç§»åˆ°äº†(${x},${y})`);
                        enemyTurn();
                    } else {
                        alert('ç›®æ ‡ä¸æ˜¯åœ°æ¿ï¼Œæ— æ³•ç¬ç§»');
                    }
                }
            }
        });
    </script>
</body>
</html>
