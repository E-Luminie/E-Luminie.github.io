<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Roguelike 地牢探索</title>
    <style>
        body {
            font-family: 'Courier New', monospace;
            background-color: #111;
            color: #eee;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            max-width: 1000px;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.3);
        }
        
        #game-title {
            color: #ff5555;
            text-shadow: 0 0 5px #ff0000, 0 0 15px #ff0000;
            margin-bottom: 10px;
            font-size: 2.5em;
            letter-spacing: 2px;
        }
        
        #game-board {
            display: grid;
            grid-template-columns: repeat(30, 16px);
            grid-template-rows: repeat(25, 16px);
            gap: 1px;
            background-color: #333;
            border: 2px solid #555;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: fit-content;
            margin: 0 auto;
        }
        
        .cell {
            width: 16px;
            height: 16px;
            background-color: #222;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 14px;
            user-select: none;
            transition: background-color 0.1s ease;
        }
        
        .wall {
            background-color: #555;
            border-radius: 3px;
        }
        
        .player {
            color: #55ff55;
            font-weight: bold;
            text-shadow: 0 0 3px #00ff00;
        }
        
        .enemy {
            color: #ff5555;
            text-shadow: 0 0 3px #ff0000;
        }
        
        .item {
            color: #5599ff;
            text-shadow: 0 0 3px #0066ff;
        }
        
        .exit {
            color: #ffff55;
            text-shadow: 0 0 3px #ffff00;
            animation: pulse 1.5s infinite;
        }
        
        .explored {
            background-color: #333;
        }
        
        #stats {
            display: flex;
            justify-content: space-around;
            width: 580px;
            margin-bottom: 10px;
            background-color: #222;
            padding: 10px;
            border-radius: 5px;
            border: 1px solid #444;
        }
        
        #stats div {
            display: flex;
            align-items: center;
            margin-right: 15px;
        }
        
        #stats span {
            color: #ffcc44;
            font-weight: bold;
            margin-left: 5px;
        }

        /* 生命值进度条样式 */
        #health-bar {
            width: 100px;
            height: 10px;
            background-color: #333;
            border-radius: 5px;
            overflow: hidden;
            margin-left: 5px;
        }
        
        #health-fill {
            height: 100%;
            background-color: #5f5;
            transition: width 0.3s ease;
        }
        
        #message-log {
            width: 580px;
            height: 100px;
            border: 1px solid #555;
            padding: 10px;
            overflow-y: auto;
            background-color: #111;
            font-size: 14px;
            border-radius: 5px;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.5);
        }
        
        #controls {
            margin-top: 20px;
        }
        
        button {
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            padding: 8px 15px;
            margin: 0 5px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            border-radius: 5px;
            transition: all 0.2s ease;
        }
        
        button:hover {
            background-color: #444;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.2);
        }
        
        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border: 2px solid #ff0000;
            text-align: center;
            display: none;
        }
        
        #game-over h2 {
            color: #ff0000;
            margin-top: 0;
        }

        /* 添加商店样式 */
        #shop-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            z-index: 1000;
            min-width: 300px;
        }

        #shop-items {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 15px 0;
        }

        .shop-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px 10px;
            background-color: #333;
            border: 1px solid #444;
        }

        .shop-item button {
            background-color: #4a4;
            border: none;
            padding: 5px 10px;
            color: white;
            cursor: pointer;
        }

        .shop-item button:disabled {
            background-color: #666;
            cursor: not-allowed;
        }

        .shop-item-price {
            color: #ff5;
        }

        /* 添加职业选择模态框样式 */
        #class-select-modal {
            display: flex;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            justify-content: center;
            align-items: center;
            overflow-y: auto;
            padding: 20px 0;
        }

        #class-select-container {
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
            max-width: 1200px;
            text-align: center;
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .class-options {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .class-card {
            width: 200px;
            height: 250px;
            background-color: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .class-card:hover {
            border-color: #ffcc44;
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(255, 204, 68, 0.3);
        }

        .class-card.selected {
            border-color: #5f5;
            box-shadow: 0 0 15px rgba(85, 255, 85, 0.5);
        }

        /* 难度选择样式 */
        .difficulty-options {
            display: flex;
            justify-content: center;
            gap: 12px;
            margin-top: 10px;
            flex-wrap: wrap;
        }
        .difficulty-card {
            width: 160px;
            min-height: 110px;
            background-color: #333;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }
        .difficulty-card:hover {
            border-color: #ffcc44;
            transform: translateY(-3px);
            box-shadow: 0 5px 12px rgba(255, 204, 68, 0.25);
        }
        .difficulty-card.selected {
            border-color: #5f5;
            box-shadow: 0 0 12px rgba(85, 255, 85, 0.45);
        }
        .difficulty-name {
            font-size: 16px;
            font-weight: bold;
            color: #ffcc44;
            margin-bottom: 6px;
        }
        .difficulty-desc {
            font-size: 12px;
            color: #ccc;
            line-height: 1.4;
        }

        .class-name {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
            color: #ffcc44;
        }

        .class-symbol {
            font-size: 32px;
            margin: 10px 0;
        }

        .class-desc {
            font-size: 12px;
            text-align: center;
            color: #ccc;
        }

        .class-stats {
            margin-top: 10px;
            font-size: 12px;
            text-align: left;
            width: 100%;
        }

        .start-game-btn {
            background-color: #4a4;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }

        .start-game-btn:hover {
            background-color: #5c5;
            box-shadow: 0 0 10px rgba(85, 255, 85, 0.5);
        }

        /* 个人记录样式 */
        #record-panel {
            margin-top: 16px;
            background-color: #2a2a2a;
            border: 1px solid #444;
            border-radius: 8px;
            padding: 12px;
            text-align: left;
        }
        #record-panel h3 {
            color: #ffcc44;
            margin: 0 0 8px 0;
            font-size: 16px;
            border-bottom: 1px dotted #444;
            padding-bottom: 6px;
        }
        #record-content {
            color: #ddd;
            font-size: 13px;
            line-height: 1.6;
        }
        #record-content .muted { color: #aaa; }

        /* 层级主题样式 */
        .theme-cave .cell {
            background-color: #223;
        }
        .theme-cave .wall {
            background-color: #446;
        }
        .theme-cave .explored {
            background-color: #334;
        }

        .theme-forest .cell {
            background-color: #232;
        }
        .theme-forest .wall {
            background-color: #464;
        }
        .theme-forest .explored {
            background-color: #343;
        }

        .theme-ruins .cell {
            background-color: #322;
        }
        .theme-ruins .wall {
            background-color: #644;
        }
        .theme-ruins .explored {
            background-color: #433;
        }

        .theme-crystal .cell {
            background-color: #225;
        }
        .theme-crystal .wall {
            background-color: #44a;
        }
        .theme-crystal .explored {
            background-color: #336;
        }

        .theme-volcanic .cell {
            background-color: #422;
        }
        .theme-volcanic .wall {
            background-color: #622;
        }
        .theme-volcanic .explored {
            background-color: #533;
        }

        /* 新增地域样式 */
        .theme-desert .cell {
            background-color: #542;
        }
        .theme-desert .wall {
            background-color: #875;
        }
        .theme-desert .explored {
            background-color: #653;
        }

        .theme-ice .cell {
            background-color: #e0f7ff; /* 更亮更接近白色 */
        }
        .theme-ice .wall {
            background-color: #7ecbff; /* 更深的蓝色，突出墙体 */
        }
        .theme-ice .explored {
            background-color: #cbeaff; /* 适中亮度，和cell区分 */
        }

        .theme-void .cell {
            background-color: #204;
        }
        .theme-void .wall {
            background-color: #506;
        }
        .theme-void .explored {
            background-color: #315;
        }

        /* BOSS样式 */
        .boss {
            color: #ff3333;
            font-weight: bold;
            text-shadow: 0 0 8px #ff0000;
            animation: boss-pulse 1.2s infinite;
        }
        
        @keyframes boss-pulse {
            0% { text-shadow: 0 0 4px #ff0000; }
            50% { text-shadow: 0 0 12px #ff0000; }
            100% { text-shadow: 0 0 4px #ff0000; }
        }

        /* 图鉴样式 */
        #codex-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            overflow-y: auto;
        }

        #codex-container {
            max-width: 800px;
            margin: 50px auto;
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
        }

        .codex-section {
            margin-bottom: 20px;
        }

        .codex-title {
            color: #ffcc44;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
            margin-bottom: 10px;
        }

        .codex-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 10px;
        }

        .codex-item {
            background-color: #333;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 10px;
        }

        .codex-item-name {
            color: #5599ff;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .codex-item-desc {
            font-size: 12px;
            color: #ccc;
        }

        .codex-close {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        .codex-tabs {
            display: flex;
            border-bottom: 1px solid #444;
            margin-bottom: 15px;
        }

        .codex-tab {
            padding: 8px 15px;
            cursor: pointer;
            background-color: #333;
            border: 1px solid #444;
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            margin-right: 5px;
        }

        .codex-tab.active {
            background-color: #444;
            color: #ffcc44;
        }

        .codex-content {
            display: none;
        }

        .codex-content.active {
            display: block;
        }

        /* 主题显示样式 */
        #theme-display {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #444;
            color: #ffcc44;
            font-size: 14px;
        }
        
        /* 商店物品描述 */
        .shop-item {
            position: relative;
        }
        
        .shop-item-tooltip {
            display: none;
            position: absolute;
            top: -5px;
            left: 105%;
            width: 200px;
            background-color: #111;
            border: 1px solid #444;
            border-radius: 5px;
            padding: 8px;
            font-size: 12px;
            z-index: 100;
            color: #ccc;
        }
        
        .shop-item:hover .shop-item-tooltip {
            display: block;
        }
        
        .shop-item-tooltip-title {
            color: #5599ff;
            font-weight: bold;
            margin-bottom: 5px;
            border-bottom: 1px solid #333;
            padding-bottom: 3px;
        }

        /* 特殊房间样式 */
        .special-room {
            color: #ffaa00;
            text-shadow: 0 0 5px #ff8800;
            animation: special-room-pulse 2s infinite;
            cursor: pointer;
        }

        @keyframes special-room-pulse {
            0% { text-shadow: 0 0 3px #ff8800; }
            50% { text-shadow: 0 0 8px #ff8800; }
            100% { text-shadow: 0 0 3px #ff8800; }
        }

        /* 特殊房间提示框样式 */
        .cell[title] {
            position: relative;
        }

        .cell[title]:hover::after {
            content: attr(title);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        /* 添加帮助对话框样式 */
        #help-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 2000;
            overflow-y: auto;
        }

        #help-container {
            max-width: 800px;
            margin: 50px auto;
            background-color: #222;
            padding: 20px;
            border: 2px solid #555;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            color: #eee;
            line-height: 1.6;
        }

        #help-container h2 {
            color: #ffcc44;
            text-align: center;
            margin-bottom: 20px;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
        }

        #help-container h3 {
            color: #5599ff;
            margin-top: 20px;
            margin-bottom: 10px;
            border-bottom: 1px dotted #444;
            padding-bottom: 5px;
        }

        #help-container ul {
            margin: 10px 0;
            padding-left: 25px;
        }

        #help-container li {
            margin-bottom: 5px;
        }

        #help-close {
            background-color: #444;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            display: block;
            margin-left: auto;
            margin-right: auto;
        }

        #help-close:hover {
            background-color: #555;
        }

        .theme-ice .cell,
        .theme-ice .wall,
        .theme-ice .explored {
            color: #111 !important;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <h1 id="game-title">Roguelike 地牢探索</h1>
        
        <div id="stats">
            <div>深度: <span id="depth">1</span></div>
            <div>生命: <span id="health">10</span>/<span id="max-health">10</span>
                <div id="health-bar"><div id="health-fill" style="width: 100%"></div></div>
            </div>
            <div>攻击: <span id="attack">3</span></div>
            <div>防御: <span id="defense">1</span></div>
            <div>金币: <span id="gold">0</span></div>
        </div>
        
        <div id="theme-display">当前区域: <span id="current-theme">洞穴</span></div>
        
        <div id="game-board"></div>
        
        <div id="message-log"></div>
        
        <div id="record-panel" style="width:580px;">
            <h3>个人记录</h3>
            <div id="record-content" class="muted">暂无记录</div>
        </div>
        
        <div id="controls">
            <button id="new-game-btn">新游戏</button>
            <button id="save-btn">存档</button>
            <button id="load-btn">读档</button>
            <button id="help-btn">帮助</button>
            <button id="codex-btn">图鉴</button>
        </div>
    </div>
    
    <div id="game-over">
        <h2>游戏结束!</h2>
        <p>你到达了第 <span id="final-depth">1</span> 层</p>
        <p>击败了 <span id="enemies-defeated">0</span> 个敌人</p>
        <p>收集了 <span id="final-gold">0</span> 金币</p>
        <button id="restart-btn">重新开始</button>
    </div>

    <!-- 添加商店模态框 -->
    <div id="shop-modal">
        <h2>商店</h2>
        <div id="shop-items"></div>
        <!-- 商店关闭按钮 -->
        <button onclick="closeShop()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">离开商店</button>
    </div>

    <!-- 添加职业选择模态框 -->
    <div id="class-select-modal">
        <div id="class-select-container">
            <h2>选择你的职业</h2>
            <div style="margin-top:8px; font-size:14px; color:#bbb">请选择职业与难度后开始</div>
            <div class="difficulty-options">
                <div class="difficulty-card" onclick="selectDifficulty('easy')">
                    <div class="difficulty-name">简单</div>
                    <div class="difficulty-desc">玩家更强，敌人更弱，更多掉落与更便宜的商店。</div>
                </div>
                <div class="difficulty-card selected" onclick="selectDifficulty('normal')">
                    <div class="difficulty-name">普通</div>
                    <div class="difficulty-desc">标准体验，平衡的敌人与奖励。</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('hard')">
                    <div class="difficulty-name">困难</div>
                    <div class="difficulty-desc">敌人更强更密集，道具更少，商店更贵。</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('diyu')">
                    <div class="difficulty-name">地狱</div>
                    <div class="difficulty-desc">强敌遍地，奖励减少，极具挑战性。</div>
                </div>
                <div class="difficulty-card" onclick="selectDifficulty('ultra')">
                    <div class="difficulty-name">ULTRA</div>
                    <div class="difficulty-desc">极限难度：敌人极强且众多，道具稀缺。</div>
                </div>
            </div>
            <div class="class-options">
                <div class="class-card" onclick="selectClass('warrior')">
                    <div class="class-name">战士</div>
                    <div class="class-symbol">⚔️</div>
                    <div class="class-desc">强大的近战职业，擅长与敌人正面交锋</div>
                    <div class="class-stats">
                        初始生命: 12<br>
                        初始攻击: 2<br>
                        初始防御: 2<br>
                        特殊能力: 增加伤害5%, 增加防御10%
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('rogue')">
                    <div class="class-name">盗贼</div>
                    <div class="class-symbol">🗡️</div>
                    <div class="class-desc">灵活的刺客，善于寻找宝物</div>
                    <div class="class-stats">
                        初始生命: 8<br>
                        初始攻击: 3<br>
                        初始防御: 1<br>
                        特殊能力: 金币获取+20%, 20%几率闪避攻击
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('mage')">
                    <div class="class-name">法师</div>
                    <div class="class-symbol">✨</div>
                    <div class="class-desc">神秘的魔法使用者，拥有强大的破坏力</div>
                    <div class="class-stats">
                        初始生命: 7<br>
                        初始攻击: 4<br>
                        初始防御: 2<br>
                        特殊能力: 20%几率造成双倍伤害，商店商品降价15%
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('cleric')">
                    <div class="class-name">牧师</div>
                    <div class="class-symbol">✝️</div>
                    <div class="class-desc">神圣的治疗者，拥有超强的生存能力</div>
                    <div class="class-stats">
                        初始生命: 10<br>
                        初始攻击: 1<br>
                        初始防御: 2<br>
                        特殊能力: 治疗效果增加50%, 30%几率在一张地图内出现第二个商店
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('hunter')">
                    <div class="class-name">猎人</div>
                    <div class="class-symbol">🏹</div>
                    <div class="class-desc">擅长陷阱与远程攻击的荒野专家</div>
                    <div class="class-stats">
                        初始生命: 9<br>
                        初始攻击: 2<br>
                        初始防御: 1<br>
                        特殊能力: 15%几率暴击, 20%几率反击敌人, 5码范围BOSS视野
                    </div>
                </div>
                <div class="class-card" onclick="selectClass('warlock')">
                    <div class="class-name">术士</div>
                    <div class="class-symbol">🔮</div>
                    <div class="class-desc">使用黑暗力量的施法者，可吸血</div>
                    <div class="class-stats">
                        初始生命: 11<br>
                        初始攻击: 2<br>
                        初始防御: 0<br>
                        特殊能力: 50%几率吸血, BOSS层增加10%生命上限
                    </div>
                </div>
                <div class="class-card devpro-card" onclick="selectClass('devpro')" style="display:none">
                    <div class="class-name">开发者Pro</div>
                    <div class="class-symbol">💻</div>
                    <div class="class-desc">隐藏职业，拥有极限属性和无限金币</div>
                    <div class="class-stats">
                        初始生命: 100<br>
                        初始攻击: 100<br>
                        初始防御: 100<br>
                        特殊能力: 无限金币
                    </div>
                </div>
                <div class="class-card devair-card" onclick="selectClass('devair')" style="display:none">
                    <div class="class-name">开发者Air</div>
                    <div class="class-symbol">🛸</div>
                    <div class="class-desc">隐藏职业，可以瞬移到任何区域</div>
                    <div class="class-stats">
                        初始生命: 50<br>
                        初始攻击: 50<br>
                        初始防御: 50<br>
                        特殊能力: 瞬移到任意区域
                    </div>
                </div>
            </div>
            <div style="margin-top:10px; color:#bbb; font-size:13px;">提示：在此界面按空格键可直接开始游戏</div>
            <button class="start-game-btn" onclick="startGameWithClass()">开始冒险</button>
        </div>
    </div>

    <!-- 添加图鉴模态框 -->
    <div id="codex-modal">
        <div id="codex-container">
            <h2>探索图鉴</h2>
            
            <div class="codex-tabs">
                <div class="codex-tab active" onclick="showCodexTab('monsters')">怪物</div>
                <div class="codex-tab" onclick="showCodexTab('items')">物品</div>
                <div class="codex-tab" onclick="showCodexTab('bosses')">BOSS</div>
                <div class="codex-tab" onclick="showCodexTab('themes')">地域</div>
                <div class="codex-tab" onclick="showCodexTab('special')">特殊房间</div>
            </div>
            
            <div id="monsters-content" class="codex-content active">
                <div class="codex-grid" id="monsters-grid"></div>
            </div>
            
            <div id="items-content" class="codex-content">
                <div class="codex-grid" id="items-grid"></div>
            </div>
            
            <div id="bosses-content" class="codex-content">
                <div class="codex-grid" id="bosses-grid"></div>
            </div>
            
            <div id="themes-content" class="codex-content">
                <div class="codex-grid" id="themes-grid"></div>
            </div>
            
            <div id="special-content" class="codex-content">
                <div class="codex-grid" id="special-grid"></div>
            </div>
            
            <!-- 图鉴关闭按钮 -->
            <button class="codex-close" onclick="closeCodex()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-top: 20px; display: block; margin-left: auto; margin-right: auto;">关闭</button>
        </div>
    </div>

    <!-- 添加帮助对话框 -->
    <div id="help-modal">
        <div id="help-container">
            <h2>地牢探索 - 奇幻冒险游戏</h2>
            <p id="birthday-message" style="display: none; text-align: center; color: #ffcc44; font-size: 18px; margin-top: -10px; margin-bottom: 20px;">周梓轩生日快乐</p>
            
            <h3>控制方式</h3>
            <ul>
                <li>W - 向上移动</li>
                <li>S - 向下移动</li>
                <li>A - 向左移动</li>
                <li>D - 向右移动</li>
                <li>E - 在商店位置时打开商店</li>
                <li>鼠标点击 - 移动到目标位置</li>
            </ul>
            
            <h3>难度</h3>
            <ul>
                <li>简单：敌人属性↓，数量↓，道具↑，商店更便宜，金币更多，玩家初始生命+2、防御+1。</li>
                <li>普通：标准规则。</li>
                <li>困难：敌人属性↑，数量↑，道具↓，商店更贵，金币略少。</li>
                <li>地狱：强敌遍地，商店很贵，道具偏少，金币更少，玩家初始生命-2、防御-1。</li>
                <li>ULTRA：极限挑战，敌人极强且更多，道具极少，商店最贵，金币最少。</li>
            </ul>
            
            <div style="margin: 6px 0 12px 0; color:#bbb; font-size:13px;">在职业/难度选择界面，按空格键可直接开始游戏。</div>
            <h3>游戏目标</h3>
            <ul>
                <li>探索随机生成的地牢</li>
                <li>收集金币和各种物品</li>
                <li>找到楼梯(>)前往下一层</li>
                <li>击败敌人获取奖励</li>
                <li>在商店(S)处使用金币购买强力物品</li>
                <li>探索特殊房间获得独特效果</li>
            </ul>
            
            <h3>敌人类型</h3>
            <ul>
                <li>基本敌人 - 小蝙蝠(b)、骷髅(s)、蜘蛛(p)、僵尸(z)、地精(g)</li>
                <li>高级敌人 - 魔法师(m)、石像鬼(t)、暗影刺客(a)（前三层不出现；第4层开始“升级怪物”出现）</li>
                <li>BOSS - 每8层出现一个强大的BOSS，拥有特殊能力</li>
            </ul>
            
            <h3>地域类型</h3>
            <ul>
                <li>基础区域 - 洞穴、迷雾森林、远古遗迹、水晶洞窟、火山深处</li>
                <li>高级区域 - 沙漠神殿、冰冻峡谷、虚空裂隙</li>
            </ul>
            
            <h3>特殊房间</h3>
            <ul>
                <li>祭坛(A) - 献祭金币获得随机增益</li>
                <li>训练场(T) - 消耗金币提升战斗能力</li>
                <li>生命之泉(F) - 恢复部分生命值</li>
                <li>宝藏室(V) - 获得金币但可能有陷阱</li>
                <li>冥想池(M) - 随机提升两种属性</li>
                <li>锻造炉(K) - 用金币强化武器或防具</li>
            </ul>
            
            <h3>游戏特点</h3>
            <ul>
                <li>每次生成全新随机地牢</li>
                <li>死亡即结束，没有重生</li>
                <li>随着深入地牢，敌人越来越强</li>
                <li>多种敌人和物品等待发现</li>
                <li>六种不同职业，各具特色</li>
                <li>每8层出现强大BOSS</li>
                <li>第4层开始会出现“升级怪物”。</li>
                <li>挑战自我，看看能达到多深的地牢层数！</li>
            </ul>
            
            <!-- 帮助对话框关闭按钮 -->
            <button id="help-close" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; margin-top: 20px; display: block; margin-left: auto; margin-right: auto;">关闭</button>
        </div>
    </div>

    <!-- 添加存档选择模态框 -->
    <div id="save-load-modal" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background-color: rgba(0,0,0,0.8); z-index: 1000;">
        <div style="background-color: #222; padding: 20px; border: 2px solid #555; border-radius: 10px; max-width: 400px; margin: 50px auto; text-align: center;">
            <h2 id="modal-title">选择存档槽</h2>
            <div id="save-slots" style="margin: 20px 0;">
                <!-- 存档槽将通过JS动态生成 -->
            </div>
            <button onclick="closeSaveLoadModal()" style="background-color: #2196f3; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer;">取消</button>
        </div>
    </div>

    <script>
        // 游戏状态
        const gameState = {
            player: { 
                x: 0, y: 0, 
                health: 10,
                maxHealth: 10, 
                attack: 3, 
                defense: 1, 
                gold: 0,
                class: '',
                classAbilities: {}
            },
            depth: 1,
            enemiesDefeated: 0,
            map: [],
            explored: [],
            enemies: [],
            items: [],
            exit: { x: 0, y: 0 },
            gameOver: false,
            messages: [],
            shop: { x: 0, y: 0, items: [] },
            theme: 'cave',  // 初始主题
            fullRenderNeeded: true, // 添加全渲染标记
            // 添加用于优化的位置映射
            entityMap: {
                enemies: {}, // 格式: "x,y": enemyIndex
                items: {},   // 格式: "x,y": itemIndex
            },
            specialRooms: [], // 添加特殊房间数组
            // 性能相关属性
            renderPending: false,     // 渲染请求标志
            updateNeeded: false,      // 更新请求标志
            lastFrameTime: 0,         // 上一帧时间
            fps: 0,                   // 当前FPS
            visibleCells: new Set(),  // 可见单元格缓存
            // 空间分区系统 - 将地图分为多个区块以加速碰撞检测
            spatialGrid: {
                cellSize: 5,  // 每个区块大小
                grid: {},     // 空间分区网格
                rebuild: true // 是否需要重建网格
            },
            // 在全局状态添加bossDefeatCount
            bossDefeatCount: 0,
            birthdayEnabled: false, // 生日祝福是否激活
            saveSlots: [null, null, null], // 3个存档槽
            currentSaveSlot: -1, // 当前使用的存档槽
            difficulty: 'normal',
        };

        // 对象池系统 - 用于重用对象以减少垃圾回收
        const objectPool = {
            // 实体池
            entities: [],
            // 获取一个实体对象
            getEntity() {
                if (this.entities.length > 0) {
                    return this.entities.pop();
                }
                return {}; // 创建新对象
            },
            // 回收一个实体对象
            recycleEntity(entity) {
                // 清空对象属性
                for (const key in entity) {
                    if (typeof entity[key] !== 'object') {
                        entity[key] = null;
                    } else if (entity[key] !== null) {
                        Object.keys(entity[key]).forEach(k => {
                            entity[key][k] = null;
                        });
                    }
                }
                this.entities.push(entity);
            },
            // 清空所有对象池
            clear() {
                this.entities = [];
            }
        };

        // 性能监控系统
        const performanceMonitor = {
            frameCount: 0,
            lastTimestamp: 0,
            fps: 0,
            renderTime: 0,
            updateTime: 0,
            enabled: false,  // 默认关闭性能监控
            
            // 开始一个性能计时
            startTimer() {
                return performance.now();
            },
            
            // 结束一个性能计时
            endTimer(startTime) {
                return performance.now() - startTime;
            },
            
            // 更新FPS计数
            updateFPS(timestamp) {
                this.frameCount++;
                // 每秒更新一次FPS
                if (timestamp - this.lastTimestamp >= 1000) {
                    this.fps = this.frameCount;
                    this.frameCount = 0;
                    this.lastTimestamp = timestamp;
                    
                    // 可选：显示性能指标
                    if (this.enabled) {
                        console.log(`FPS: ${this.fps}, Render: ${this.renderTime.toFixed(2)}ms, Update: ${this.updateTime.toFixed(2)}ms`);
                    }
                }
            }
        };
        
        // 输入处理系统（防抖和节流）
        const inputHandler = {
            keysPressed: {},      // 当前按下的按键
            lastKeyTime: 0,       // 上次按键时间
            keyThrottle: 100,     // 按键节流阈值 (ms)
            clickThrottle: 200,   // 点击节流阈值 (ms)
            lastClickTime: 0,     // 上次点击时间
            birthdaySequence: "", // 存储输入的序列
            requiredSequence: "wwssaadd61", // 需要输入的序列
            
            // 初始化输入处理
            init() {
                document.addEventListener('keydown', (e) => {
                    const key = e.key.toLowerCase();
                    
                    // 检查生日祝福激活序列
                    if (document.getElementById('help-modal').style.display === 'block') {
                        this.birthdaySequence += key;
                        
                        // 检查是否输入了完整序列
                        if (this.birthdaySequence.includes(this.requiredSequence)) {
                            gameState.birthdayEnabled = true;
                            document.getElementById('birthday-message').style.display = 'block';
                            this.birthdaySequence = ""; // 重置序列
                            addMessage("生日祝福已激活！");
                        }
                        
                        // 防止序列过长
                        if (this.birthdaySequence.length > 20) {
                            this.birthdaySequence = "";
                        }
                    }
                    
                    this.keysPressed[key] = true;
                    const now = performance.now();
                    
                    // 对按键输入进行节流
                    if (now - this.lastKeyTime > this.keyThrottle) {
                        this.lastKeyTime = now;
                        this.processInput();
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    delete this.keysPressed[e.key.toLowerCase()];
                });
            },
            
            // 处理输入
            processInput() {
                if (gameState.gameOver) return;
                
                // 处理方向键
                if (this.keysPressed['w'] || this.keysPressed['arrowup']) {
                    movePlayer(0, -1);
                } else if (this.keysPressed['s'] || this.keysPressed['arrowdown']) {
                    movePlayer(0, 1);
                } else if (this.keysPressed['a'] || this.keysPressed['arrowleft']) {
                    movePlayer(-1, 0);
                } else if (this.keysPressed['d'] || this.keysPressed['arrowright']) {
                    movePlayer(1, 0);
                } else if (this.keysPressed['e']) {
                    openShopIfAtLocation();
                }
            },
            
            // 处理单元格点击，包含节流逻辑
            handleCellClick(x, y) {
                const now = performance.now();
                if (now - this.lastClickTime < this.clickThrottle) return;
                this.lastClickTime = now;
                
                handleCellClick(x, y);
            }
        };

        // 层级主题
        const dungeonThemes = [
            { 
                name: 'cave', 
                displayName: '洞穴', 
                description: '黑暗潮湿的洞穴系统，栖息着各种适应了黑暗环境的生物。',
                enemyNameModifiers: {
                    "小蝙蝠": "洞穴蝙蝠",
                    "骷髅": "洞穴骷髅",
                    "蜘蛛": "洞穴蜘蛛",
                    "僵尸": "矿工僵尸",
                    "地精": "洞穴地精",
                    "魔法师": "洞穴法师",
                    "石像鬼": "岩石石像鬼",
                    "暗影刺客": "洞穴潜行者"
                }
            },
            { 
                name: 'forest', 
                displayName: '迷雾森林', 
                description: '被魔法迷雾覆盖的古老森林，传说中隐藏着精灵和自然元素的力量。',
                enemyNameModifiers: {
                    "小蝙蝠": "森林蝙蝠",
                    "骷髅": "树精骷髅",
                    "蜘蛛": "巨型林蛛",
                    "僵尸": "森林腐尸",
                    "地精": "木精灵",
                    "魔法师": "森林巫师",
                    "石像鬼": "树妖石像鬼",
                    "暗影刺客": "迷雾刺客"
                }
            },
            { 
                name: 'ruins', 
                displayName: '远古遗迹', 
                description: '一个被遗忘的古代文明遗址，充满了未知的危险和宝藏。',
                enemyNameModifiers: {
                    "小蝙蝠": "遗迹蝙蝠",
                    "骷髅": "古代士兵",
                    "蜘蛛": "守卫蜘蛛",
                    "僵尸": "古代祭司",
                    "地精": "遗迹守卫",
                    "魔法师": "远古法师",
                    "石像鬼": "遗迹守护者",
                    "暗影刺客": "古代刺客"
                }
            },
            { 
                name: 'crystal', 
                displayName: '水晶洞窟', 
                description: '闪耀着魔法光芒的水晶洞窟，这里的生物已经被水晶的能量改变。',
                enemyNameModifiers: {
                    "小蝙蝠": "水晶蝙蝠",
                    "骷髅": "水晶骷髅",
                    "蜘蛛": "水晶蜘蛛",
                    "僵尸": "水晶傀儡",
                    "地精": "水晶守卫",
                    "魔法师": "水晶法师",
                    "石像鬼": "水晶石像鬼",
                    "暗影刺客": "闪光刺客"
                }
            },
            { 
                name: 'volcanic', 
                displayName: '火山深处', 
                description: '炽热的地下火山区域，只有最坚韧的生物才能在这里生存。',
                enemyNameModifiers: {
                    "小蝙蝠": "火焰蝙蝠",
                    "骷髅": "灰烬骷髅",
                    "蜘蛛": "熔岩蜘蛛",
                    "僵尸": "火焰僵尸",
                    "地精": "火山地精",
                    "魔法师": "熔岩巫师",
                    "石像鬼": "岩浆石像鬼",
                    "暗影刺客": "灰烬刺客"
                }
            },
            { 
                name: 'desert', 
                displayName: '沙漠神殿', 
                description: '古老的沙漠建筑群，充满了陷阱和谜题，传说中藏有远古法老的宝藏。',
                enemyNameModifiers: {
                    "小蝙蝠": "沙漠蝙蝠",
                    "骷髅": "法老卫兵",
                    "蜘蛛": "沙漠蜘蛛",
                    "僵尸": "木乃伊",
                    "地精": "沙漠掠夺者",
                    "魔法师": "沙漠祭司",
                    "石像鬼": "神殿守卫",
                    "暗影刺客": "沙影刺客"
                }
            },
            { 
                name: 'ice', 
                displayName: '冰冻峡谷', 
                description: '寒冷刺骨的冰雪地带，这里的生物已经适应了极寒环境，具有独特的冰系能力。',
                enemyNameModifiers: {
                    "小蝙蝠": "霜翼蝙蝠",
                    "骷髅": "冰霜骷髅",
                    "蜘蛛": "冰晶蜘蛛",
                    "僵尸": "冰冻僵尸",
                    "地精": "雪地地精",
                    "魔法师": "冰霜法师",
                    "石像鬼": "冰雕石像鬼",
                    "暗影刺客": "雪影刺客"
                }
            },
            { 
                name: 'void', 
                displayName: '虚空裂隙', 
                description: '现实与虚无之间的可怕领域，拥有扭曲的空间和不稳定的物质结构，令人发疯的景象。',
                enemyNameModifiers: {
                    "小蝙蝠": "虚空飞行者",
                    "骷髅": "空间残骸",
                    "蜘蛛": "次元蜘蛛",
                    "僵尸": "虚空行尸",
                    "地精": "扭曲地精",
                    "魔法师": "虚空术士",
                    "石像鬼": "裂隙守卫",
                    "暗影刺客": "虚空猎手"
                }
            }
        ];

        // 敌人类型
        const enemyTypes = [
            { 
                name: "小蝙蝠", 
                health: 3, 
                attack: 2, 
                defense: 0, 
                symbol: "b", 
                exp: 1,
                description: "黑暗中敏捷的飞行生物，攻击力不高但行动迅速。"
            },
            { 
                name: "骷髅", 
                health: 5, 
                attack: 3, 
                defense: 1, 
                symbol: "s", 
                exp: 2,
                description: "被魔法复活的骸骨，具有一定的防御能力。"
            },
            { 
                name: "蜘蛛", 
                health: 4, 
                attack: 4, 
                defense: 0, 
                symbol: "p", 
                exp: 2,
                description: "八足的掠食者，攻击力较强但防御薄弱。"
            },
            { 
                name: "僵尸", 
                health: 7, 
                attack: 3, 
                defense: 2, 
                symbol: "z", 
                exp: 3,
                description: "行动缓慢但生命顽强的不死生物，具有较高的防御力。"
            },
            { 
                name: "地精", 
                health: 6, 
                attack: 5, 
                defense: 1, 
                symbol: "g", 
                exp: 4,
                description: "狡猾的生物，攻击力很高，是地牢中的危险敌人。"
            },
            { 
                name: "魔法师", 
                health: 5, 
                attack: 6, 
                defense: 0, 
                symbol: "m", 
                exp: 4,
                description: "掌握着元素魔法的施法者，拥有强大的攻击力但防御薄弱。"
            },
            { 
                name: "石像鬼", 
                health: 8, 
                attack: 4, 
                defense: 3, 
                symbol: "t", 
                exp: 5,
                description: "石头构成的飞行怪物，拥有很高的防御力和中等的攻击力。"
            },
            { 
                name: "暗影刺客", 
                health: 6, 
                attack: 7, 
                defense: 1, 
                symbol: "a", 
                exp: 5,
                description: "能在黑暗中隐形的刺客，攻击力极高但生命值和防御较低。"
            }
        ];

        // BOSS定义
        const bossTypes = [
            { 
                name: "地牢守卫", 
                health: 30, 
                attack: 7, 
                defense: 5,
                symbol: "G", // 守卫 Guardian
                exp: 10,
                description: "一个巨大的石头傀儡，守卫着地牢的秘密。拥有极高的防御力。"
            },
            { 
                name: "暗影巫师", 
                health: 24, 
                attack: 10, 
                defense: 3,
                symbol: "M", // Mage
                exp: 12,
                description: "控制黑暗魔法的强大巫师，可以召唤暗影仆从。防御力虽低但攻击极高。"
            },
            { 
                name: "地下龙兽", 
                health: 40, 
                attack: 8, 
                defense: 6,
                symbol: "D", // Dragon
                exp: 15,
                description: "地下洞穴中的恐怖生物，坚硬的鳞片和锋利的爪牙。拥有极高的生命值和防御力。"
            },
            { 
                name: "远古机械守卫", 
                health: 35, 
                attack: 9, 
                defense: 7,
                symbol: "R", // Robot/Remnant
                exp: 18,
                description: "远古文明留下的机械守卫，装备着强大的武器和装甲。拥有游戏中最高的防御力。"
            },
            { 
                name: "噩梦之王", 
                health: 45, 
                attack: 12, 
                defense: 5,
                symbol: "N", // Nightmare
                exp: 20,
                description: "从噩梦中诞生的恐怖存在，可以操控恐惧本身。全面强大的终极BOSS。"
            },
            { 
                name: "远古巨龙", 
                health: 50, 
                attack: 14, 
                defense: 6,
                symbol: "F", // Flame Dragon
                exp: 25,
                description: "传说中的火龙，可以喷吐毁灭性的龙息，拥有强大的攻击力和极高的生命值。"
            },
            { 
                name: "虚空领主", 
                health: 42, 
                attack: 16, 
                defense: 4,
                symbol: "V", // Void
                exp: 28,
                description: "来自虚空的神秘存在，可以操控时空和暗影魔法，攻击力极高但防御略低。"
            },
            { 
                name: "不灭守护者", 
                health: 60, 
                attack: 13, 
                defense: 8,
                symbol: "U", // Undying
                exp: 30,
                description: "神话中的不朽生物，拥有自愈能力和极高的防御力，是最为顽强的BOSS之一。"
            }
        ];

        // 物品类型
        const itemTypes = [
            { 
                name: "生命药水", 
                type: "health", 
                value: 3, 
                symbol: "!", 
                rarity: 2,
                description: "红色液体充满的小瓶，饮用后可恢复少量生命值。恢复3点生命值。"
            },
            { 
                name: "大生命药水", 
                type: "health", 
                value: 5, 
                symbol: "!", 
                rarity: 1,
                description: "更大的药水瓶，内含更纯净的治疗药剂。恢复5点生命值。"
            },
            { 
                name: "超级生命药水", 
                type: "health", 
                value: 8, 
                symbol: "!", 
                rarity: 1,
                description: "最高级别的治疗药剂，有着显著的治疗效果。恢复8点生命值。"
            },
            { 
                name: "攻击卷轴", 
                type: "attack", 
                value: 1, 
                symbol: "?", 
                rarity: 2,
                description: "刻有古老符文的卷轴，阅读后可短暂提升攻击力。增加1点攻击力。"
            },
            { 
                name: "强力攻击卷轴", 
                type: "attack", 
                value: 2, 
                symbol: "?", 
                rarity: 1,
                description: "刻有强力战斗符文的卷轴，效果更为显著。增加2点攻击力。"
            },
            { 
                name: "防御卷轴", 
                type: "defense", 
                value: 1, 
                symbol: "?", 
                rarity: 2,
                description: "记载着防御咒语的卷轴，阅读后可短暂提升防御力。增加1点防御力。"
            },
            { 
                name: "坚固防御卷轴", 
                type: "defense", 
                value: 2, 
                symbol: "?", 
                rarity: 1,
                description: "高级防护卷轴，能提供更强力的防御增益。增加2点防御力。"
            },
            { 
                name: "金币", 
                type: "gold", 
                value: 1, 
                symbol: "$", 
                rarity: 3,
                description: "闪闪发光的金币，是地牢中通用的货币，可在商店中购买物品。"
            },
            { 
                name: "金币堆", 
                type: "gold", 
                value: 5, 
                symbol: "$", 
                rarity: 2,
                description: "一小堆金币，是一笔不错的财富。价值5金币。"
            },
            { 
                name: "宝箱", 
                type: "gold", 
                value: 10, 
                symbol: "$", 
                rarity: 1,
                description: "装满金币的小箱子，是相当可观的财富。价值10金币。"
            },
            { 
                name: "生命上限药剂", 
                type: "maxHealth", 
                value: 2, 
                symbol: "+", 
                rarity: 1,
                description: "一种稀有的药剂，饮用后可永久增加生命上限。增加2点生命上限。"
            },
            { 
                name: "力量药剂", 
                type: "permAttack", 
                value: 1, 
                symbol: "^", 
                rarity: 1,
                description: "一种珍贵的红色药剂，饮用后可永久增加攻击力。增加1点攻击力。"
            },
            { 
                name: "护甲药剂", 
                type: "permDefense", 
                value: 1, 
                symbol: "&", 
                rarity: 1,
                description: "一种珍贵的蓝色药剂，饮用后可永久增加防御力。增加1点防御力。"
            },
            // 新增物品
            { 
                name: "狂暴药剂", 
                type: "berserk", 
                value: 3, 
                symbol: "*", 
                rarity: 1,
                description: "饮用后进入狂暴状态，攻击力+3，但防御力-1。"
            },
            { 
                name: "隐身药水", 
                type: "stealth", 
                value: 6, 
                symbol: "~", 
                rarity: 1,
                description: "使用后可以避免被敌人发现，持续6回合。"
            },

            { 
                name: "经验宝珠", 
                type: "experience", 
                value: 1, 
                symbol: "O", 
                rarity: 1,
                description: "蕴含着能量的宝珠，使用后可以随机提升一项属性。"
            }
        ];

        // 商店物品池
        const shopItemTypes = [
            { 
                name: "优质生命药水", 
                type: "health", 
                value: 6, 
                symbol: "!", 
                price: 20, // 原价15
                description: "特质配方酿造的药水，比普通药水有更好的治疗效果。恢复6点生命值。"
            },
            { 
                name: "特制生命药水", 
                type: "health", 
                value: 10, 
                symbol: "!", 
                price: 35, // 原价25
                description: "炼金大师制作的顶级药水，具有强大的治疗功效。恢复10点生命值。"
            },
            { 
                name: "攻击戒指", 
                type: "permAttack", 
                value: 1, 
                symbol: "^", 
                price: 40, // 原价30
                description: "镶嵌着红宝石的戒指，佩戴后可以永久增强攻击力。永久增加1点攻击力。"
            },
            { 
                name: "防御护符", 
                type: "permDefense", 
                value: 1, 
                symbol: "&", 
                price: 40, // 原价30
                description: "古老的守护护符，可以增强佩戴者的防御能力。永久增加1点防御力。"
            },
            { 
                name: "生命宝石", 
                type: "maxHealth", 
                value: 3, 
                symbol: "+", 
                price: 45, // 原价35
                description: "蕴含生命能量的宝石，可以增强使用者的生命力。永久增加3点生命上限。"
            },
            { 
                name: "力量手环", 
                type: "permAttack", 
                value: 2, 
                symbol: "^", 
                price: 65, // 原价50
                description: "传说中的战士佩戴的手环，可以大幅增强攻击力。永久增加2点攻击力。"
            },
            { 
                name: "守护铠甲", 
                type: "permDefense", 
                value: 2, 
                symbol: "&", 
                price: 65, // 原价50
                description: "由坚固材料制作的护甲碎片，可以显著提高防御能力。永久增加2点防御力。"
            },
            { 
                name: "生命之心", 
                type: "maxHealth", 
                value: 5, 
                symbol: "+", 
                price: 80, // 原价60
                description: "传说中的神器，据说是从某个强大生物体内取出。永久增加5点生命上限。"
            }
        ];

        // 职业定义
        const classes = {
            warrior: {
                name: '战士',
                health: 12,
                attack: 2,
                defense: 2,
                abilities: {
                    increaseDamage: 0.05,         // 增加伤害5%
                    increaseDefense: 0.1          // 增加防御10%
                }
            },
            rogue: {
                name: '盗贼',
                health: 8,
                attack: 3,
                defense: 1,
                abilities: {
                    increaseLoot: 0.2,           // 增加金币获取20%
                    dodgeChance: 0.2            // 20%几率闪避攻击
                }
            },
            mage: {
                name: '法师',
                health: 7,
                attack: 4,
                defense: 2,
                abilities: {
                    criticalHitChance: 0.2,     // 20%几率造成双倍伤害
                    shopDiscount: 0.15          // 商店商品降价15%
                }
            },
            cleric: {
                name: '牧师',
                health: 10,
                attack: 1,
                defense: 2,
                abilities: {
                    healingBoost: 0.5,          // 治疗效果增加50%
                    extraShop: 0.3              // 30%几率在一张地图内出现第二个商店
                }
            },
            // 新增职业：猎人
            hunter: {
                name: '猎人',
                health: 9,
                attack: 2,
                defense: 1,
                abilities: {
                    rangedAttack: 0.15,         // 15%几率在远处打击敌人
                    criticalHitChance: 0.15,    // 15%几率造成双倍伤害
                    trapChance: 0.2,            // 20%几率在被攻击时反击
                    bossVision: {
                        range: 5,
                        duration: 2
                    }
                }
            },
            // 新增职业：术士
            warlock: {
                name: '术士',
                health: 11,
                attack: 2,
                defense: 0,
                abilities: {
                    lifeSteal: 0.5,             // 50%几率吸血
                    bossHealthBoost: 0.1        // BOSS层增加10%生命上限
                }
            },
            devpro: {
                name: '开发者Pro',
                health: 100,
                attack: 100,
                defense: 100,
                abilities: {
                    infiniteGold: true
                }
            },
            devair: {
                name: '开发者Air',
                health: 50,
                attack: 50,
                defense: 50,
                abilities: {
                    teleport: true
                }
            }
        };

        let selectedClass = null;
        let selectedDifficulty = 'normal';

        // 低血量职业前期生存加成判定：初始生命≤10且深度≤4
        function hasEarlyLowHpClassBuff() {
            try {
                const cls = gameState && gameState.player && gameState.player.class ? gameState.player.class : null;
                if (!cls || !classes[cls]) return false;
                const baseHp = classes[cls].health;
                const isLowHpClass = baseHp <= 10;
                const isEarlyDepth = (gameState && typeof gameState.depth === 'number') ? (gameState.depth <= 4) : true;
                return isLowHpClass && isEarlyDepth;
            } catch(e) {
                return false;
            }
        }

        // 难度定义
        const difficulties = {
            easy: {
                key: 'easy',
                displayName: '简单',
                enemyStatMultiplier: 0.85,
                enemyCountDelta: -2,
                itemCountDelta: 2,
                shopPriceMultiplier: 0.8,
                playerDamageDealtMultiplier: 1.1,
                playerDamageTakenMultiplier: 0.85,
                goldFindMultiplier: 1.2,
                playerStartAdjust: { health: 2, attack: 0, defense: 1 }
            },
            normal: {
                key: 'normal',
                displayName: '普通',
                enemyStatMultiplier: 1.0,
                enemyCountDelta: 0,
                itemCountDelta: 0,
                shopPriceMultiplier: 1.0,
                playerDamageDealtMultiplier: 1.0,
                playerDamageTakenMultiplier: 1.0,
                goldFindMultiplier: 1.0,
                playerStartAdjust: { health: 0, attack: 0, defense: 0 }
            },
            hard: {
                key: 'hard',
                displayName: '困难',
                enemyStatMultiplier: 1.2,
                enemyCountDelta: 1,
                itemCountDelta: -1,
                shopPriceMultiplier: 1.2,
                playerDamageDealtMultiplier: 0.95,
                playerDamageTakenMultiplier: 1.15,
                goldFindMultiplier: 0.9,
                playerStartAdjust: { health: -1, attack: 0, defense: 0 }
            },
            diyu: { 
                key: 'diyu',
                displayName: '地狱',
                enemyStatMultiplier: 1.4,
                enemyCountDelta: 2,
                itemCountDelta: -2,
                shopPriceMultiplier: 1.4,
                playerDamageDealtMultiplier: 0.9,
                playerDamageTakenMultiplier: 1.3,
                goldFindMultiplier: 0.85,
                playerStartAdjust: { health: -2, attack: 0, defense: -1 }
            },
            ultra: {
                key: 'ultra',
                displayName: 'ULTRA',
                enemyStatMultiplier: 1.8,
                enemyCountDelta: 3,
                itemCountDelta: -3,
                shopPriceMultiplier: 1.6,
                playerDamageDealtMultiplier: 0.85,
                playerDamageTakenMultiplier: 1.5,
                goldFindMultiplier: 0.8,
                playerStartAdjust: { health: -3, attack: -1, defense: -2 }
            }
        };

        // 难度选择
        function selectDifficulty(difficultyKey) {
            selectedDifficulty = difficultyKey;
            // 取消所有已选中样式
            document.querySelectorAll('.difficulty-card').forEach(card => {
                card.classList.remove('selected');
            });
            // 添加选中样式
            const el = document.querySelector(`.difficulty-card[onclick="selectDifficulty('${difficultyKey}')"]`);
            if (el) el.classList.add('selected');
        }

        // 选择职业
        function selectClass(className) {
            selectedClass = className;
            
            // 移除所有已选中样式
            document.querySelectorAll('.class-card').forEach(card => {
                card.classList.remove('selected');
            });
            
            // 添加选中样式
            document.querySelector(`.class-card[onclick="selectClass('${className}')"]`).classList.add('selected');
        }

        // 开发者Pro激活逻辑
        (function(){
            const devproSequence = 'qwertyasdfghzxcvbn123456';
            let inputBuffer = '';
            // 只在职业选择界面显示时监听
            document.addEventListener('keydown', function(e) {
                const modal = document.getElementById('class-select-modal');
                if (modal && modal.style.display !== 'none') {
                    let key = e.key;
                    // 统一小写
                    if (/^[A-Z]$/.test(key)) key = key.toLowerCase();
                    inputBuffer += key;
                    if (inputBuffer.length > devproSequence.length) {
                        inputBuffer = inputBuffer.slice(-devproSequence.length);
                    }
                    if (inputBuffer === devproSequence) {
                        // 显示开发者Pro卡片
                        document.querySelector('.devpro-card').style.display = 'flex';
                    }
                }
            });
        })();
        // 开发者Air激活逻辑
        (function(){
            const devairSequence = 'qwerasdfzxcv7894';
            let inputBuffer = '';
            document.addEventListener('keydown', function(e) {
                const modal = document.getElementById('class-select-modal');
                if (modal && modal.style.display !== 'none') {
                    let key = e.key;
                    if (/^[A-Z]$/.test(key)) key = key.toLowerCase();
                    inputBuffer += key;
                    if (inputBuffer.length > devairSequence.length) {
                        inputBuffer = inputBuffer.slice(-devairSequence.length);
                    }
                    if (inputBuffer === devairSequence) {
                        document.querySelector('.devair-card').style.display = 'flex';
                    }
                }
            });
        })();

        // 使用所选职业开始游戏
        function startGameWithClass() {
            if (!selectedClass) {
                alert('请选择一个职业（也可按空格键快速开始）');
                return;
            }
            
            const chosenClass = classes[selectedClass];
            
            // 设置职业属性
            gameState.player.health = chosenClass.health;
            gameState.player.maxHealth = chosenClass.health;
            gameState.player.attack = chosenClass.attack;
            gameState.player.defense = chosenClass.defense;
            gameState.player.class = selectedClass;
            gameState.player.classAbilities = chosenClass.abilities;
            // 如果是开发者Pro，初始金币999999
            if(selectedClass === 'devpro') {
                gameState.player.gold = 999999;
            }
            
            // 关闭职业选择界面
            document.getElementById('class-select-modal').style.display = 'none';
            
            // 初始化游戏
            initGame();
        }

        // 初始化游戏
        function initGame() {
            if (!gameState.player.class) {
                document.getElementById('class-select-modal').style.display = 'flex';
                return;
            }
            // 确保商店界面隐藏
            document.getElementById('shop-modal').style.display = 'none';
            
            // 重置玩家状态（保留已选职业属性）
            const previousClass = gameState.player.class;
            const previousAbilities = gameState.player.classAbilities;
            
            gameState.player = { 
                x: 0, y: 0, 
                health: classes[previousClass].health, 
                maxHealth: classes[previousClass].health, 
                attack: classes[previousClass].attack, 
                defense: classes[previousClass].defense, 
                gold: 0,
                class: previousClass,
                classAbilities: previousAbilities
            };
            
            // 应用难度对玩家初始属性的调整
            const diff = difficulties[selectedDifficulty] || difficulties.normal;
            if (diff && diff.playerStartAdjust) {
                gameState.player.maxHealth += diff.playerStartAdjust.health;
                gameState.player.health += diff.playerStartAdjust.health;
                gameState.player.attack += diff.playerStartAdjust.attack;
                gameState.player.defense += diff.playerStartAdjust.defense;
                if (gameState.player.health > gameState.player.maxHealth) {
                    gameState.player.health = gameState.player.maxHealth;
                }
            }
            
            gameState.difficulty = selectedDifficulty;
            
            gameState.depth = 1;
            gameState.enemiesDefeated = 0;
            gameState.gameOver = false;
            gameState.messages = [];
            gameState.fullRenderNeeded = true; // 添加全渲染标记
            
            // 设置初始主题
            gameState.theme = dungeonThemes[0].name;
            
            generateDungeon();
            updateStats();
            renderMap();
            addMessage(`你作为${classes[gameState.player.class].name}进入了${getDungeonThemeDisplay()}的第一层...`);
            const diffName = (difficulties[gameState.difficulty] || difficulties.normal).displayName;
            addMessage(`当前难度: ${diffName}`);
            // 展示当前难度对玩家的具体影响
            const d = difficulties[gameState.difficulty] || difficulties.normal;
            const diffDetail = [
                `玩家对敌人伤害×${d.playerDamageDealtMultiplier || 1}`,
                `玩家受到伤害×${d.playerDamageTakenMultiplier || 1}`,
                `敌人属性×${d.enemyStatMultiplier || 1}`,
                `敌人数量调整: ${d.enemyCountDelta > 0 ? '+'+d.enemyCountDelta : d.enemyCountDelta}`,
                `道具数量调整: ${d.itemCountDelta > 0 ? '+'+d.itemCountDelta : d.itemCountDelta}`,
                `商店价格×${d.shopPriceMultiplier || 1}`,
                `金币掉落×${d.goldFindMultiplier || 1}`
            ].join('，');
            addMessage(`难度效果：${diffDetail}`);
            // 强制刷新一次状态条，确保初始动画填满
            updateStats();
            // 如果触发前期低血量职业减伤，给出提示
            if (hasEarlyLowHpClassBuff()) {
                addMessage('早期生存加成：你的职业在前几层受到的伤害降低。');
            }
            
            document.getElementById('game-over').style.display = 'none';
            const music = document.getElementById('background-music');
            music.play(); // 播放音乐
            gameState.currentSaveSlot = -1;
        }

        // 获取当前主题显示名
        function getDungeonThemeDisplay() {
            const theme = dungeonThemes.find(t => t.name === gameState.theme);
            return theme ? theme.displayName : '未知区域';
        }

        // 生成地牢
        function generateDungeon() {
            // 清空地图
            gameState.map = [];
            gameState.explored = [];
            gameState.enemies = [];
            gameState.items = [];
            gameState.fullRenderNeeded = true; // 添加全渲染标记
            
            // 创建空地图 (25x30)
            for (let y = 0; y < 25; y++) {
                gameState.map[y] = [];
                gameState.explored[y] = [];
                for (let x = 0; x < 30; x++) {
                    gameState.map[y][x] = 1; // 1 = 墙, 0 = 地板
                    gameState.explored[y][x] = false;
                }
            }
            
            // 使用随机游走算法生成地牢
            generateRoomsAndCorridors();
            
            // 放置玩家
            placePlayer();
            
            // 放置出口
            placeExit();
            
            // 放置敌人
            placeEnemies();
            
            // 放置物品
            placeItems();
            
            // 放置商店
            placeShop();
            
            // 根据深度选择主题
            const themeIndex = (gameState.depth - 1) % dungeonThemes.length;
            gameState.theme = dungeonThemes[themeIndex].name;
            
            // 显示当前主题
            document.getElementById('current-theme').textContent = dungeonThemes[themeIndex].displayName;
            
            // 设置游戏板的主题类
            const gameBoard = document.getElementById('game-board');
            dungeonThemes.forEach(theme => {
                gameBoard.classList.remove(`theme-${theme.name}`);
            });
            gameBoard.classList.add(`theme-${gameState.theme}`);
        }

        // 使用房间和走廊生成地牢
        function generateRoomsAndCorridors() {
            // 放置几个随机房间
            const roomCount = 5 + Math.floor(Math.random() * 3);
            let rooms = [];
            
            for (let i = 0; i < roomCount; i++) {
                // 增加房间尺寸
                const width = 4 + Math.floor(Math.random() * 5);  // 4-8的宽度，原来是3-6
                const height = 4 + Math.floor(Math.random() * 5); // 4-8的高度，原来是3-6
                const x = 1 + Math.floor(Math.random() * (28 - width));
                const y = 1 + Math.floor(Math.random() * (23 - height));
                
                // 挖出房间
                for (let ry = y; ry < y + height; ry++) {
                    for (let rx = x; rx < x + width; rx++) {
                        gameState.map[ry][rx] = 0;
                    }
                }
                
                // 如果不是第一个房间，连接到上一个房间
                if (i > 0) {
                    const prevRoom = rooms[i-1];
                    const prevCenterX = Math.floor(prevRoom.x + prevRoom.width / 2);
                    const prevCenterY = Math.floor(prevRoom.y + prevRoom.height / 2);
                    const newCenterX = Math.floor(x + width / 2);
                    const newCenterY = Math.floor(y + height / 2);
                    
                    // 挖出走廊
                    digCorridor(prevCenterX, prevCenterY, newCenterX, newCenterY);
                }
                
                // 保存房间信息
                rooms.push({ x, y, width, height });
            }

            // 生成特殊房间
            gameState.specialRooms = [];
            const specialRoomCount = 2 + Math.floor(Math.random() * 3); // 2-4个特殊房间，原来是1-2个
            const availableRooms = [...rooms];
            const availableSpecialRooms = [...specialRooms];

            for (let i = 0; i < specialRoomCount && availableRooms.length > 0 && availableSpecialRooms.length > 0; i++) {
                // 随机选择一个房间和特殊房间类型
                const roomIndex = Math.floor(Math.random() * availableRooms.length);
                const room = availableRooms.splice(roomIndex, 1)[0];
                
                // 如果特殊房间类型用完了，重新填充
                if (availableSpecialRooms.length === 0) {
                    availableSpecialRooms.push(...specialRooms);
                }
                
                const specialRoomIndex = Math.floor(Math.random() * availableSpecialRooms.length);
                const specialRoomType = availableSpecialRooms.splice(specialRoomIndex, 1)[0];

                // 生成特殊房间
                const specialRoom = generateSpecialRoom(room.x, room.y, room.width, room.height, specialRoomType);
                gameState.specialRooms.push(specialRoom);
            }
        }

        // 挖出走廊
        function digCorridor(x1, y1, x2, y2) {
            let x = x1;
            let y = y1;
            
            // 随机决定先水平还是垂直
            if (Math.random() < 0.5) {
                // 先水平，再垂直
                while (x !== x2) {
                    gameState.map[y][x] = 0;
                    // 增加走廊宽度 - 向上下各扩展一格
                    if (y > 0) gameState.map[y-1][x] = 0;
                    if (y < 24) gameState.map[y+1][x] = 0;
                    x += x2 > x ? 1 : -1;
                }
                while (y !== y2) {
                    gameState.map[y][x] = 0;
                    // 增加走廊宽度 - 向左右各扩展一格
                    if (x > 0) gameState.map[y][x-1] = 0;
                    if (x < 29) gameState.map[y][x+1] = 0;
                    y += y2 > y ? 1 : -1;
                }
            } else {
                // 先垂直，再水平
                while (y !== y2) {
                    gameState.map[y][x] = 0;
                    // 增加走廊宽度 - 向左右各扩展一格
                    if (x > 0) gameState.map[y][x-1] = 0;
                    if (x < 29) gameState.map[y][x+1] = 0;
                    y += y2 > y ? 1 : -1;
                }
                while (x !== x2) {
                    gameState.map[y][x] = 0;
                    // 增加走廊宽度 - 向上下各扩展一格
                    if (y > 0) gameState.map[y-1][x] = 0;
                    if (y < 24) gameState.map[y+1][x] = 0;
                    x += x2 > x ? 1 : -1;
                }
            }
        }

        // 放置玩家
        function placePlayer() {
            // 找到所有地板位置
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0) {
                        floorPositions.push({ x, y });
                    }
                }
            }
            
            // 随机选择一个位置
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.player.x = pos.x;
                gameState.player.y = pos.y;
                
                // 标记周围为已探索
                updateExplored(pos.x, pos.y);
            }
        }

        // 放置出口
        function placeExit() {
            // 找到所有可用的地板位置（必须是地板且远离玩家）
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0) {
                        // 计算与玩家的距离
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        // 确保出口位置至少离玩家10格远
                        if (dist >= 10) {
                            // 检查周围是否有墙（确保不会被完全包围）
                            let hasPath = false;
                            for (let dy = -1; dy <= 1; dy++) {
                                for (let dx = -1; dx <= 1; dx++) {
                                    if (dx === 0 && dy === 0) continue;
                                    const nx = x + dx;
                                    const ny = y + dy;
                                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25 && gameState.map[ny][nx] === 0) {
                                        hasPath = true;
                                        break;
                                    }
                                }
                                if (hasPath) break;
                            }
                            if (hasPath) {
                                floorPositions.push({ x, y });
                            }
                        }
                    }
                }
            }
            
            // 如果找到合适的位置，随机选择一个
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.exit = { x: pos.x, y: pos.y };
            } else {
                // 如果没有找到理想位置，选择任何远离玩家的地板位置
                const fallbackPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0) {
                            const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                            if (dist >= 5) {
                                fallbackPositions.push({ x, y });
                            }
                        }
                    }
                }
                if (fallbackPositions.length > 0) {
                    const pos = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
                    gameState.exit = { x: pos.x, y: pos.y };
                } else {
                                    // 最后的后备方案：选择任何地板位置
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y)) {
                            fallbackPositions.push({ x, y });
                        }
                    }
                }
                    if (fallbackPositions.length > 0) {
                        const pos = fallbackPositions[Math.floor(Math.random() * fallbackPositions.length)];
                        gameState.exit = { x: pos.x, y: pos.y };
                    }
                }
            }
        }

        // 放置敌人
        function placeEnemies() {
            // 清空敌人位置映射
            gameState.entityMap.enemies = {};
            
            // 判断是否是BOSS层
            const isBossLevel = gameState.depth % 8 === 0;
            
            if (isBossLevel) {
                // 放置BOSS
                placeBoss();
                return;
            }
            
            // 根据深度增加敌人数量和实力 - 降低前4层难度
            let baseEnemyCount = 7;
            if (gameState.depth <= 4) baseEnemyCount = 4; // 前4层更少敌人
            const depthFactor = Math.floor(gameState.depth / 2);
            let enemyCount = baseEnemyCount + depthFactor + Math.floor(Math.random() * (gameState.depth <= 4 ? 2 : 4)); // 前4层波动更小
            // 难度影响敌人数量
            const diffForCount = difficulties[gameState.difficulty] || difficulties.normal;
            enemyCount = Math.max(1, enemyCount + (diffForCount.enemyCountDelta || 0));
            
            // 获取当前主题
            const currentThemeObj = dungeonThemes.find(t => t.name === gameState.theme);
            
            for (let i = 0; i < enemyCount; i++) {
                // 找到所有远离玩家的地板位置
                const floorPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y) &&
                            !(x === gameState.exit.x && y === gameState.exit.y)) {
                                // 计算与玩家的距离
                                const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                                // 前4层敌人离玩家更远
                                if (dist > (gameState.depth <= 4 ? 3 : 5)) {
                                    floorPositions.push({ x, y });
                                }
                            }
                        }
                    }
                    
                    // 随机选择一个位置
                    if (floorPositions.length > 0) {
                        const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                        
                        // 选择敌人类型 (随着深度增加更强的敌人)
                        let enemyPool = [...enemyTypes];
                        if (gameState.depth <= 3) {
                            enemyPool = enemyPool.filter(e => !['m','t','a'].includes(e.symbol));
                        }
                        if (gameState.depth > 3) {
                            enemyPool = enemyPool.filter(e => e.exp > 1);
                        }
                        if (gameState.depth > 6) {
                            enemyPool = enemyPool.filter(e => e.exp > 2);
                        }
                        
                        const enemyType = enemyPool[Math.floor(Math.random() * enemyPool.length)];
                        
                        // 难度影响敌人基础属性
                        const diffStat = difficulties[gameState.difficulty] || difficulties.normal;
                        const statMul = diffStat.enemyStatMultiplier || 1;
                        
                        // 根据主题调整敌人名称
                        let enemyName = enemyType.name;
                        if (currentThemeObj && currentThemeObj.enemyNameModifiers && currentThemeObj.enemyNameModifiers[enemyName]) {
                            enemyName = currentThemeObj.enemyNameModifiers[enemyName];
                        }
                        
                        // 根据深度增加敌人实力，前4层无加成
                        let healthBonus = Math.floor(gameState.depth / 2);
                        let attackBonus = Math.floor(gameState.depth / 4);
                        let defenseBonus = Math.floor(gameState.depth / 6);
                        if (gameState.depth <= 4) {
                            healthBonus = 0;
                            attackBonus = 0;
                            defenseBonus = 0;
                        }
                        
                        const enemy = {
                            ...enemyType,
                            name: enemyName,  // 使用主题调整后的名称
                            x: pos.x,
                            y: pos.y,
                            maxHealth: Math.round((enemyType.health + healthBonus) * statMul),
                            health: Math.round((enemyType.health + healthBonus) * statMul),
                            attack: Math.max(1, Math.round((enemyType.attack + attackBonus) * statMul)),
                            defense: Math.max(0, Math.round((enemyType.defense + defenseBonus) * statMul))
                        };
                        
                        // 添加到数组并更新位置映射
                        const index = gameState.enemies.length;
                        gameState.enemies.push(enemy);
                        gameState.entityMap.enemies[`${pos.x},${pos.y}`] = index;
                    }
                }
            }

        // 放置BOSS
        function placeBoss() {
            // 找所有远离玩家的地板位置
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0 && 
                        !(x === gameState.player.x && y === gameState.player.y) &&
                        !(x === gameState.exit.x && y === gameState.exit.y)) {
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        if (dist > 8) {
                            floorPositions.push({ x, y });
                        }
                    }
                }
            }
            // 判断是否16的倍数
            const bossCount = (gameState.depth % 16 === 0) ? 2 : 1;
            const usedPositions = new Set();
            for (let b = 0; b < bossCount; b++) {
                if (floorPositions.length === 0) break;
                // 随机选一个不重复的位置
                let posIdx = Math.floor(Math.random() * floorPositions.length);
                let pos = floorPositions[posIdx];
                // 移除该位置，防止重叠
                floorPositions.splice(posIdx, 1);
                usedPositions.add(`${pos.x},${pos.y}`);
                // 选择BOSS（与原逻辑一致）
                let bossIndex = Math.min(Math.floor(gameState.depth / 8) - 1, bossTypes.length - 1);
                if (gameState.depth > 8) {
                    if (Math.random() < 0.5) {
                        const minIndex = bossIndex;
                        const maxIndex = Math.min(bossIndex + 2, bossTypes.length - 1);
                        bossIndex = minIndex + Math.floor(Math.random() * (maxIndex - minIndex + 1));
                    }
                }
                const bossType = bossTypes[bossIndex];
                const depthBonus = Math.floor(gameState.depth / 3);
                // 在placeBoss函数生成BOSS时应用属性加成
                const bossMultiplier = Math.pow(1.3, gameState.bossDefeatCount || 0);
                // 难度影响BOSS属性
                const diffStat = difficulties[gameState.difficulty] || difficulties.normal;
                const bossStatMul = diffStat.enemyStatMultiplier || 1;
                const boss = {
                    ...bossType,
                    x: pos.x,
                    y: pos.y,
                    maxHealth: Math.round((bossType.health + depthBonus * 8) * bossStatMul),
                    health: Math.round((bossType.health + depthBonus * 8) * bossStatMul),
                    attack: Math.max(1, Math.round((bossType.attack + depthBonus * 2) * bossStatMul)),
                    defense: Math.max(0, Math.round((bossType.defense + depthBonus * 1.5) * bossStatMul)),
                    isBoss: true
                };
                // 添加到数组并更新位置映射
                const index = gameState.enemies.length;
                gameState.enemies.push(boss);
                gameState.entityMap.enemies[`${pos.x},${pos.y}`] = index;
                // 预警消息
                addMessage(`注意! ${boss.name}出现了!`);
                addMessage(boss.description);
                addMessage(`这个强大的敌人拥有 ${boss.defense} 点防御力，请做好充分准备！`);
            }
        }

        // 放置物品
        function placeItems() {
            // 清空物品位置映射
            gameState.entityMap.items = {};
            
            let itemCount = 5 + Math.floor(Math.random() * 4);
            if (gameState.depth <= 4) itemCount += 2; // 前4层多2个物品
            // 难度影响物品数量
            const diffItems = difficulties[gameState.difficulty] || difficulties.normal;
            itemCount = Math.max(1, itemCount + (diffItems.itemCountDelta || 0));
            
            for (let i = 0; i < itemCount; i++) {
                // 找到所有地板位置
                const floorPositions = [];
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        if (gameState.map[y][x] === 0 && 
                            !(x === gameState.player.x && y === gameState.player.y) &&
                            !(x === gameState.exit.x && y === gameState.exit.y) &&
                            !gameState.entityMap.enemies[`${x},${y}`]) {
                                floorPositions.push({ x, y });
                            }
                        }
                    }
                    
                    // 增加前4层回血道具概率
                    let itemPool = [];
                    itemTypes.forEach(item => {
                        let rarity = item.rarity || 1;
                        if (gameState.depth <= 4 && item.type === "health") rarity += 2;
                        for (let j = 0; j < rarity; j++) {
                            itemPool.push(item);
                        }
                    });
                    
                    // 随机选择一个位置
                    if (floorPositions.length > 0) {
                        const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                        
                        const itemType = itemPool[Math.floor(Math.random() * itemPool.length)];
                        const item = {
                            ...itemType,
                            x: pos.x,
                            y: pos.y
                        };
                        
                        // 添加到数组并更新位置映射
                        const index = gameState.items.length;
                        gameState.items.push(item);
                        gameState.entityMap.items[`${pos.x},${pos.y}`] = index;
                    }
                }
            }

        // 生成商店物品
        function generateShopItems() {
            let itemCount = 3 + Math.floor(Math.random() * 2); // 3-4个商品
            // 难度影响商店陈列数量（简单多，困难少）
            const diff = difficulties[gameState.difficulty] || difficulties.normal;
            itemCount = Math.max(1, itemCount + (diff.itemCountDelta > 0 ? Math.min(1, diff.itemCountDelta) : Math.max(-1, diff.itemCountDelta)));
            const availableItems = [...shopItemTypes];
            const selectedItems = [];

            for (let i = 0; i < itemCount && availableItems.length > 0; i++) {
                const index = Math.floor(Math.random() * availableItems.length);
                const item = availableItems.splice(index, 1)[0];
                
                // 根据地牢深度调整价格
                let adjustedPrice = Math.floor(item.price * (1 + (gameState.depth - 1) * 0.2));
                
                // 难度影响价格
                const diff = difficulties[gameState.difficulty] || difficulties.normal;
                adjustedPrice = Math.floor(adjustedPrice * (diff.shopPriceMultiplier || 1));
                
                // 法师商店折扣
                if (gameState.player.classAbilities.shopDiscount) {
                    adjustedPrice = Math.floor(adjustedPrice * (1 - gameState.player.classAbilities.shopDiscount));
                }
                
                selectedItems.push({
                    ...item,
                    price: adjustedPrice
                });
            }

            return selectedItems;
        }

        // 放置商店
        function placeShop() {
            // 找到所有合适的地板位置
            const floorPositions = [];
            for (let y = 0; y < 25; y++) {
                for (let x = 0; x < 30; x++) {
                    if (gameState.map[y][x] === 0 && 
                        !(x === gameState.player.x && y === gameState.player.y) &&
                        !(x === gameState.exit.x && y === gameState.exit.y)) {
                        const dist = Math.abs(x - gameState.player.x) + Math.abs(y - gameState.player.y);
                        if (dist >= 3) {
                            floorPositions.push({ x, y });
                        }
                    }
                }
            }
            
            if (floorPositions.length > 0) {
                const pos = floorPositions[Math.floor(Math.random() * floorPositions.length)];
                gameState.shop = {
                    x: pos.x,
                    y: pos.y,
                    items: generateShopItems()
                };
            }
        }

        // 显示商店界面
        function openShop() {
            const shopModal = document.getElementById('shop-modal');
            const shopItemsContainer = document.getElementById('shop-items');
            shopItemsContainer.innerHTML = '';

            gameState.shop.items.forEach((item, index) => {
                const itemElement = document.createElement('div');
                itemElement.className = 'shop-item';
                itemElement.innerHTML = `
                    <span>${item.name}</span>
                    <span class="shop-item-price">${item.price} 金币</span>
                    <button onclick="buyItem(${index})" ${gameState.player.gold < item.price ? 'disabled' : ''}>购买</button>
                    <div class="shop-item-tooltip">
                        <div class="shop-item-tooltip-title">${item.name}</div>
                        <div>${item.description}</div>
                    </div>
                `;
                shopItemsContainer.appendChild(itemElement);
            });

            shopModal.style.display = 'block';
        }

        // 关闭商店界面
        function closeShop() {
            document.getElementById('shop-modal').style.display = 'none';
        }

        // 购买物品
        function buyItem(index) {
            const item = gameState.shop.items[index];
            if (gameState.player.gold >= item.price) {
                gameState.player.gold -= item.price;
                
                // 应用物品效果
                switch (item.type) {
                    case "health":
                        gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + item.value);
                        addMessage(`你购买并使用了${item.name}, 恢复了 ${item.value} 点生命值!`);
                        break;
                    case "maxHealth":
                        gameState.player.maxHealth += item.value;
                        gameState.player.health += item.value;
                        addMessage(`你购买并使用了${item.name}, 生命上限永久增加 ${item.value}!`);
                        break;
                    case "attack":
                        gameState.player.attack += item.value;
                        addMessage(`你购买并使用了${item.name}, 攻击力暂时增加 ${item.value}!`);
                        break;
                    case "permAttack":
                        gameState.player.attack += item.value;
                        addMessage(`你购买并使用了${item.name}, 攻击力永久增加 ${item.value}!`);
                        break;
                    case "defense":
                        gameState.player.defense += item.value;
                        addMessage(`你购买并使用了${item.name}, 防御力暂时增加 ${item.value}!`);
                        break;
                    case "permDefense":
                        gameState.player.defense += item.value;
                        addMessage(`你购买并使用了${item.name}, 防御力永久增加 ${item.value}!`);
                        break;
                    case "gold":
                        gameState.player.gold += item.value;
                        addMessage(`你拾取了${item.value}金币!`);
                        break;
                }
                
                // 从商店移除物品
                gameState.shop.items.splice(index, 1);
                
                // 更新状态和商店显示
                updateStats();
                openShop();
                
                // 如果商店没有物品了，关闭商店
                if (gameState.shop.items.length === 0) {
                    closeShop();
                    addMessage("商店的商品已经售罄了!");
                }
            }
        }

        // 修改移动玩家函数
        function movePlayer(dx, dy) {
            if (gameState.gameOver) return;
            
            const nx = gameState.player.x + dx;
            const ny = gameState.player.y + dy;
            
            if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25) return;
            if (gameState.map[ny][nx] === 1) {
                addMessage("你撞到了墙上!");
                return;
            }
            
            // 检查是否是特殊房间
            const specialRoom = gameState.specialRooms.find(room => room.x === nx && room.y === ny);
            if (specialRoom && !specialRoom.used) {
                specialRoom.effect(gameState.player);
                specialRoom.used = true; // 标记为已使用
                updateStats();
                // 不return，继续后续移动逻辑
            }
            
            // 使用位置映射检查敌人
            const posKey = `${nx},${ny}`;
            const enemyIndex = gameState.entityMap.enemies[posKey] !== undefined ? 
                                gameState.entityMap.enemies[posKey] : -1;
                                
            if (enemyIndex !== -1) {
                attackEnemy(enemyIndex);
                return;
            }
            
            // 使用位置映射检查物品
            const itemIndex = gameState.entityMap.items[posKey] !== undefined ? 
                               gameState.entityMap.items[posKey] : -1;
                                
            if (itemIndex !== -1) {
                pickUpItem(itemIndex);
                gameState.player.x = nx;
                gameState.player.y = ny;
                updateExplored(nx, ny);
                renderMap();
                return;
            }
            
            // 检查出口
            if (nx === gameState.exit.x && ny === gameState.exit.y) {
                descendDungeon();
                return;
            }
            
            // 移动玩家
            gameState.player.x = nx;
            gameState.player.y = ny;
            
            // 更新探索区域
            updateExplored(nx, ny);
            
            // 渲染地图
            renderMap();
            
            // 敌人回合
            enemyTurn();
        }

        // 更新探索区域
        function updateExplored(x, y) {
            // 标记当前位置和周围8格为已探索
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const nx = x + dx;
                    const ny = y + dy;
                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25) {
                        gameState.explored[ny][nx] = true;
                    }
                }
            }
        }

        // 渲染地图 - 性能优化版
        function renderMap() {
            // 如果已经有渲染请求，则跳过
            if (gameState.renderPending) return;
            
            // 请求下一帧渲染
            gameState.renderPending = true;
            requestAnimationFrame(() => {
                const startTime = performanceMonitor.startTimer();
                
                const board = document.getElementById('game-board');

                // 仅在首次渲染或重新生成地图时完全重建DOM
                if (!board.hasChildNodes() || gameState.fullRenderNeeded) {
                    board.innerHTML = '';
                    
                    for (let y = 0; y < 25; y++) {
                        for (let x = 0; x < 30; x++) {
                            const cell = document.createElement('div');
                            cell.className = 'cell';
                            cell.id = `cell-${x}-${y}`;
                            
                            // 使用事件委托而不是每个格子单独添加事件
                            cell.dataset.x = x;
                            cell.dataset.y = y;
                            
                            board.appendChild(cell);
                        }
                    }
                    
                    // 委托事件处理到父元素
                    if (!board.hasAttribute('data-event-bound')) {
                        board.addEventListener('click', (e) => {
                            const cell = e.target;
                            if (cell.classList.contains('cell')) {
                                const x = parseInt(cell.dataset.x);
                                const y = parseInt(cell.dataset.y);
                                inputHandler.handleCellClick(x, y);
                            }
                        });
                        board.setAttribute('data-event-bound', 'true');
                    }
                    
                    gameState.fullRenderNeeded = false;
                }

                // 创建本地引用以提高性能
                const { map, explored, player, exit, shop, entityMap, specialRooms } = gameState;

                // 计算视野可见区域
                gameState.visibleCells.clear();
                const visionRange = 15; // 视野范围
                
                for (let dy = -visionRange; dy <= visionRange; dy++) {
                    for (let dx = -visionRange; dx <= visionRange; dx++) {
                        const x = player.x + dx;
                        const y = player.y + dy;
                        // 检查是否在地图范围内
                        if (x >= 0 && x < 30 && y >= 0 && y < 25) {
                            // 计算到玩家的距离
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            if (dist <= visionRange) {
                                gameState.visibleCells.add(`${x},${y}`);
                            }
                        }
                    }
                }

                // 只更新可见区域的单元格以减少DOM操作
                for (let y = 0; y < 25; y++) {
                    for (let x = 0; x < 30; x++) {
                        // 检查是否在可见区域或已探索
                        if (!gameState.visibleCells.has(`${x},${y}`) && !explored[y][x]) continue;
                        
                        const cell = document.getElementById(`cell-${x}-${y}`);
                        
                        // 重置单元格类
                        cell.className = 'cell';
                        
                        if (!explored[y][x]) {
                            cell.style.backgroundColor = '#000';
                            cell.textContent = '';
                            continue;
                        }
                        
                        cell.classList.add('explored');
                        cell.style.backgroundColor = ''; // 重置背景色
                        
                        // 检查是否是特殊房间
                        const specialRoom = specialRooms.find(room => room.x === x && room.y === y);
                        
                        if (map[y][x] === 1) {
                            cell.classList.add('wall');
                            cell.textContent = '#';
                        } 
                        else if (x === player.x && y === player.y) {
                            cell.classList.add('player');
                            cell.textContent = '@';
                        }
                        else if (x === exit.x && y === exit.y) {
                            cell.classList.add('exit');
                            cell.textContent = '>';
                        }
                        else if (x === shop.x && y === shop.y) {
                            cell.classList.add('item');
                            cell.textContent = 'S';
                        }
                        else if (specialRoom) {
                            cell.classList.add('special-room');
                            cell.textContent = specialRoom.symbol;
                            // 添加提示信息
                            cell.title = `${specialRoom.name}: ${specialRoom.description}`;
                        }
                        else {
                            const posKey = `${x},${y}`;
                            const enemyIndex = entityMap.enemies[posKey];
                            const itemIndex = entityMap.items[posKey];
                            
                            if (enemyIndex !== undefined) {
                                const enemy = gameState.enemies[enemyIndex];
                                if (enemy.isBoss) {
                                    cell.classList.add('boss');
                                } else {
                                    cell.classList.add('enemy');
                                }
                                cell.textContent = enemy.symbol;
                            } else if (itemIndex !== undefined) {
                                const item = gameState.items[itemIndex];
                                cell.classList.add('item');
                                cell.textContent = item.symbol;
                            } else {
                                cell.textContent = '.';
                            }
                        }
                    }
                }
                
                gameState.renderPending = false;
                
                // 性能监控
                performanceMonitor.renderTime = performanceMonitor.endTimer(startTime);
                performanceMonitor.updateFPS(performance.now());
            });
        }

        // 更新状态显示
        function updateStats() {
            // 如果是开发者Pro，金币锁定999999
            if(gameState.player.class === 'devpro') {
                gameState.player.gold = 999999;
            }
            document.getElementById('depth').textContent = gameState.depth;
            document.getElementById('health').textContent = gameState.player.health;
            document.getElementById('max-health').textContent = gameState.player.maxHealth;
            document.getElementById('attack').textContent = gameState.player.attack;
            document.getElementById('defense').textContent = gameState.player.defense;
            document.getElementById('gold').textContent = gameState.player.gold;
            
            // 更新生命条（取整并夹紧，避免出现 99.999% 导致看起来未满的问题）
            const rawHealthPercent = (gameState.player.health / gameState.player.maxHealth) * 100;
            const healthPercent = Math.max(0, Math.min(100, Math.round(rawHealthPercent)));
            document.getElementById('health-fill').style.width = `${healthPercent}%`;
            
            // 根据生命值百分比更改颜色
            let healthColor = '#5f5'; // 绿色
            if (healthPercent < 30) {
                healthColor = '#f55'; // 红色
            } else if (healthPercent < 60) {
                healthColor = '#fa5'; // 橙色
            }
            document.getElementById('health-fill').style.backgroundColor = healthColor;
        }

        // 添加消息
        function addMessage(msg) {
            gameState.messages.push(msg);
            if (gameState.messages.length > 5) {
                gameState.messages.shift();
            }
            
            const log = document.getElementById('message-log');
            log.innerHTML = gameState.messages.join('<br>');
            log.scrollTop = log.scrollHeight;
        }

        // 修改攻击敌人函数，更新位置映射
        function attackEnemy(enemyIndex) {
            const enemy = gameState.enemies[enemyIndex];
            const isBoss = enemy.isBoss;
            
            // 玩家攻击敌人
            let playerDamage = Math.max(1, gameState.player.attack - enemy.defense);

            // 难度影响玩家对敌人造成的伤害
            const diffDmgDealt = difficulties[gameState.difficulty] || difficulties.normal;
            playerDamage = Math.max(1, Math.round(playerDamage * (diffDmgDealt.playerDamageDealtMultiplier || 1)));
            
            // 应用职业技能
            let criticalHit = false;
            
            // 战士增伤
            if (gameState.player.classAbilities.increaseDamage) {
                playerDamage = Math.floor(playerDamage * (1 + gameState.player.classAbilities.increaseDamage));
            }
            
            // 法师暴击
            if (gameState.player.classAbilities.criticalHitChance && Math.random() < gameState.player.classAbilities.criticalHitChance) {
                playerDamage *= 2;
                criticalHit = true;
            }
            
            // 术士诅咒效果
            if (gameState.player.classAbilities.curseEffect) {
                playerDamage = Math.floor(playerDamage * (1 + gameState.player.classAbilities.curseEffect));
            }
            
            enemy.health -= playerDamage;
            
            // 术士生命偷取
            if (gameState.player.classAbilities.lifeSteal && Math.random() < gameState.player.classAbilities.lifeSteal) {
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + 1);
                addMessage(`你的攻击吸取了敌人的生命力，恢复了1点生命值!`);
            }
            
            if (criticalHit) {
                addMessage(`暴击！你攻击了${enemy.name}, 造成 ${playerDamage} 点伤害!`);
            } else {
                addMessage(`你攻击了${enemy.name}, 造成 ${playerDamage} 点伤害!`);
            }
            
            // 显示BOSS的血量百分比
            if (isBoss) {
                const healthPercent = Math.floor((enemy.health / enemy.maxHealth) * 100);
                addMessage(`${enemy.name} 剩余生命: ${healthPercent}%`);
            }
            
            // 检查敌人是否死亡
            if (enemy.health <= 0) {
                // 从位置映射中移除
                delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
                
                gameState.enemies.splice(enemyIndex, 1);
                gameState.enemiesDefeated++;
                
                // 更新所有大于被删除敌人索引的映射
                for (let key in gameState.entityMap.enemies) {
                    if (gameState.entityMap.enemies[key] > enemyIndex) {
                        gameState.entityMap.enemies[key]--;
                    }
                }
                
                if (isBoss) {
                    // BOSS奖励
                    const bossGold = gameState.depth * 20;
                    gameState.player.gold += bossGold;
                    addMessage(`你击败了BOSS ${enemy.name}!`);
                    addMessage(`你获得了 ${bossGold} 金币的奖励!`);
                    
                    // 额外奖励
                    gameState.player.maxHealth += 2;
                    gameState.player.health += 2;
                    gameState.player.attack += 1;
                    addMessage("你感到自己变得更强大了!");
                } else {
                    addMessage(`你击败了${enemy.name}!`);
                    
                                    // 普通敌人掉落金币
                if (Math.random() < 0.7) {
                    let goldAmount = 1 + Math.floor(Math.random() * 3);

                    // 难度影响金币掉落
                    const diffGold = difficulties[gameState.difficulty] || difficulties.normal;
                    goldAmount = Math.max(1, Math.floor(goldAmount * (diffGold.goldFindMultiplier || 1)));
                    
                    // 盗贼获得更多金币
                    if (gameState.player.classAbilities.increaseLoot) {
                        goldAmount = Math.floor(goldAmount * (1 + gameState.player.classAbilities.increaseLoot));
                    }
                        
                        const newItem = {
                            name: "金币",
                            type: "gold",
                            value: goldAmount,
                            symbol: "$",
                            x: enemy.x,
                            y: enemy.y
                        };
                        
                        // 添加到物品数组并更新位置映射
                        const index = gameState.items.length;
                        gameState.items.push(newItem);
                        gameState.entityMap.items[`${enemy.x},${enemy.y}`] = index;
                        
                        addMessage(`${enemy.name}掉落了${goldAmount}金币!`);
                    }
                }
            } else {
                // 敌人反击 (降低10%攻击力)
                const reducedAttack = Math.floor(enemy.attack * 0.9);
                
                // 盗贼可能闪避攻击
                if (gameState.player.classAbilities.dodgeChance && Math.random() < gameState.player.classAbilities.dodgeChance) {
                    addMessage(`你灵巧地躲过了${enemy.name}的攻击!`);
                } 
                // 猎人陷阱反击
                else if (gameState.player.classAbilities.trapChance && Math.random() < gameState.player.classAbilities.trapChance) {
                    const trapDamage = Math.floor(gameState.player.attack / 2);
                    enemy.health -= trapDamage;
                    addMessage(`你的陷阱触发了，对${enemy.name}造成了${trapDamage}点伤害!`);
                    
                    // 再次检查敌人是否死亡
                    if (enemy.health <= 0) {
                        delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
                        gameState.enemies.splice(enemyIndex, 1);
                        gameState.enemiesDefeated++;
                        addMessage(`你击败了${enemy.name}!`);
                    }
                } else {
                    let enemyDamage;
                    if (isBoss) {
                        // BOSS无视护甲
                        enemyDamage = Math.max(1, reducedAttack);
                    } else {
                        enemyDamage = Math.max(1, reducedAttack - gameState.player.defense);
                    }
                    // 难度影响玩家受到的伤害
                    const diffDmgTaken = difficulties[gameState.difficulty] || difficulties.normal;
                    enemyDamage = Math.max(1, Math.round(enemyDamage * (diffDmgTaken.playerDamageTakenMultiplier || 1)));
                    // 低血量职业前几层减伤
                    if (hasEarlyLowHpClassBuff()) {
                        enemyDamage = Math.max(1, Math.floor(enemyDamage * 0.75));
                    }
                    gameState.player.health -= enemyDamage;
                    updateStats();
                    
                    // BOSS有特殊攻击消息
                    if (isBoss) {
                        const attackMessages = [
                            `${enemy.name}使用强力一击，造成 ${enemyDamage} 点伤害!`,
                            `${enemy.name}发动猛烈攻击，造成 ${enemyDamage} 点伤害!`,
                            `${enemy.name}的攻击击中了你，造成 ${enemyDamage} 点伤害!`
                        ];
                        const msgIndex = Math.floor(Math.random() * attackMessages.length);
                        addMessage(attackMessages[msgIndex]);
                    } else {
                        addMessage(`${enemy.name}反击, 造成 ${enemyDamage} 点伤害!`);
                    }
                    
                    // 检查玩家是否死亡
                    if (gameState.player.health <= 0) {
                        gameOver();
                    }
                }
            }
            
            // 更新状态和地图
            updateStats();
            renderMap();
        }

        // 修改拾取物品函数，更新位置映射
        function pickUpItem(itemIndex) {
            const item = gameState.items[itemIndex];
            
            // 根据物品类型应用效果
            switch (item.type) {
                case "health":
                    let healAmount = item.value;
                    
                    // 牧师治疗增益
                    if (gameState.player.classAbilities.healingBoost) {
                        healAmount = Math.floor(healAmount * (1 + gameState.player.classAbilities.healingBoost));
                    }
                    
                    gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                    addMessage(`你使用了${item.name}, 恢复了 ${healAmount} 点生命值!`);
                    break;
                case "maxHealth":
                    gameState.player.maxHealth += item.value;
                    gameState.player.health += item.value;
                    addMessage(`你使用了${item.name}, 生命上限永久增加 ${item.value}!`);
                    break;
                case "attack":
                    gameState.player.attack += item.value;
                    addMessage(`你使用了${item.name}, 攻击力暂时增加 ${item.value}!`);
                    break;
                case "permAttack":
                    gameState.player.attack += item.value;
                    addMessage(`你使用了${item.name}, 攻击力永久增加 ${item.value}!`);
                    break;
                case "defense":
                    gameState.player.defense += item.value;
                    addMessage(`你使用了${item.name}, 防御力暂时增加 ${item.value}!`);
                    break;
                case "permDefense":
                    gameState.player.defense += item.value;
                    addMessage(`你使用了${item.name}, 防御力永久增加 ${item.value}!`);
                    break;
                case "gold":
                    gameState.player.gold += item.value;
                    addMessage(`你拾取了${item.value}金币!`);
                    break;
                // 新增物品效果
                case "berserk":
                    gameState.player.attack += item.value;
                    gameState.player.defense = Math.max(0, gameState.player.defense - 1);
                    addMessage(`你使用了${item.name}, 进入狂暴状态! 攻击+${item.value}, 防御-1`);
                    break;
                case "stealth":
                    gameState.player.stealth = item.value;
                    addMessage(`你使用了${item.name}, 获得${item.value}回合的隐身效果!`);
                    break;
                
                case "experience":
                    // 随机提升一项属性
                    const attr = Math.floor(Math.random() * 3);
                    switch(attr) {
                        case 0:
                            gameState.player.maxHealth += 2;
                            gameState.player.health += 2;
                            addMessage(`你使用了${item.name}, 生命上限增加了2点!`);
                            break;
                        case 1:
                            gameState.player.attack += 1;
                            addMessage(`你使用了${item.name}, 攻击力增加了1点!`);
                            break;
                        case 2:
                            gameState.player.defense += 1;
                            addMessage(`你使用了${item.name}, 防御力增加了1点!`);
                            break;
                    }
                    break;
            }
            
            // 从位置映射中移除
            delete gameState.entityMap.items[`${item.x},${item.y}`];
            
            // 移除物品
            gameState.items.splice(itemIndex, 1);
            
            // 更新所有大于被删除物品索引的映射
            for (let key in gameState.entityMap.items) {
                if (gameState.entityMap.items[key] > itemIndex) {
                    gameState.entityMap.items[key]--;
                }
            }
            
            // 更新状态
            updateStats();
        }

        // 修改敌人移动函数，更新位置映射
        function tryMoveEnemy(enemyIndex, dx, dy) {
            const enemy = gameState.enemies[enemyIndex];
            const nx = enemy.x + dx;
            const ny = enemy.y + dy;
            
            // 检查边界和墙壁
            if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25 || gameState.map[ny][nx] === 1) {
                return false;
            }
            
            // 使用位置映射检查其他敌人
            const posKey = `${nx},${ny}`;
            if (gameState.entityMap.enemies[posKey] !== undefined && gameState.entityMap.enemies[posKey] !== enemyIndex) {
                return false;
            }
            
            // 使用位置映射检查物品
            if (gameState.entityMap.items[posKey] !== undefined) {
                return false;
            }
            
            // 检查玩家
            if (nx === gameState.player.x && ny === gameState.player.y) {
                // 攻击玩家
                const enemy = gameState.enemies[enemyIndex];
                const damage = Math.max(1, enemy.attack - gameState.player.defense);
                let finalDamage = damage;
                // 低血量职业前几层减伤
                if (hasEarlyLowHpClassBuff()) {
                    finalDamage = Math.max(1, Math.floor(finalDamage * 0.75));
                }
                gameState.player.health -= finalDamage;
                updateStats();
                addMessage(`${enemy.name}攻击了你, 造成 ${finalDamage} 点伤害!`);
                
                // 检查玩家是否死亡
                if (gameState.player.health <= 0) {
                    gameOver();
                }
                
                return true;
            }
            
            // 检查出口
            if (nx === gameState.exit.x && ny === gameState.exit.y) {
                return false;
            }
            
            // 从旧位置的映射中移除
            delete gameState.entityMap.enemies[`${enemy.x},${enemy.y}`];
            
            // 移动敌人
            enemy.x = nx;
            enemy.y = ny;
            
            // 更新位置映射
            gameState.entityMap.enemies[`${nx},${ny}`] = enemyIndex;
            
            return true;
        }

        // 进入下一层
        function descendDungeon() {
            gameState.depth++;
            
            // 只在生日祝福激活时显示
            if (gameState.birthdayEnabled) {
                addMessage("周梓轩生日快乐！");
            }
            
            // 每层奖励金币 (层数 × 10)
            let coinReward = gameState.depth * 10;

            // 难度影响金币
            const diffGold = difficulties[gameState.difficulty] || difficulties.normal;
            coinReward = Math.floor(coinReward * (diffGold.goldFindMultiplier || 1));
            
            // 盗贼获得更多金币
            if (gameState.player.classAbilities.increaseLoot) {
                coinReward = Math.floor(coinReward * (1 + gameState.player.classAbilities.increaseLoot));
            }
            
            gameState.player.gold += coinReward;
            
            // 修复：先更新主题
            // 根据深度选择主题
            const themeIndex = (gameState.depth - 1) % dungeonThemes.length;
            gameState.theme = dungeonThemes[themeIndex].name;
            
            // 如果下一层是BOSS层，提前警告
            if (gameState.depth % 8 === 0) {
                addMessage(`你进入了${getDungeonThemeDisplay()}的第 ${gameState.depth} 层...`);
                addMessage(`警告：这一层有强大的BOSS守护！`);
            } else {
                addMessage(`你进入了${getDungeonThemeDisplay()}的第 ${gameState.depth} 层...`);
            }
            
            if (gameState.depth === 4) {
                addMessage('提醒：从第4层开始会出现"升级怪物"。');
            }
            
            addMessage(`发现了 ${coinReward} 金币!`);
            
            // 牧师每层回复生命
            if (gameState.player.classAbilities.regenPerLevel) {
                const regenAmount = gameState.player.classAbilities.regenPerLevel;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + regenAmount);
                addMessage(`你的治愈能力让你恢复了 ${regenAmount} 点生命值!`);
            }
            
            // 每3层恢复一些生命值
            if (gameState.depth % 3 === 0) {
                const healAmount = 3;
                gameState.player.health = Math.min(gameState.player.maxHealth, gameState.player.health + healAmount);
                addMessage(`深入地下让你感到振奋, 恢复了 ${healAmount} 点生命值!`);
            }
            
            // 生成新地牢
            generateDungeon();
            
            // 更新状态和地图
            updateStats();
            renderMap();
        }

        // 敌人回合
        function enemyTurn() {
            // 检查是否有隐身效果
            if (gameState.player.stealth > 0) {
                gameState.player.stealth--;
                addMessage(`隐身效果剩余 ${gameState.player.stealth} 回合`);
                return; // 隐身时敌人不行动
            }
            
            // 更新空间分区系统
            updateSpatialGrid();
            
            // 只处理玩家附近的敌人，以提高性能
            const nearbyEnemies = [];
            const visionRange = 15; // 相同的视野范围
            
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // 使用空间分区快速找到附近的敌人
            for (let dy = -1; dy <= 1; dy++) {
                for (let dx = -1; dx <= 1; dx++) {
                    const gridX = Math.floor((playerX + dx * gameState.spatialGrid.cellSize) / gameState.spatialGrid.cellSize);
                    const gridY = Math.floor((playerY + dy * gameState.spatialGrid.cellSize) / gameState.spatialGrid.cellSize);
                    const key = `${gridX},${gridY}`;
                    
                    const cellContent = gameState.spatialGrid.grid[key];
                    if (cellContent && cellContent.enemies.length > 0) {
                        cellContent.enemies.forEach(enemyIndex => {
                            const enemy = gameState.enemies[enemyIndex];
                            const dist = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                            if (dist <= visionRange) {
                                nearbyEnemies.push(enemyIndex);
                            }
                        });
                    }
                }
            }
            
            // 如果没有使用空间分区，回退到检查所有敌人
            if (nearbyEnemies.length === 0) {
                for (let i = 0; i < gameState.enemies.length; i++) {
                    const enemy = gameState.enemies[i];
                    const dist = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                    if (dist <= visionRange) {
                        nearbyEnemies.push(i);
                    }
                }
            }
            
            // 只处理附近的敌人
            for (const enemyIndex of nearbyEnemies) {
                const enemy = gameState.enemies[enemyIndex];
                
                // 简单AI: 前4层敌人只在距离1格时才会动
                const distToPlayer = Math.abs(enemy.x - playerX) + Math.abs(enemy.y - playerY);
                if (gameState.depth <= 4 && distToPlayer > 1) continue;
                
                if (distToPlayer <= 3) {
                    // 尝试移动到玩家
                    let dx = 0;
                    let dy = 0;
                    
                    if (Math.random() < 0.7) { // 70%几率向玩家移动
                        if (enemy.x < playerX) dx = 1;
                        else if (enemy.x > playerX) dx = -1;
                        
                        if (enemy.y < playerY) dy = 1;
                        else if (enemy.y > playerY) dy = -1;
                        
                        // 随机决定先移动x还是y
                        if (Math.random() < 0.5) {
                            if (dx !== 0) {
                                tryMoveEnemy(enemyIndex, dx, 0);
                                continue;
                            } else if (dy !== 0) {
                                tryMoveEnemy(enemyIndex, 0, dy);
                                continue;
                            }
                        } else {
                            if (dy !== 0) {
                                tryMoveEnemy(enemyIndex, 0, dy);
                                continue;
                            } else if (dx !== 0) {
                                tryMoveEnemy(enemyIndex, dx, 0);
                                continue;
                            }
                        }
                    }
                } else {
                    // 远离玩家的敌人不行动，以节省性能
                    continue;
                }
            }
            
            // 标记空间分区需要重建
            gameState.spatialGrid.rebuild = true;
            
            // 渲染地图
            renderMap();
        }

        // 游戏结束
        function gameOver() {
            gameState.gameOver = true;
            addMessage("你死了! 游戏结束!");
            
            document.getElementById('final-depth').textContent = gameState.depth;
            document.getElementById('enemies-defeated').textContent = gameState.enemiesDefeated;
            document.getElementById('final-gold').textContent = gameState.player.gold;
            
            // 修复：使用textContent而不是innerHTML+=
            const className = classes[gameState.player.class].name;
            const gameOverEl = document.getElementById('game-over');
            
            // 检查是否已经存在职业信息
            if (!gameOverEl.querySelector('.player-class-info')) {
                const classInfoElement = document.createElement('p');
                classInfoElement.className = 'player-class-info';
                classInfoElement.textContent = `职业: ${className}`;
                gameOverEl.appendChild(classInfoElement);
            } else {
                document.querySelector('.player-class-info').textContent = `职业: ${className}`;
            }
            
            gameOverEl.style.display = 'block';

            // 记录最佳成绩（按最高层数比较）
            const currentRecord = {
                difficulty: gameState.difficulty,
                depth: gameState.depth,
                enemiesDefeated: gameState.enemiesDefeated,
                gold: gameState.player.gold,
                health: Math.max(gameState.player.health),
                maxHealth: gameState.player.maxHealth,
                attack: gameState.player.attack,
                defense: gameState.player.defense,
                class: gameState.player.class
            };
            const best = loadBestRecord();
            if (!best || currentRecord.depth > best.depth) {
                saveBestRecord(currentRecord);
                renderBestRecord();
                addMessage('新纪录！你的最高层数已更新。');
            }
        }

        // 图鉴相关函数
        function showCodexTab(tabName) {
            // 隐藏所有内容
            document.querySelectorAll('.codex-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // 取消所有标签的激活状态
            document.querySelectorAll('.codex-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // 激活选定的标签和内容
            document.getElementById(`${tabName}-content`).classList.add('active');
            document.querySelector(`.codex-tab[onclick="showCodexTab('${tabName}')"]`).classList.add('active');
            
            // 如果是第一次显示，生成内容
            if (document.getElementById(`${tabName}-grid`).innerHTML === '') {
                generateCodexContent(tabName);
            }
        }
        
        function generateCodexContent(tabName) {
            const grid = document.getElementById(`${tabName}-grid`);
            grid.innerHTML = '';
            
            switch(tabName) {
                case 'monsters':
                    enemyTypes.forEach(enemy => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${enemy.name} (${enemy.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${enemy.description}</p>
                                    <p>生命: ${enemy.health} | 攻击: ${enemy.attack} | 防御: ${enemy.defense}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'items':
                    itemTypes.forEach(item => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${item.name} (${item.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${item.description}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'bosses':
                    bossTypes.forEach(boss => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${boss.name} (${boss.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${boss.description}</p>
                                    <p>生命: ${boss.health} | 攻击: ${boss.attack} | 防御: ${boss.defense}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'themes':
                    dungeonThemes.forEach(theme => {
                        // 为主题添加更多详细信息
                        let enemyExamples = '';
                        if (theme.enemyNameModifiers) {
                            const examples = Object.values(theme.enemyNameModifiers).slice(0, 3);
                            if (examples.length > 0) {
                                enemyExamples = `<p>典型敌人: ${examples.join('、')}</p>`;
                            }
                        }
                        
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${theme.displayName}</div>
                                <div class="codex-item-desc">
                                    <p>${theme.description}</p>
                                    ${enemyExamples}
                                </div>
                            </div>
                        `;
                    });
                    break;
                case 'special':
                    specialRooms.forEach(room => {
                        grid.innerHTML += `
                            <div class="codex-item">
                                <div class="codex-item-name">${room.name} (${room.symbol})</div>
                                <div class="codex-item-desc">
                                    <p>${room.description}</p>
                                </div>
                            </div>
                        `;
                    });
                    break;
            }
        }
        
        function openCodex() {
            document.getElementById('codex-modal').style.display = 'block';
            showCodexTab('monsters'); // 默认显示怪物标签
        }
        
        function closeCodex() {
            document.getElementById('codex-modal').style.display = 'none';
        }

        // 添加打开商店的单独函数
        function openShopIfAtLocation() {
            // 检查玩家是否在商店位置
            if (gameState.player.x === gameState.shop.x && gameState.player.y === gameState.shop.y) {
                openShop();
            } else {
                addMessage("你不在商店位置，无法与商人交易。");
            }
        }

        // 初始化事件监听
        function initEventListeners() {
            // 初始化输入处理系统
            inputHandler.init();
            
            // 新游戏按钮
            document.getElementById('new-game-btn').addEventListener('click', initGame);

            // 在职业/难度选择界面按空格键开始
            document.addEventListener('keydown', (e) => {
                const modal = document.getElementById('class-select-modal');
                if (!modal || modal.style.display === 'none') return;
                if (e.code === 'Space') {
                    e.preventDefault();
                    startGameWithClass();
                }
            });
            
            // 重新开始按钮
            document.getElementById('restart-btn').addEventListener('click', initGame);
            
            // 帮助按钮 - 使用自定义对话框替代alert
            document.getElementById('help-btn').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'block';
            });
            
            // 关闭帮助对话框按钮
            document.getElementById('help-close').addEventListener('click', () => {
                document.getElementById('help-modal').style.display = 'none';
                localStorage.setItem('helpShown', 'true'); // 标记为已显示
            });

            // 图鉴按钮
            document.getElementById('codex-btn').addEventListener('click', openCodex);
            
            // 存档按钮
            document.getElementById('save-btn').addEventListener('click', function() {
                if (gameState.gameOver) {
                    addMessage("游戏已结束，无法存档");
                    return;
                }
                showSaveLoadModal(true);
            });
            
            // 读档按钮
            document.getElementById('load-btn').addEventListener('click', function() {
                showSaveLoadModal(false);
            });
        }

        // 个人记录逻辑
        const BEST_RECORD_KEY = 'roguelike_best_record_v1';
        function loadBestRecord() {
            try {
                const raw = localStorage.getItem(BEST_RECORD_KEY);
                if (!raw) return null;
                return JSON.parse(raw);
            } catch { return null; }
        }
        function saveBestRecord(record) {
            try {
                localStorage.setItem(BEST_RECORD_KEY, JSON.stringify(record));
            } catch {}
        }
        function renderBestRecord() {
            const el = document.getElementById('record-content');
            if (!el) return;
            const rec = loadBestRecord();
            if (!rec) { el.textContent = '暂无记录'; el.classList.add('muted'); return; }
            const diffName = (difficulties[rec.difficulty] || difficulties.normal).displayName;
            el.classList.remove('muted');
            el.innerHTML = `
                难度: ${diffName}<br>
                最高层数: ${rec.depth}<br>
                击败敌人: ${rec.enemiesDefeated}<br>
                最终金币: ${rec.gold}<br>
                属性: 生命 ${rec.health}/${rec.maxHealth}，攻 ${rec.attack}，防 ${rec.defense}
            `;
        }

        // 启动游戏
        window.onload = function() {
            initEventListeners();
            loadBestRecord();
            renderBestRecord();

            // 加载存档
            for (let i = 0; i < 3; i++) {
                const savedData = localStorage.getItem(`roguelike_save_${i}`);
                if (savedData) {
                    gameState.saveSlots[i] = JSON.parse(savedData);
                }
            }

            // 默认选中“普通”难度卡片
            selectDifficulty('normal');

            // 强制显示帮助界面（仅首次启动）
            if (!localStorage.getItem('helpShown')) {
                const helpModal = document.getElementById('help-modal');
                const helpCloseBtn = document.getElementById('help-close');
                helpModal.style.display = 'block';
                helpCloseBtn.disabled = true;
                helpCloseBtn.style.opacity = 0.5;
                helpCloseBtn.style.backgroundColor = '#444'; // 灰色
                let countdown = 10;
                helpCloseBtn.textContent = `关闭（${countdown}）`;
                const timer = setInterval(() => {
                    countdown--;
                    if (countdown > 0) {
                        helpCloseBtn.textContent = `关闭（${countdown}）`;
                    } else {
                        clearInterval(timer);
                        helpCloseBtn.disabled = false;
                        helpCloseBtn.style.opacity = 1;
                        helpCloseBtn.textContent = '关闭';
                        helpCloseBtn.style.backgroundColor = '#2196f3'; // 蓝色
                        localStorage.setItem('helpShown', 'true'); // 标记为已显示
                    }
                }, 1000);
            }

            initGame();
        };

        // 添加处理单元格点击的函数
        function handleCellClick(targetX, targetY) {
            if (gameState.gameOver) return;
            // 如果是开发者Air职业，点击地板直接瞬移
            if (gameState.player.class === 'devair') {
                if (gameState.map[targetY][targetX] === 1) return; // 墙不可瞬移
                gameState.player.x = targetX;
                gameState.player.y = targetY;
                updateExplored(targetX, targetY);
                renderMap();
                addMessage(`你瞬移到了(${targetX},${targetY})`);
                enemyTurn();
                return;
            }
            // 如果点击的是墙或未探索区域,不处理
            if (gameState.map[targetY][targetX] === 1 || !gameState.explored[targetY][targetX]) {
                return;
            }
            
            // 获取当前玩家位置
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // 如果点击当前位置,不处理
            if (playerX === targetX && playerY === targetY) {
                return;
            }
            
            // 如果是相邻格子,直接移动
            const dx = targetX - playerX;
            const dy = targetY - playerY;
            
            if (Math.abs(dx) <= 1 && Math.abs(dy) <= 1 && (dx === 0 || dy === 0)) { 
                // 只允许上下左右移动,不允许斜向移动
                movePlayer(dx, dy);
                return;
            }
            
            // 对于远距离点击,使用A*路径查找算法 (替代简单贪心算法)
            findPathAndMove(playerX, playerY, targetX, targetY);
        }

        // A*路径查找算法
        function findPathAndMove(startX, startY, endX, endY) {
            // 节点结构: {x, y, g, h, f, parent}
            const openList = [];
            const closedSet = new Set();
            
            // 启发函数: 曼哈顿距离
            function heuristic(x, y) {
                return Math.abs(x - endX) + Math.abs(y - endY);
            }
            
            // 添加起点到开放列表
            openList.push({
                x: startX,
                y: startY,
                g: 0,
                h: heuristic(startX, startY),
                f: heuristic(startX, startY),
                parent: null
            });
            
            // 当开放列表不为空时继续搜索
            while (openList.length > 0) {
                // 找出f值最小的节点
                let minIndex = 0;
                for (let i = 1; i < openList.length; i++) {
                    if (openList[i].f < openList[minIndex].f) {
                        minIndex = i;
                    }
                }
                
                // 当前节点
                const current = openList[minIndex];
                
                // 如果达到目标，构建路径
                if (current.x === endX && current.y === endY) {
                    let path = [];
                    let temp = current;
                    
                    while (temp.parent) {
                        path.push({x: temp.x, y: temp.y});
                        temp = temp.parent;
                    }
                    
                    path.reverse();
                    
                    // 移动到路径的第一个位置
                    if (path.length > 0) {
                        const nextStep = path[0];
                        const dx = nextStep.x - startX;
                        const dy = nextStep.y - startY;
                        movePlayer(dx, dy);
                    }
                    
                    return;
                }
                
                // 从开放列表中移除当前节点
                openList.splice(minIndex, 1);
                
                // 添加当前节点到关闭集
                closedSet.add(`${current.x},${current.y}`);
                
                // 检查四个方向的邻居
                const directions = [
                    {dx: 0, dy: -1}, // 上
                    {dx: 1, dy: 0},  // 右
                    {dx: 0, dy: 1},  // 下
                    {dx: -1, dy: 0}  // 左
                ];
                
                for (const dir of directions) {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;
                    
                    // 检查边界
                    if (nx < 0 || nx >= 30 || ny < 0 || ny >= 25) continue;
                    
                    // 检查是否是墙或已在关闭集中
                    if (gameState.map[ny][nx] === 1 || closedSet.has(`${nx},${ny}`)) continue;
                    
                    // 计算g值 (路径长度)
                    const g = current.g + 1;
                    
                    // 检查是否已在开放列表中
                    let inOpenList = false;
                    for (let i = 0; i < openList.length; i++) {
                        if (openList[i].x === nx && openList[i].y === ny) {
                            inOpenList = true;
                            
                            // 如果新路径更好，更新
                            if (g < openList[i].g) {
                                openList[i].g = g;
                                openList[i].f = g + openList[i].h;
                                openList[i].parent = current;
                            }
                            break;
                        }
                    }
                    
                    // 如果不在开放列表中，添加
                    if (!inOpenList) {
                        const h = heuristic(nx, ny);
                        openList.push({
                            x: nx,
                            y: ny,
                            g: g,
                            h: h,
                            f: g + h,
                            parent: current
                        });
                    }
                }
                
                // 限制搜索步骤，防止长路径计算过久
                if (openList.length > 100) break;
            }
            
            // 如果没找到路径，使用原来的贪心算法
            movePlayerTowards(endX, endY);
        }

        // 优化父类
        movePlayerTowards = function(targetX, targetY) {
            // 获取当前位置
            const playerX = gameState.player.x;
            const playerY = gameState.player.y;
            
            // 决定是先水平移动还是先垂直移动(随机)
            let dx = 0;
            let dy = 0;
            
            if (Math.random() < 0.5) {
                // 先尝试水平移动
                if (playerX < targetX) dx = 1;
                else if (playerX > targetX) dx = -1;
                
                // 如果已经水平对齐,则垂直移动
                if (dx === 0) {
                    if (playerY < targetY) dy = 1;
                    else if (playerY > targetY) dy = -1;
                }
            } else {
                // 先尝试垂直移动
                if (playerY < targetY) dy = 1;
                else if (playerY > targetY) dy = -1;
                
                // 如果已经垂直对齐,则水平移动
                if (dy === 0) {
                    if (playerX < targetX) dx = 1;
                    else if (playerX > targetX) dx = -1;
                }
            }
            
            // 如果计算出了移动方向,则移动一步
            if (dx !== 0 || dy !== 0) {
                movePlayer(dx, dy);
            }
        };

        // 特殊房间定义
        const specialRooms = [
            {
                name: "祭坛",
                symbol: "A",
                description: "一个神秘的祭坛，可以献祭物品来获得随机增益。",
                effect: function(player) {
                    if (player.gold >= 20) {
                        player.gold -= 20;
                        const effects = [
                            {type: "maxHealth", value: 3, desc: "生命上限+3"},
                            {type: "attack", value: 2, desc: "攻击力+2"},
                            {type: "defense", value: 2, desc: "防御力+2"}
                        ];
                        const effect = effects[Math.floor(Math.random() * effects.length)];
                        player[effect.type] += effect.value;
                        if (effect.type === "maxHealth") player.health += effect.value;
                        addMessage(`你在祭坛献祭了20金币，获得了${effect.desc}！`);
                    } else {
                        addMessage("你需要至少20金币才能在祭坛献祭。");
                    }
                }
            },
            {
                name: "训练场",
                symbol: "T",
                description: "一个古老的训练场，可以消耗金币提升战斗能力。",
                effect: function(player) {
                    if (player.gold >= 30) {
                        player.gold -= 30;
                        player.attack += 1;
                        player.defense += 1;
                        addMessage("你在训练场进行了特训，攻击力和防御力各+1！");
                    } else {
                        addMessage("你需要至少30金币才能使用训练场。");
                    }
                }
            },
            {
                name: "生命之泉",
                symbol: "F",
                description: "一个神奇的泉水，可以恢复生命值。",
                effect: function(player) {
                    const healAmount = Math.floor(player.maxHealth * 0.3);
                    player.health = Math.min(player.maxHealth, player.health + healAmount);
                    addMessage(`你在生命之泉中休息，恢复了${healAmount}点生命值！`);
                }
            },
            {
                name: "宝藏室",
                symbol: "V",
                description: "一个充满财宝的房间，但可能有陷阱。",
                effect: function(player) {
                    if (Math.random() < 0.7) {
                        const gold = 20 + Math.floor(Math.random() * 30);
                        player.gold += gold;
                        addMessage(`你找到了${gold}金币的宝藏！`);
                    } else {
                        const damage = Math.floor(player.maxHealth * 0.2);
                        player.health = Math.max(1, player.health - damage);
                        addMessage(`你触发了陷阱，受到了${damage}点伤害！`);
                    }
                }
            },
            {
                name: "冥想池",
                symbol: "M",
                description: "一个可以平静心灵的水池，沉浸其中能感受到奇妙的力量。",
                effect: function(player) {
                    // 随机提升两项属性
                    const attrs = ["attack", "defense", "maxHealth"];
                    const boostValues = [1, 1, 2]; // 对应属性提升值
                    const usedIndices = new Set();
                    
                    // 随机选择两种不同的属性
                    for (let i = 0; i < 2; i++) {
                        let index;
                        do {
                            index = Math.floor(Math.random() * attrs.length);
                        } while (usedIndices.has(index));
                        
                        usedIndices.add(index);
                        const attr = attrs[index];
                        const value = boostValues[index];
                        
                        player[attr] += value;
                        if (attr === "maxHealth") player.health += value;
                        
                        let attrName = "";
                        if (attr === "attack") attrName = "攻击力";
                        else if (attr === "defense") attrName = "防御力";
                        else if (attr === "maxHealth") attrName = "生命上限";
                        
                        addMessage(`冥想让你的${attrName}提升了${value}点！`);
                    }
                    
                    addMessage("你感到内心平静而强大...");
                }
            },
            {
                name: "锻造炉",
                symbol: "K",
                description: "一个古老的锻造炉，能够用金币强化你的武器或防具。",
                effect: function(player) {
                    if (player.gold >= 40) {
                        player.gold -= 40;
                        
                        // 玩家选择强化攻击或防御
                        const choice = Math.random() < 0.5 ? "attack" : "defense";
                        
                        if (choice === "attack") {
                            player.attack += 2;
                            addMessage("你将金币投入锻造炉，你的武器变得更加锋利！攻击力+2");
                        } else {
                            player.defense += 2;
                            addMessage("你将金币投入锻造炉，你的护甲变得更加坚固！防御力+2");
                        }
                    } else {
                        addMessage("你需要40金币才能使用锻造炉。");
                    }
                }
            }
        ];

        // 生成特殊房间
        function generateSpecialRoom(x, y, width, height, type) {
            // 在房间中央放置特殊标记
            const centerX = Math.floor(x + width / 2);
            const centerY = Math.floor(y + height / 2);
            
            // 扩大特殊房间区域 - 在中心点周围形成一个十字形的特殊区域
            for (let dx = -1; dx <= 1; dx++) {
                for (let dy = -1; dy <= 1; dy++) {
                    const nx = centerX + dx;
                    const ny = centerY + dy;
                    if (nx >= 0 && nx < 30 && ny >= 0 && ny < 25 && 
                        gameState.map[ny][nx] === 0) {
                        // 在特殊房间周围添加装饰性地板
                        gameState.map[ny][nx] = 0; // 确保是地板
                    }
                }
            }
            
            return {
                x: centerX,
                y: centerY,
                ...type,
                used: false
            };
        }

        // 更新空间分区网格
        function updateSpatialGrid() {
            if (!gameState.spatialGrid.rebuild) return;
            
            const { cellSize } = gameState.spatialGrid;
            gameState.spatialGrid.grid = {};
            
            // 添加敌人到空间网格
            gameState.enemies.forEach((enemy, index) => {
                const gridX = Math.floor(enemy.x / cellSize);
                const gridY = Math.floor(enemy.y / cellSize);
                const key = `${gridX},${gridY}`;
                
                if (!gameState.spatialGrid.grid[key]) {
                    gameState.spatialGrid.grid[key] = { enemies: [], items: [] };
                }
                
                gameState.spatialGrid.grid[key].enemies.push(index);
            });
            
            // 添加物品到空间网格
            gameState.items.forEach((item, index) => {
                const gridX = Math.floor(item.x / cellSize);
                const gridY = Math.floor(item.y / cellSize);
                const key = `${gridX},${gridY}`;
                
                if (!gameState.spatialGrid.grid[key]) {
                    gameState.spatialGrid.grid[key] = { enemies: [], items: [] };
                }
                
                gameState.spatialGrid.grid[key].items.push(index);
            });
            
            gameState.spatialGrid.rebuild = false;
        }

        // 获取指定位置的空间分区内容
        function getSpatialGridContent(x, y) {
            const { cellSize } = gameState.spatialGrid;
            const gridX = Math.floor(x / cellSize);
            const gridY = Math.floor(y / cellSize);
            const key = `${gridX},${gridY}`;
            
            return gameState.spatialGrid.grid[key] || { enemies: [], items: [] };
        }

        // 添加存档/读档相关函数
        function showSaveLoadModal(isSave) {
            const modal = document.getElementById('save-load-modal');
            const title = document.getElementById('modal-title');
            const slotsContainer = document.getElementById('save-slots');
            
            title.textContent = isSave ? '选择存档槽' : '选择读档槽';
            slotsContainer.innerHTML = '';
            
            // 生成3个存档槽
            for (let i = 0; i < 3; i++) {
                const slotDiv = document.createElement('div');
                slotDiv.style.display = 'flex';
                slotDiv.style.justifyContent = 'space-between';
                slotDiv.style.alignItems = 'center';
                slotDiv.style.margin = '10px 0';
                slotDiv.style.padding = '10px';
                slotDiv.style.backgroundColor = '#333';
                slotDiv.style.borderRadius = '5px';
                
                const slotInfo = document.createElement('div');
                if (gameState.saveSlots[i]) {
                    const d = gameState.saveSlots[i];
                    const diffName = (d.difficulty && difficulties[d.difficulty]) ? difficulties[d.difficulty].displayName : '普通';
                    slotInfo.innerHTML = `存档 ${i+1}<br>难度: ${diffName} 深度: ${d.depth} 金币: ${d.player.gold}`;
                } else {
                    slotInfo.textContent = `存档 ${i+1} (空)`;
                }
                
                const slotButton = document.createElement('button');
                slotButton.textContent = isSave ? '存档' : '读档';
                slotButton.style.backgroundColor = isSave ? '#4CAF50' : '#2196F3';
                slotButton.style.color = 'white';
                slotButton.style.border = 'none';
                slotButton.style.padding = '5px 10px';
                slotButton.style.borderRadius = '3px';
                slotButton.style.cursor = 'pointer';
                
                slotButton.onclick = (function(slotIndex) {
                    return function() {
                        if (isSave) {
                            saveGame(slotIndex);
                        } else {
                            loadGame(slotIndex);
                        }
                        closeSaveLoadModal();
                    };
                })(i);
                
                // 新增删除按钮
                const deleteButton = document.createElement('button');
                deleteButton.textContent = '删除';
                deleteButton.style.backgroundColor = '#f44336';
                deleteButton.style.color = 'white';
                deleteButton.style.border = 'none';
                deleteButton.style.padding = '5px 10px';
                deleteButton.style.borderRadius = '3px';
                deleteButton.style.cursor = 'pointer';
                deleteButton.style.marginLeft = '10px';
                deleteButton.onclick = (function(slotIndex) {
                    return function() {
                        if (gameState.saveSlots[slotIndex]) {
                            if (confirm(`确定要删除存档 ${slotIndex+1} 吗？`)) {
                                clearSave(slotIndex);
                                showSaveLoadModal(isSave); // 刷新列表
                            }
                        } else {
                            addMessage(`存档 ${slotIndex+1} 为空，无需删除。`);
                        }
                    };
                })(i);
                
                slotDiv.appendChild(slotInfo);
                slotDiv.appendChild(slotButton);
                slotDiv.appendChild(deleteButton);
                slotsContainer.appendChild(slotDiv);
            }
            
            modal.style.display = 'block';
        }

        function closeSaveLoadModal() {
            document.getElementById('save-load-modal').style.display = 'none';
        }

        function saveGame(slotIndex) {
            try {
                const saveData = {
                    player: JSON.parse(JSON.stringify(gameState.player)),
                    depth: gameState.depth,
                    enemiesDefeated: gameState.enemiesDefeated,
                    map: JSON.parse(JSON.stringify(gameState.map)),
                    explored: JSON.parse(JSON.stringify(gameState.explored)),
                    enemies: JSON.parse(JSON.stringify(gameState.enemies)),
                    items: JSON.parse(JSON.stringify(gameState.items)),
                    exit: JSON.parse(JSON.stringify(gameState.exit)),
                    messages: JSON.parse(JSON.stringify(gameState.messages)),
                    shop: JSON.parse(JSON.stringify(gameState.shop)),
                    theme: gameState.theme,
                    specialRooms: JSON.parse(JSON.stringify(gameState.specialRooms)),
                    entityMap: JSON.parse(JSON.stringify(gameState.entityMap)),
                    birthdayEnabled: gameState.birthdayEnabled,
                    difficulty: gameState.difficulty,
                    timestamp: new Date().toLocaleString()
                };

                // 保存到内存和 localStorage
                gameState.saveSlots[slotIndex] = saveData;
                localStorage.setItem(`roguelike_save_${slotIndex}`, JSON.stringify(saveData));
                addMessage(`游戏已保存到存档 ${slotIndex + 1}`);
            } catch (e) {
                console.error("存档失败:", e);
                addMessage("存档失败，可能是存储空间不足！");
            }
        }

        function loadGame(slotIndex) {
            try {
                const savedData = localStorage.getItem(`roguelike_save_${slotIndex}`);
                if (!savedData) {
                    addMessage("该存档槽为空！");
                    return;
                }

                const saveData = JSON.parse(savedData);
                Object.keys(saveData).forEach(key => {
                    if (key !== 'timestamp' && gameState.hasOwnProperty(key)) {
                        gameState[key] = JSON.parse(JSON.stringify(saveData[key]));
                    }
                });

                // 兼容旧版存档无难度字段
                if (!gameState.difficulty) {
                    gameState.difficulty = 'normal';
                }
                selectedDifficulty = gameState.difficulty;

                gameState.currentSaveSlot = slotIndex;
                gameState.fullRenderNeeded = true;
                gameState.spatialGrid.rebuild = true;

                updateStats();
                renderMap();
                addMessage(`已从存档 ${slotIndex + 1} 加载游戏`);
                addMessage(`存档时间: ${saveData.timestamp}`);
            } catch (e) {
                console.error("读档失败:", e);
                addMessage("读档失败，存档可能已损坏！");
            }
        }

        function clearSave(slotIndex) {
            // 从内存中清除
            gameState.saveSlots[slotIndex] = null;
            
            // 从 localStorage 中清除
            localStorage.removeItem(`roguelike_save_${slotIndex}`);
            addMessage(`已清除存档 ${slotIndex + 1}`);
        }

        // 监听T键实现开发者Air瞬移
        document.addEventListener('keydown', function(e) {
            if (gameState.player && gameState.player.class === 'devair' && !gameState.gameOver) {
                if (e.key === 't' || e.key === 'T') {
                    let input = prompt('输入目标坐标（格式：x,y，范围0-29,0-24）：');
                    if (!input) return;
                    let parts = input.split(',');
                    if (parts.length !== 2) { alert('格式错误'); return; }
                    let x = parseInt(parts[0].trim());
                    let y = parseInt(parts[1].trim());
                    if (isNaN(x) || isNaN(y) || x < 0 || x > 29 || y < 0 || y > 24) {
                        alert('坐标超出范围'); return;
                    }
                    if (gameState.map && gameState.map[y] && gameState.map[y][x] === 0) {
                        gameState.player.x = x;
                        gameState.player.y = y;
                        updateExplored(x, y);
                        renderMap();
                        addMessage(`你瞬移到了(${x},${y})`);
                        enemyTurn();
                    } else {
                        alert('目标不是地板，无法瞬移');
                    }
                }
            }
        });
    </script>
</body>
</html>
